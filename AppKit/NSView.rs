//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_options!(
    #[underlying(NSUInteger)]
    /**
      Bitset options for the autoresizingMask
    */
    pub enum NSAutoresizingMaskOptions {
        NSViewNotSizable = 0,
        NSViewMinXMargin = 1,
        NSViewWidthSizable = 2,
        NSViewMaxXMargin = 4,
        NSViewMinYMargin = 8,
        NSViewHeightSizable = 16,
        NSViewMaxYMargin = 32,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSBorderType {
        NSNoBorder = 0,
        NSLineBorder = 1,
        NSBezelBorder = 2,
        NSGrooveBorder = 3,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSViewLayerContentsRedrawPolicy {
        NSViewLayerContentsRedrawNever = 0,
        NSViewLayerContentsRedrawOnSetNeedsDisplay = 1,
        NSViewLayerContentsRedrawDuringViewResize = 2,
        NSViewLayerContentsRedrawBeforeViewResize = 3,
        NSViewLayerContentsRedrawCrossfade = 4,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSViewLayerContentsPlacement {
        NSViewLayerContentsPlacementScaleAxesIndependently = 0,
        NSViewLayerContentsPlacementScaleProportionallyToFit = 1,
        NSViewLayerContentsPlacementScaleProportionallyToFill = 2,
        NSViewLayerContentsPlacementCenter = 3,
        NSViewLayerContentsPlacementTop = 4,
        NSViewLayerContentsPlacementTopRight = 5,
        NSViewLayerContentsPlacementRight = 6,
        NSViewLayerContentsPlacementBottomRight = 7,
        NSViewLayerContentsPlacementBottom = 8,
        NSViewLayerContentsPlacementBottomLeft = 9,
        NSViewLayerContentsPlacementLeft = 10,
        NSViewLayerContentsPlacementTopLeft = 11,
    }
);

pub type NSTrackingRectTag = NSInteger;

pub type NSToolTipTag = NSInteger;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSView")]
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    pub struct NSView;

    #[cfg(feature = "AppKit_NSView")]
    unsafe impl ClassType for NSView {
        #[inherits(NSObject)]
        type Super = NSResponder;
    }
);

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSAccessibility for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSAccessibilityElementProtocol for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSAnimatablePropertyContainer for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSAppearanceCustomization for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSCoding for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSDraggingDestination for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSObjectProtocol for NSView {}

#[cfg(feature = "AppKit_NSView")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSUserInterfaceItemIdentification for NSView {}

extern_methods!(
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[method_id(@__retain_semantics Init initWithFrame:)]
        pub unsafe fn initWithFrame(this: Option<Allocated<Self>>, frame_rect: NSRect) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Option<Allocated<Self>>,
            coder: &NSCoder,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[method_id(@__retain_semantics Other window)]
        pub unsafe fn window(&self) -> Option<Id<NSWindow>>;

        #[method_id(@__retain_semantics Other superview)]
        pub unsafe fn superview(&self) -> Option<Id<NSView>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other subviews)]
        pub unsafe fn subviews(&self) -> Id<NSArray<NSView>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method(setSubviews:)]
        pub unsafe fn setSubviews(&self, subviews: &NSArray<NSView>);

        #[method(isDescendantOf:)]
        pub unsafe fn isDescendantOf(&self, view: &NSView) -> bool;

        #[method_id(@__retain_semantics Other ancestorSharedWithView:)]
        pub unsafe fn ancestorSharedWithView(&self, view: &NSView) -> Option<Id<NSView>>;

        #[method_id(@__retain_semantics Other opaqueAncestor)]
        pub unsafe fn opaqueAncestor(&self) -> Option<Id<NSView>>;

        #[method(isHidden)]
        pub unsafe fn isHidden(&self) -> bool;

        #[method(setHidden:)]
        pub unsafe fn setHidden(&self, hidden: bool);

        #[method(isHiddenOrHasHiddenAncestor)]
        pub unsafe fn isHiddenOrHasHiddenAncestor(&self) -> bool;

        #[method(getRectsBeingDrawn:count:)]
        pub unsafe fn getRectsBeingDrawn_count(
            &self,
            rects: *mut *mut NSRect,
            count: *mut NSInteger,
        );

        #[method(needsToDrawRect:)]
        pub unsafe fn needsToDrawRect(&self, rect: NSRect) -> bool;

        #[method(wantsDefaultClipping)]
        pub unsafe fn wantsDefaultClipping(&self) -> bool;

        #[method(viewDidHide)]
        pub unsafe fn viewDidHide(&self);

        #[method(viewDidUnhide)]
        pub unsafe fn viewDidUnhide(&self);

        #[method(addSubview:)]
        pub unsafe fn addSubview(&self, view: &NSView);

        #[method(addSubview:positioned:relativeTo:)]
        pub unsafe fn addSubview_positioned_relativeTo(
            &self,
            view: &NSView,
            place: NSWindowOrderingMode,
            other_view: Option<&NSView>,
        );

        #[method(sortSubviewsUsingFunction:context:)]
        pub unsafe fn sortSubviewsUsingFunction_context(
            &self,
            compare: unsafe extern "C" fn(
                NonNull<NSView>,
                NonNull<NSView>,
                *mut c_void,
            ) -> NSComparisonResult,
            context: *mut c_void,
        );

        #[cfg(feature = "AppKit_NSWindow")]
        #[method(viewWillMoveToWindow:)]
        pub unsafe fn viewWillMoveToWindow(&self, new_window: Option<&NSWindow>);

        #[method(viewDidMoveToWindow)]
        pub unsafe fn viewDidMoveToWindow(&self);

        #[method(viewWillMoveToSuperview:)]
        pub unsafe fn viewWillMoveToSuperview(&self, new_superview: Option<&NSView>);

        #[method(viewDidMoveToSuperview)]
        pub unsafe fn viewDidMoveToSuperview(&self);

        #[method(didAddSubview:)]
        pub unsafe fn didAddSubview(&self, subview: &NSView);

        #[method(willRemoveSubview:)]
        pub unsafe fn willRemoveSubview(&self, subview: &NSView);

        #[method(removeFromSuperview)]
        pub unsafe fn removeFromSuperview(&self);

        #[method(replaceSubview:with:)]
        pub unsafe fn replaceSubview_with(&self, old_view: &NSView, new_view: &NSView);

        #[method(removeFromSuperviewWithoutNeedingDisplay)]
        pub unsafe fn removeFromSuperviewWithoutNeedingDisplay(&self);

        #[method(viewDidChangeBackingProperties)]
        pub unsafe fn viewDidChangeBackingProperties(&self);

        #[method(postsFrameChangedNotifications)]
        pub unsafe fn postsFrameChangedNotifications(&self) -> bool;

        #[method(setPostsFrameChangedNotifications:)]
        pub unsafe fn setPostsFrameChangedNotifications(
            &self,
            posts_frame_changed_notifications: bool,
        );

        #[method(resizeSubviewsWithOldSize:)]
        pub unsafe fn resizeSubviewsWithOldSize(&self, old_size: NSSize);

        #[method(resizeWithOldSuperviewSize:)]
        pub unsafe fn resizeWithOldSuperviewSize(&self, old_size: NSSize);

        #[method(autoresizesSubviews)]
        pub unsafe fn autoresizesSubviews(&self) -> bool;

        #[method(setAutoresizesSubviews:)]
        pub unsafe fn setAutoresizesSubviews(&self, autoresizes_subviews: bool);

        #[method(autoresizingMask)]
        pub unsafe fn autoresizingMask(&self) -> NSAutoresizingMaskOptions;

        #[method(setAutoresizingMask:)]
        pub unsafe fn setAutoresizingMask(&self, autoresizing_mask: NSAutoresizingMaskOptions);

        #[method(setFrameOrigin:)]
        pub unsafe fn setFrameOrigin(&self, new_origin: NSPoint);

        #[method(setFrameSize:)]
        pub unsafe fn setFrameSize(&self, new_size: NSSize);

        #[method(frame)]
        pub unsafe fn frame(&self) -> NSRect;

        #[method(setFrame:)]
        pub unsafe fn setFrame(&self, frame: NSRect);

        #[method(frameRotation)]
        pub unsafe fn frameRotation(&self) -> CGFloat;

        #[method(setFrameRotation:)]
        pub unsafe fn setFrameRotation(&self, frame_rotation: CGFloat);

        #[method(frameCenterRotation)]
        pub unsafe fn frameCenterRotation(&self) -> CGFloat;

        #[method(setFrameCenterRotation:)]
        pub unsafe fn setFrameCenterRotation(&self, frame_center_rotation: CGFloat);

        #[method(setBoundsOrigin:)]
        pub unsafe fn setBoundsOrigin(&self, new_origin: NSPoint);

        #[method(setBoundsSize:)]
        pub unsafe fn setBoundsSize(&self, new_size: NSSize);

        #[method(boundsRotation)]
        pub unsafe fn boundsRotation(&self) -> CGFloat;

        #[method(setBoundsRotation:)]
        pub unsafe fn setBoundsRotation(&self, bounds_rotation: CGFloat);

        #[method(translateOriginToPoint:)]
        pub unsafe fn translateOriginToPoint(&self, translation: NSPoint);

        #[method(scaleUnitSquareToSize:)]
        pub unsafe fn scaleUnitSquareToSize(&self, new_unit_size: NSSize);

        #[method(rotateByAngle:)]
        pub unsafe fn rotateByAngle(&self, angle: CGFloat);

        #[method(bounds)]
        pub unsafe fn bounds(&self) -> NSRect;

        #[method(setBounds:)]
        pub unsafe fn setBounds(&self, bounds: NSRect);

        #[method(isFlipped)]
        pub unsafe fn isFlipped(&self) -> bool;

        #[method(isRotatedFromBase)]
        pub unsafe fn isRotatedFromBase(&self) -> bool;

        #[method(isRotatedOrScaledFromBase)]
        pub unsafe fn isRotatedOrScaledFromBase(&self) -> bool;

        /**
          A hint as to whether or not this view draws its contents completely opaque or not. Opaque content drawing can allow some optimizations to happen. The default value is NO.
        */
        #[method(isOpaque)]
        pub unsafe fn isOpaque(&self) -> bool;

        #[method(convertPoint:fromView:)]
        pub unsafe fn convertPoint_fromView(
            &self,
            point: NSPoint,
            view: Option<&NSView>,
        ) -> NSPoint;

        #[method(convertPoint:toView:)]
        pub unsafe fn convertPoint_toView(&self, point: NSPoint, view: Option<&NSView>) -> NSPoint;

        #[method(convertSize:fromView:)]
        pub unsafe fn convertSize_fromView(&self, size: NSSize, view: Option<&NSView>) -> NSSize;

        #[method(convertSize:toView:)]
        pub unsafe fn convertSize_toView(&self, size: NSSize, view: Option<&NSView>) -> NSSize;

        #[method(convertRect:fromView:)]
        pub unsafe fn convertRect_fromView(&self, rect: NSRect, view: Option<&NSView>) -> NSRect;

        #[method(convertRect:toView:)]
        pub unsafe fn convertRect_toView(&self, rect: NSRect, view: Option<&NSView>) -> NSRect;

        #[method(backingAlignedRect:options:)]
        pub unsafe fn backingAlignedRect_options(
            &self,
            rect: NSRect,
            options: NSAlignmentOptions,
        ) -> NSRect;

        #[method(centerScanRect:)]
        pub unsafe fn centerScanRect(&self, rect: NSRect) -> NSRect;

        #[method(convertPointToBacking:)]
        pub unsafe fn convertPointToBacking(&self, point: NSPoint) -> NSPoint;

        #[method(convertPointFromBacking:)]
        pub unsafe fn convertPointFromBacking(&self, point: NSPoint) -> NSPoint;

        #[method(convertSizeToBacking:)]
        pub unsafe fn convertSizeToBacking(&self, size: NSSize) -> NSSize;

        #[method(convertSizeFromBacking:)]
        pub unsafe fn convertSizeFromBacking(&self, size: NSSize) -> NSSize;

        #[method(convertRectToBacking:)]
        pub unsafe fn convertRectToBacking(&self, rect: NSRect) -> NSRect;

        #[method(convertRectFromBacking:)]
        pub unsafe fn convertRectFromBacking(&self, rect: NSRect) -> NSRect;

        #[method(convertPointToLayer:)]
        pub unsafe fn convertPointToLayer(&self, point: NSPoint) -> NSPoint;

        #[method(convertPointFromLayer:)]
        pub unsafe fn convertPointFromLayer(&self, point: NSPoint) -> NSPoint;

        #[method(convertSizeToLayer:)]
        pub unsafe fn convertSizeToLayer(&self, size: NSSize) -> NSSize;

        #[method(convertSizeFromLayer:)]
        pub unsafe fn convertSizeFromLayer(&self, size: NSSize) -> NSSize;

        #[method(convertRectToLayer:)]
        pub unsafe fn convertRectToLayer(&self, rect: NSRect) -> NSRect;

        #[method(convertRectFromLayer:)]
        pub unsafe fn convertRectFromLayer(&self, rect: NSRect) -> NSRect;

        /**
          Reports whether AppKit may invoke the view's -drawRect: method on a background thread, where it would otherwise be invoked on the main thread.  Defaults to NO.
        */
        #[method(canDrawConcurrently)]
        pub unsafe fn canDrawConcurrently(&self) -> bool;

        /**
          Reports whether AppKit may invoke the view's -drawRect: method on a background thread, where it would otherwise be invoked on the main thread.  Defaults to NO.
        */
        #[method(setCanDrawConcurrently:)]
        pub unsafe fn setCanDrawConcurrently(&self, can_draw_concurrently: bool);

        /**
          Sets whether AppKit may invoke the view's -drawRect: method on a background thread, where it would otherwise be invoked on the main thread.  Defaults to NO for most kinds of views.  May be set to YES to enable threaded drawing for a particular view instance.  The view's window must also have its "allowsConcurrentViewDrawing" property set to YES (the default) for threading of view drawing to actually take place.
        */
        #[deprecated = "If a view needs display, -drawRect: or -updateLayer will be called automatically when the view is able to draw.  To check whether a view is in a window, call -window.  To check whether a view is hidden, call -isHiddenOrHasHiddenAncestor."]
        #[method(canDraw)]
        pub unsafe fn canDraw(&self) -> bool;

        #[method(setNeedsDisplayInRect:)]
        pub unsafe fn setNeedsDisplayInRect(&self, invalid_rect: NSRect);

        #[method(needsDisplay)]
        pub unsafe fn needsDisplay(&self) -> bool;

        #[method(setNeedsDisplay:)]
        pub unsafe fn setNeedsDisplay(&self, needs_display: bool);

        #[deprecated = "To draw, subclass NSView and implement -drawRect:; AppKit's automatic deferred display mechanism will call -drawRect: as necessary to display the view."]
        #[method(lockFocus)]
        pub unsafe fn lockFocus(&self);

        #[deprecated = "To draw, subclass NSView and implement -drawRect:; AppKit's automatic deferred display mechanism will call -drawRect: as necessary to display the view."]
        #[method(unlockFocus)]
        pub unsafe fn unlockFocus(&self);

        #[deprecated = "To draw, subclass NSView and implement -drawRect:; AppKit's automatic deferred display mechanism will call -drawRect: as necessary to display the view."]
        #[method(lockFocusIfCanDraw)]
        pub unsafe fn lockFocusIfCanDraw(&self) -> bool;

        #[cfg(feature = "AppKit_NSGraphicsContext")]
        #[deprecated = "Use -[NSView displayRectIgnoringOpacity:inContext:] to draw a view subtree into a graphics context."]
        #[method(lockFocusIfCanDrawInContext:)]
        pub unsafe fn lockFocusIfCanDrawInContext(&self, context: &NSGraphicsContext) -> bool;

        #[method_id(@__retain_semantics Other focusView)]
        pub unsafe fn focusView() -> Option<Id<NSView>>;

        #[method(visibleRect)]
        pub unsafe fn visibleRect(&self) -> NSRect;

        #[method(display)]
        pub unsafe fn display(&self);

        #[method(displayIfNeeded)]
        pub unsafe fn displayIfNeeded(&self);

        #[method(displayIfNeededIgnoringOpacity)]
        pub unsafe fn displayIfNeededIgnoringOpacity(&self);

        #[method(displayRect:)]
        pub unsafe fn displayRect(&self, rect: NSRect);

        #[method(displayIfNeededInRect:)]
        pub unsafe fn displayIfNeededInRect(&self, rect: NSRect);

        #[method(displayRectIgnoringOpacity:)]
        pub unsafe fn displayRectIgnoringOpacity(&self, rect: NSRect);

        #[method(displayIfNeededInRectIgnoringOpacity:)]
        pub unsafe fn displayIfNeededInRectIgnoringOpacity(&self, rect: NSRect);

        #[method(drawRect:)]
        pub unsafe fn drawRect(&self, dirty_rect: NSRect);

        #[cfg(feature = "AppKit_NSGraphicsContext")]
        #[method(displayRectIgnoringOpacity:inContext:)]
        pub unsafe fn displayRectIgnoringOpacity_inContext(
            &self,
            rect: NSRect,
            context: &NSGraphicsContext,
        );

        #[cfg(feature = "AppKit_NSBitmapImageRep")]
        #[method_id(@__retain_semantics Other bitmapImageRepForCachingDisplayInRect:)]
        pub unsafe fn bitmapImageRepForCachingDisplayInRect(
            &self,
            rect: NSRect,
        ) -> Option<Id<NSBitmapImageRep>>;

        #[cfg(feature = "AppKit_NSBitmapImageRep")]
        #[method(cacheDisplayInRect:toBitmapImageRep:)]
        pub unsafe fn cacheDisplayInRect_toBitmapImageRep(
            &self,
            rect: NSRect,
            bitmap_image_rep: &NSBitmapImageRep,
        );

        #[method(viewWillDraw)]
        pub unsafe fn viewWillDraw(&self);

        #[method(scrollPoint:)]
        pub unsafe fn scrollPoint(&self, point: NSPoint);

        #[method(scrollRectToVisible:)]
        pub unsafe fn scrollRectToVisible(&self, rect: NSRect) -> bool;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(autoscroll:)]
        pub unsafe fn autoscroll(&self, event: &NSEvent) -> bool;

        #[method(adjustScroll:)]
        pub unsafe fn adjustScroll(&self, new_visible: NSRect) -> NSRect;

        #[deprecated = "Use NSScrollView to achieve scrolling views."]
        #[method(scrollRect:by:)]
        pub unsafe fn scrollRect_by(&self, rect: NSRect, delta: NSSize);

        #[method(translateRectsNeedingDisplayInRect:by:)]
        pub unsafe fn translateRectsNeedingDisplayInRect_by(
            &self,
            clip_rect: NSRect,
            delta: NSSize,
        );

        #[method_id(@__retain_semantics Other hitTest:)]
        pub unsafe fn hitTest(&self, point: NSPoint) -> Option<Id<NSView>>;

        #[method(mouse:inRect:)]
        pub unsafe fn mouse_inRect(&self, point: NSPoint, rect: NSRect) -> bool;

        #[method_id(@__retain_semantics Other viewWithTag:)]
        pub unsafe fn viewWithTag(&self, tag: NSInteger) -> Option<Id<NSView>>;

        #[method(tag)]
        pub unsafe fn tag(&self) -> NSInteger;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(performKeyEquivalent:)]
        pub unsafe fn performKeyEquivalent(&self, event: &NSEvent) -> bool;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(acceptsFirstMouse:)]
        pub unsafe fn acceptsFirstMouse(&self, event: Option<&NSEvent>) -> bool;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(shouldDelayWindowOrderingForEvent:)]
        pub unsafe fn shouldDelayWindowOrderingForEvent(&self, event: &NSEvent) -> bool;

        #[method(needsPanelToBecomeKey)]
        pub unsafe fn needsPanelToBecomeKey(&self) -> bool;

        #[method(mouseDownCanMoveWindow)]
        pub unsafe fn mouseDownCanMoveWindow(&self) -> bool;

        /**
          Deprecated in favor of allowedTouchTypes. Return YES if allowedTouchTypes includes NSTouchTypeMaskIndirect
        */
        #[deprecated = "Use allowedTouchTypes instead"]
        #[method(acceptsTouchEvents)]
        pub unsafe fn acceptsTouchEvents(&self) -> bool;

        /**
          Deprecated in favor of allowedTouchTypes. Return YES if allowedTouchTypes includes NSTouchTypeMaskIndirect
        */
        #[deprecated = "Use allowedTouchTypes instead"]
        #[method(setAcceptsTouchEvents:)]
        pub unsafe fn setAcceptsTouchEvents(&self, accepts_touch_events: bool);

        /**
          In some cases, the user may rest a thumb or other touch on the device. By default, these touches are not delivered and are not included in the event's set of touches. Touches may transition in and out of resting at any time. Unless the view wants restingTouches, began / ended events are simlulated as touches transition from resting to active and vice versa.
        */
        #[method(wantsRestingTouches)]
        pub unsafe fn wantsRestingTouches(&self) -> bool;

        /**
          In some cases, the user may rest a thumb or other touch on the device. By default, these touches are not delivered and are not included in the event's set of touches. Touches may transition in and out of resting at any time. Unless the view wants restingTouches, began / ended events are simlulated as touches transition from resting to active and vice versa.
        */
        #[method(setWantsRestingTouches:)]
        pub unsafe fn setWantsRestingTouches(&self, wants_resting_touches: bool);

        /**
          Get and set how the layer should redraw when resizing and redisplaying. Prior to 10.8, the default value was always set to NSViewLayerContentsRedrawDuringViewResize when an AppKit managed layer was created. In 10.8 and higher, the value is initialized to the appropriate thing for each individual AppKit view. Generally, the default value is NSViewLayerContentsRedrawOnSetNeedsDisplay if the view responds YES to -wantsUpdateLayer. Otherwise, the value is usually NSViewLayerContentsRedrawDuringViewResize, indicating that the view needs to redraw on each step of an animation via a setFrame: change. On 10.8, the value is not encoded by the view.
        */
        #[method(layerContentsRedrawPolicy)]
        pub unsafe fn layerContentsRedrawPolicy(&self) -> NSViewLayerContentsRedrawPolicy;

        /**
          Get and set how the layer should redraw when resizing and redisplaying. Prior to 10.8, the default value was always set to NSViewLayerContentsRedrawDuringViewResize when an AppKit managed layer was created. In 10.8 and higher, the value is initialized to the appropriate thing for each individual AppKit view. Generally, the default value is NSViewLayerContentsRedrawOnSetNeedsDisplay if the view responds YES to -wantsUpdateLayer. Otherwise, the value is usually NSViewLayerContentsRedrawDuringViewResize, indicating that the view needs to redraw on each step of an animation via a setFrame: change. On 10.8, the value is not encoded by the view.
        */
        #[method(setLayerContentsRedrawPolicy:)]
        pub unsafe fn setLayerContentsRedrawPolicy(
            &self,
            layer_contents_redraw_policy: NSViewLayerContentsRedrawPolicy,
        );

        #[method(layerContentsPlacement)]
        pub unsafe fn layerContentsPlacement(&self) -> NSViewLayerContentsPlacement;

        #[method(setLayerContentsPlacement:)]
        pub unsafe fn setLayerContentsPlacement(
            &self,
            layer_contents_placement: NSViewLayerContentsPlacement,
        );

        /**
          Indicates if this view should be a "Layer Backed View". When layer backed, all subviews will subsequently also have a layer set on them (however, wantsLayer will only be YES on views that have had it explicitly set). Contents for a layer are specified in one of two ways: if -wantsUpdateLayer returns YES, then one can directly update the layer's contents (or other properties) in -updateLayer. If -wantsUpdateLayer returns NO, then the layer's contents is filled with whatever is drawn by -drawRect:
        */
        #[method(wantsLayer)]
        pub unsafe fn wantsLayer(&self) -> bool;

        /**
          Indicates if this view should be a "Layer Backed View". When layer backed, all subviews will subsequently also have a layer set on them (however, wantsLayer will only be YES on views that have had it explicitly set). Contents for a layer are specified in one of two ways: if -wantsUpdateLayer returns YES, then one can directly update the layer's contents (or other properties) in -updateLayer. If -wantsUpdateLayer returns NO, then the layer's contents is filled with whatever is drawn by -drawRect:
        */
        #[method(setWantsLayer:)]
        pub unsafe fn setWantsLayer(&self, wants_layer: bool);

        /**
          Layer Backed Views: Return YES if this view supports directly setting the layer properties (such as the contents and backgroundColor) as opposed to filling in the contents with a drawRect: implementation. Most AppKit controls return YES if there is no subclassing involved that would alter the drawing appearance. It will return NO for views that do have subclassing that AppKit does not know about (such as, overriding drawRect:, or other drawing methods).
        */
        #[method(wantsUpdateLayer)]
        pub unsafe fn wantsUpdateLayer(&self) -> bool;

        #[method(updateLayer)]
        pub unsafe fn updateLayer(&self);

        /**
          When canDrawSubviewsIntoLayer is set to YES, and the view is layer-backed (either explicitly with -wantsLayer=YES, or by having a parent view that is layer-backed), the layer will draw all subviews into this view's layer, and each subview will not get an individual layer (the exception to this is a subview which has wantsLayer explicitly set to YES). This is useful for layer-backing a complex set of views that can not be refactored to take advantage of proper resizing and -wantsUpdateLayer==YES. If canDrawSubviewsIntoLayer is YES, the value returned from wantsUpdateLayer will be ignored, and the layer will always have drawRect: invoked to get the layer's contents. The default value is NO. NOTE: These methods should NOT be overridden, and the setter should always be used.
        */
        #[method(canDrawSubviewsIntoLayer)]
        pub unsafe fn canDrawSubviewsIntoLayer(&self) -> bool;

        /**
          When canDrawSubviewsIntoLayer is set to YES, and the view is layer-backed (either explicitly with -wantsLayer=YES, or by having a parent view that is layer-backed), the layer will draw all subviews into this view's layer, and each subview will not get an individual layer (the exception to this is a subview which has wantsLayer explicitly set to YES). This is useful for layer-backing a complex set of views that can not be refactored to take advantage of proper resizing and -wantsUpdateLayer==YES. If canDrawSubviewsIntoLayer is YES, the value returned from wantsUpdateLayer will be ignored, and the layer will always have drawRect: invoked to get the layer's contents. The default value is NO. NOTE: These methods should NOT be overridden, and the setter should always be used.
        */
        #[method(setCanDrawSubviewsIntoLayer:)]
        pub unsafe fn setCanDrawSubviewsIntoLayer(&self, can_draw_subviews_into_layer: bool);

        #[method(layoutSubtreeIfNeeded)]
        pub unsafe fn layoutSubtreeIfNeeded(&self);

        #[method(layout)]
        pub unsafe fn layout(&self);

        #[method(needsLayout)]
        pub unsafe fn needsLayout(&self) -> bool;

        #[method(setNeedsLayout:)]
        pub unsafe fn setNeedsLayout(&self, needs_layout: bool);

        #[method(alphaValue)]
        pub unsafe fn alphaValue(&self) -> CGFloat;

        #[method(setAlphaValue:)]
        pub unsafe fn setAlphaValue(&self, alpha_value: CGFloat);

        /**
          If you have set a custom layer on your view, and it (or one of its sublayers) uses CIFilters, you should set this. You do not need to set this if you are using the backgroundFilters, compositingFilter, or contentFilters properties below. See the release notes for more information.
        */
        #[method(layerUsesCoreImageFilters)]
        pub unsafe fn layerUsesCoreImageFilters(&self) -> bool;

        /**
          If you have set a custom layer on your view, and it (or one of its sublayers) uses CIFilters, you should set this. You do not need to set this if you are using the backgroundFilters, compositingFilter, or contentFilters properties below. See the release notes for more information.
        */
        #[method(setLayerUsesCoreImageFilters:)]
        pub unsafe fn setLayerUsesCoreImageFilters(&self, layer_uses_core_image_filters: bool);

        #[cfg(feature = "AppKit_NSShadow")]
        #[method_id(@__retain_semantics Other shadow)]
        pub unsafe fn shadow(&self) -> Option<Id<NSShadow>>;

        #[cfg(feature = "AppKit_NSShadow")]
        #[method(setShadow:)]
        pub unsafe fn setShadow(&self, shadow: Option<&NSShadow>);

        #[method(postsBoundsChangedNotifications)]
        pub unsafe fn postsBoundsChangedNotifications(&self) -> bool;

        #[method(setPostsBoundsChangedNotifications:)]
        pub unsafe fn setPostsBoundsChangedNotifications(
            &self,
            posts_bounds_changed_notifications: bool,
        );

        #[cfg(feature = "AppKit_NSScrollView")]
        #[method_id(@__retain_semantics Other enclosingScrollView)]
        pub unsafe fn enclosingScrollView(&self) -> Option<Id<NSScrollView>>;

        #[cfg(all(feature = "AppKit_NSEvent", feature = "AppKit_NSMenu"))]
        #[method_id(@__retain_semantics Other menuForEvent:)]
        pub unsafe fn menuForEvent(&self, event: &NSEvent) -> Option<Id<NSMenu>>;

        #[cfg(feature = "AppKit_NSMenu")]
        #[method_id(@__retain_semantics Other defaultMenu)]
        pub unsafe fn defaultMenu() -> Option<Id<NSMenu>>;

        #[cfg(all(feature = "AppKit_NSEvent", feature = "AppKit_NSMenu"))]
        #[method(willOpenMenu:withEvent:)]
        pub unsafe fn willOpenMenu_withEvent(&self, menu: &NSMenu, event: &NSEvent);

        #[cfg(all(feature = "AppKit_NSEvent", feature = "AppKit_NSMenu"))]
        #[method(didCloseMenu:withEvent:)]
        pub unsafe fn didCloseMenu_withEvent(&self, menu: &NSMenu, event: Option<&NSEvent>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other toolTip)]
        pub unsafe fn toolTip(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setToolTip:)]
        pub unsafe fn setToolTip(&self, tool_tip: Option<&NSString>);

        #[method(addToolTipRect:owner:userData:)]
        pub unsafe fn addToolTipRect_owner_userData(
            &self,
            rect: NSRect,
            owner: &Object,
            data: *mut c_void,
        ) -> NSToolTipTag;

        #[method(removeToolTip:)]
        pub unsafe fn removeToolTip(&self, tag: NSToolTipTag);

        #[method(removeAllToolTips)]
        pub unsafe fn removeAllToolTips(&self);

        #[method(viewWillStartLiveResize)]
        pub unsafe fn viewWillStartLiveResize(&self);

        #[method(viewDidEndLiveResize)]
        pub unsafe fn viewDidEndLiveResize(&self);

        /**
          inLiveResize can be called at any time to determine if the window is performing a live resize or not. Drawing optimizations can be done when the view is being live-resized.
        */
        #[method(inLiveResize)]
        pub unsafe fn inLiveResize(&self) -> bool;

        /**
          A view that returns YES for -preservesContentDuringLiveResize is responsible for invalidating its own dirty rects during live resize
        */
        #[method(preservesContentDuringLiveResize)]
        pub unsafe fn preservesContentDuringLiveResize(&self) -> bool;

        /**
          -rectPreservedDuringLiveResize indicates the rect the view previously occupied, in the current coordinate system of the view
        */
        #[method(rectPreservedDuringLiveResize)]
        pub unsafe fn rectPreservedDuringLiveResize(&self) -> NSRect;

        #[cfg(feature = "AppKit_NSTextInputContext")]
        /**
          Text Input
         Returns NSTextInputContext object for the receiver. Returns nil if the receiver doesn't conform to NSTextInputClient protocol.
        */
        #[method_id(@__retain_semantics Other inputContext)]
        pub unsafe fn inputContext(&self) -> Option<Id<NSTextInputContext>>;

        #[method(rectForSmartMagnificationAtPoint:inRect:)]
        pub unsafe fn rectForSmartMagnificationAtPoint_inRect(
            &self,
            location: NSPoint,
            visible_rect: NSRect,
        ) -> NSRect;

        /**
          Get and set the user interface layout direction. By default, a basic NSView may not respect the User Interface Layout Direction that is uniquely set on it, and it is up to the developer and supporting subclasses to correctly implement a Right To Left layout implementation. The default value is set to [NSApp userInterfaceLayoutDirection].
        */
        #[method(userInterfaceLayoutDirection)]
        pub unsafe fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;

        /**
          Get and set the user interface layout direction. By default, a basic NSView may not respect the User Interface Layout Direction that is uniquely set on it, and it is up to the developer and supporting subclasses to correctly implement a Right To Left layout implementation. The default value is set to [NSApp userInterfaceLayoutDirection].
        */
        #[method(setUserInterfaceLayoutDirection:)]
        pub unsafe fn setUserInterfaceLayoutDirection(
            &self,
            user_interface_layout_direction: NSUserInterfaceLayoutDirection,
        );

        #[method(prepareForReuse)]
        pub unsafe fn prepareForReuse(&self);

        /**
          A subclass of any NSScrollView, NSClipView or the NSScrollView's documentView can override this method to verify that its customizations are compatible with 10.9's responsive scrolling behavior. By default, AppKit assumes that a ScrollView is responsive scrolling compatible if it and its clipview and document view do not override certain methods such as -scrollWheel: (See documentation for the expanded list). However, these views may still opt into responsive scrolling if they work with the new scrolling behavior by overriding and returning YES for this method. Likewise, the same set of views may return NO to explicitly opt out of responsive scrolling.
        */
        #[method(isCompatibleWithResponsiveScrolling)]
        pub unsafe fn isCompatibleWithResponsiveScrolling() -> bool;

        #[method(prepareContentInRect:)]
        pub unsafe fn prepareContentInRect(&self, rect: NSRect);

        /**
          The preparedContentRect is the area of the NSView that has full content coverage. In general, this should be called with the area that is filled in fully with views.  Set this with a value equal to the visibleRect to have overdraw start from the visibleRect and automatically grow larger on idle, as is needed for optimal system performance. The result of preparedContentRect may include the visibleRect, and may not include it if the previously prepared area has been scrolled away.
        */
        #[method(preparedContentRect)]
        pub unsafe fn preparedContentRect(&self) -> NSRect;

        /**
          The preparedContentRect is the area of the NSView that has full content coverage. In general, this should be called with the area that is filled in fully with views.  Set this with a value equal to the visibleRect to have overdraw start from the visibleRect and automatically grow larger on idle, as is needed for optimal system performance. The result of preparedContentRect may include the visibleRect, and may not include it if the previously prepared area has been scrolled away.
        */
        #[method(setPreparedContentRect:)]
        pub unsafe fn setPreparedContentRect(&self, prepared_content_rect: NSRect);

        /**
          allowsVibrancy is queried when a vibrant appearance is used on a view hierarchy. When allowsVibrancy returns YES, the view will have an appropriate measure taken to ensure it is vibrant on top of its given material.

        Specific subclasses, such as NSControl, will answer this question based on the artwork they draw for a given appearance.
        */
        #[method(allowsVibrancy)]
        pub unsafe fn allowsVibrancy(&self) -> bool;

        #[method(viewDidChangeEffectiveAppearance)]
        pub unsafe fn viewDidChangeEffectiveAppearance(&self);
    }
);

extern_protocol!(
    pub unsafe trait NSViewToolTipOwner: NSObjectProtocol {
        #[cfg(all(feature = "AppKit_NSView", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other view:stringForToolTip:point:userData:)]
        unsafe fn view_stringForToolTip_point_userData(
            &self,
            view: &NSView,
            tag: NSToolTipTag,
            point: NSPoint,
            data: *mut c_void,
        ) -> Id<NSString>;
    }

    unsafe impl ProtocolType for dyn NSViewToolTipOwner {}
);

extern_methods!(
    /// NSKeyboardUI
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[method_id(@__retain_semantics Other nextKeyView)]
        pub unsafe fn nextKeyView(&self) -> Option<Id<NSView>>;

        #[method(setNextKeyView:)]
        pub unsafe fn setNextKeyView(&self, next_key_view: Option<&NSView>);

        #[method_id(@__retain_semantics Other previousKeyView)]
        pub unsafe fn previousKeyView(&self) -> Option<Id<NSView>>;

        #[method_id(@__retain_semantics Other nextValidKeyView)]
        pub unsafe fn nextValidKeyView(&self) -> Option<Id<NSView>>;

        #[method_id(@__retain_semantics Other previousValidKeyView)]
        pub unsafe fn previousValidKeyView(&self) -> Option<Id<NSView>>;

        #[method(canBecomeKeyView)]
        pub unsafe fn canBecomeKeyView(&self) -> bool;

        #[method(setKeyboardFocusRingNeedsDisplayInRect:)]
        pub unsafe fn setKeyboardFocusRingNeedsDisplayInRect(&self, rect: NSRect);

        #[method(focusRingType)]
        pub unsafe fn focusRingType(&self) -> NSFocusRingType;

        #[method(setFocusRingType:)]
        pub unsafe fn setFocusRingType(&self, focus_ring_type: NSFocusRingType);

        #[method(defaultFocusRingType)]
        pub unsafe fn defaultFocusRingType() -> NSFocusRingType;

        #[method(drawFocusRingMask)]
        pub unsafe fn drawFocusRingMask(&self);

        #[method(focusRingMaskBounds)]
        pub unsafe fn focusRingMaskBounds(&self) -> NSRect;

        #[method(noteFocusRingMaskChanged)]
        pub unsafe fn noteFocusRingMaskChanged(&self);
    }
);

extern_methods!(
    /// NSPrinting
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(feature = "AppKit_NSPasteboard")]
        #[method(writeEPSInsideRect:toPasteboard:)]
        pub unsafe fn writeEPSInsideRect_toPasteboard(
            &self,
            rect: NSRect,
            pasteboard: &NSPasteboard,
        );

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other dataWithEPSInsideRect:)]
        pub unsafe fn dataWithEPSInsideRect(&self, rect: NSRect) -> Id<NSData>;

        #[cfg(feature = "AppKit_NSPasteboard")]
        #[method(writePDFInsideRect:toPasteboard:)]
        pub unsafe fn writePDFInsideRect_toPasteboard(
            &self,
            rect: NSRect,
            pasteboard: &NSPasteboard,
        );

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other dataWithPDFInsideRect:)]
        pub unsafe fn dataWithPDFInsideRect(&self, rect: NSRect) -> Id<NSData>;

        #[method(print:)]
        pub unsafe fn print(&self, sender: Option<&Object>);

        #[method(knowsPageRange:)]
        pub unsafe fn knowsPageRange(&self, range: NSRangePointer) -> bool;

        #[method(heightAdjustLimit)]
        pub unsafe fn heightAdjustLimit(&self) -> CGFloat;

        #[method(widthAdjustLimit)]
        pub unsafe fn widthAdjustLimit(&self) -> CGFloat;

        #[method(adjustPageWidthNew:left:right:limit:)]
        pub unsafe fn adjustPageWidthNew_left_right_limit(
            &self,
            new_right: NonNull<CGFloat>,
            old_left: CGFloat,
            old_right: CGFloat,
            right_limit: CGFloat,
        );

        #[method(adjustPageHeightNew:top:bottom:limit:)]
        pub unsafe fn adjustPageHeightNew_top_bottom_limit(
            &self,
            new_bottom: NonNull<CGFloat>,
            old_top: CGFloat,
            old_bottom: CGFloat,
            bottom_limit: CGFloat,
        );

        #[method(rectForPage:)]
        pub unsafe fn rectForPage(&self, page: NSInteger) -> NSRect;

        #[method(locationOfPrintRect:)]
        pub unsafe fn locationOfPrintRect(&self, rect: NSRect) -> NSPoint;

        #[method(drawPageBorderWithSize:)]
        pub unsafe fn drawPageBorderWithSize(&self, border_size: NSSize);

        #[cfg(feature = "Foundation_NSAttributedString")]
        #[method_id(@__retain_semantics Other pageHeader)]
        pub unsafe fn pageHeader(&self) -> Id<NSAttributedString>;

        #[cfg(feature = "Foundation_NSAttributedString")]
        #[method_id(@__retain_semantics Other pageFooter)]
        pub unsafe fn pageFooter(&self) -> Id<NSAttributedString>;

        #[deprecated = "This is never invoked and the NSView implementation does nothing"]
        #[method(drawSheetBorderWithSize:)]
        pub unsafe fn drawSheetBorderWithSize(&self, border_size: NSSize);

        #[cfg(feature = "Foundation_NSString")]
        /**
          Printing
         Returns print job title. Default implementation first tries its window's NSDocument (displayName), then window's title
        */
        #[method_id(@__retain_semantics Other printJobTitle)]
        pub unsafe fn printJobTitle(&self) -> Id<NSString>;

        #[method(beginDocument)]
        pub unsafe fn beginDocument(&self);

        #[method(endDocument)]
        pub unsafe fn endDocument(&self);

        #[method(beginPageInRect:atPlacement:)]
        pub unsafe fn beginPageInRect_atPlacement(&self, rect: NSRect, location: NSPoint);

        #[method(endPage)]
        pub unsafe fn endPage(&self);
    }
);

extern_methods!(
    /// NSDrag
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(all(
            feature = "AppKit_NSDraggingItem",
            feature = "AppKit_NSDraggingSession",
            feature = "AppKit_NSEvent",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Other beginDraggingSessionWithItems:event:source:)]
        pub unsafe fn beginDraggingSessionWithItems_event_source(
            &self,
            items: &NSArray<NSDraggingItem>,
            event: &NSEvent,
            source: &ProtocolObject<dyn NSDraggingSource>,
        ) -> Id<NSDraggingSession>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other registeredDraggedTypes)]
        pub unsafe fn registeredDraggedTypes(&self) -> Id<NSArray<NSPasteboardType>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method(registerForDraggedTypes:)]
        pub unsafe fn registerForDraggedTypes(&self, new_types: &NSArray<NSPasteboardType>);

        #[method(unregisterDraggedTypes)]
        pub unsafe fn unregisterDraggedTypes(&self);
    }
);

typed_enum!(
    pub type NSViewFullScreenModeOptionKey = NSString;
);

extern_static!(NSFullScreenModeAllScreens: &'static NSViewFullScreenModeOptionKey);

extern_static!(NSFullScreenModeSetting: &'static NSViewFullScreenModeOptionKey);

extern_static!(NSFullScreenModeWindowLevel: &'static NSViewFullScreenModeOptionKey);

extern_static!(
    NSFullScreenModeApplicationPresentationOptions: &'static NSViewFullScreenModeOptionKey
);

extern_methods!(
    /// NSFullScreenMode
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(all(feature = "AppKit_NSScreen", feature = "Foundation_NSDictionary"))]
        #[method(enterFullScreenMode:withOptions:)]
        pub unsafe fn enterFullScreenMode_withOptions(
            &self,
            screen: &NSScreen,
            options: Option<&NSDictionary<NSViewFullScreenModeOptionKey, Object>>,
        ) -> bool;

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method(exitFullScreenModeWithOptions:)]
        pub unsafe fn exitFullScreenModeWithOptions(
            &self,
            options: Option<&NSDictionary<NSViewFullScreenModeOptionKey, Object>>,
        );

        #[method(isInFullScreenMode)]
        pub unsafe fn isInFullScreenMode(&self) -> bool;
    }
);

typed_enum!(
    pub type NSDefinitionOptionKey = NSString;
);

extern_static!(NSDefinitionPresentationTypeKey: &'static NSDefinitionOptionKey);

typed_enum!(
    pub type NSDefinitionPresentationType = NSString;
);

extern_static!(NSDefinitionPresentationTypeOverlay: &'static NSDefinitionPresentationType);

extern_static!(
    NSDefinitionPresentationTypeDictionaryApplication: &'static NSDefinitionPresentationType
);

extern_methods!(
    /// NSDefinition
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(feature = "Foundation_NSAttributedString")]
        #[method(showDefinitionForAttributedString:atPoint:)]
        pub unsafe fn showDefinitionForAttributedString_atPoint(
            &self,
            attr_string: Option<&NSAttributedString>,
            text_baseline_origin: NSPoint,
        );

        #[cfg(all(
            feature = "Foundation_NSAttributedString",
            feature = "Foundation_NSDictionary"
        ))]
        #[method(showDefinitionForAttributedString:range:options:baselineOriginProvider:)]
        pub unsafe fn showDefinitionForAttributedString_range_options_baselineOriginProvider(
            &self,
            attr_string: Option<&NSAttributedString>,
            target_range: NSRange,
            options: Option<&NSDictionary<NSDefinitionOptionKey, Object>>,
            origin_provider: Option<&Block<(NSRange,), NSPoint>>,
        );
    }
);

extern_methods!(
    /// NSFindIndicator
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        /**
          When this method returns YES, the receiver or one of its ancestors is being drawn for a find indicator, meaning the receiver should draw so its contents will be easily readable.
        */
        #[method(isDrawingFindIndicator)]
        pub unsafe fn isDrawingFindIndicator(&self) -> bool;
    }
);

extern_methods!(
    /// NSGestureRecognizer
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(all(feature = "AppKit_NSGestureRecognizer", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other gestureRecognizers)]
        pub unsafe fn gestureRecognizers(&self) -> Id<NSArray<NSGestureRecognizer>>;

        #[cfg(all(feature = "AppKit_NSGestureRecognizer", feature = "Foundation_NSArray"))]
        #[method(setGestureRecognizers:)]
        pub unsafe fn setGestureRecognizers(
            &self,
            gesture_recognizers: &NSArray<NSGestureRecognizer>,
        );

        #[cfg(feature = "AppKit_NSGestureRecognizer")]
        #[method(addGestureRecognizer:)]
        pub unsafe fn addGestureRecognizer(&self, gesture_recognizer: &NSGestureRecognizer);

        #[cfg(feature = "AppKit_NSGestureRecognizer")]
        #[method(removeGestureRecognizer:)]
        pub unsafe fn removeGestureRecognizer(&self, gesture_recognizer: &NSGestureRecognizer);
    }
);

extern_methods!(
    /// NSTouchBar
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        /**
          Defaults to NSTouchTypeDirect if linked on or after 10_12, 0 otherwise
        */
        #[method(allowedTouchTypes)]
        pub unsafe fn allowedTouchTypes(&self) -> NSTouchTypeMask;

        /**
          Defaults to NSTouchTypeDirect if linked on or after 10_12, 0 otherwise
        */
        #[method(setAllowedTouchTypes:)]
        pub unsafe fn setAllowedTouchTypes(&self, allowed_touch_types: NSTouchTypeMask);
    }
);

extern_methods!(
    /// NSSafeAreas
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        /**
          Indicates the potentially-obscured distance from each edge of the view (e.g, not behind the window title bar, etc., if present).
        */
        #[method(safeAreaInsets)]
        pub unsafe fn safeAreaInsets(&self) -> NSEdgeInsets;

        /**
          Configurable insets added to insets inherited from the superview (if any), and contributing to self.safeAreaInsets.
        */
        #[method(additionalSafeAreaInsets)]
        pub unsafe fn additionalSafeAreaInsets(&self) -> NSEdgeInsets;

        /**
          Configurable insets added to insets inherited from the superview (if any), and contributing to self.safeAreaInsets.
        */
        #[method(setAdditionalSafeAreaInsets:)]
        pub unsafe fn setAdditionalSafeAreaInsets(&self, additional_safe_area_insets: NSEdgeInsets);

        #[cfg(feature = "AppKit_NSLayoutGuide")]
        /**
          This layout guide reflects the safe area for this view (i.e., the frame minus safeAreaInsets), and provides a convenient way to arrange content relative to the safe area using auto layout.
        */
        #[method_id(@__retain_semantics Other safeAreaLayoutGuide)]
        pub unsafe fn safeAreaLayoutGuide(&self) -> Id<NSLayoutGuide>;

        /**
          The safe area for this view expressed as a rectangle in the view's coordinate space.
        */
        #[method(safeAreaRect)]
        pub unsafe fn safeAreaRect(&self) -> NSRect;

        #[cfg(feature = "AppKit_NSLayoutGuide")]
        /**
          This layout guide provides the recommended amount of padding for content inside a view.
        */
        #[method_id(@__retain_semantics Other layoutMarginsGuide)]
        pub unsafe fn layoutMarginsGuide(&self) -> Id<NSLayoutGuide>;
    }
);

extern_methods!(
    /// NSTrackingArea
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(feature = "AppKit_NSTrackingArea")]
        #[method(addTrackingArea:)]
        pub unsafe fn addTrackingArea(&self, tracking_area: &NSTrackingArea);

        #[cfg(feature = "AppKit_NSTrackingArea")]
        #[method(removeTrackingArea:)]
        pub unsafe fn removeTrackingArea(&self, tracking_area: &NSTrackingArea);

        #[cfg(all(feature = "AppKit_NSTrackingArea", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other trackingAreas)]
        pub unsafe fn trackingAreas(&self) -> Id<NSArray<NSTrackingArea>>;

        #[method(updateTrackingAreas)]
        pub unsafe fn updateTrackingAreas(&self);

        #[cfg(feature = "AppKit_NSCursor")]
        #[method(addCursorRect:cursor:)]
        pub unsafe fn addCursorRect_cursor(&self, rect: NSRect, object: &NSCursor);

        #[cfg(feature = "AppKit_NSCursor")]
        #[method(removeCursorRect:cursor:)]
        pub unsafe fn removeCursorRect_cursor(&self, rect: NSRect, object: &NSCursor);

        #[method(discardCursorRects)]
        pub unsafe fn discardCursorRects(&self);

        #[method(resetCursorRects)]
        pub unsafe fn resetCursorRects(&self);

        #[method(addTrackingRect:owner:userData:assumeInside:)]
        pub unsafe fn addTrackingRect_owner_userData_assumeInside(
            &self,
            rect: NSRect,
            owner: &Object,
            data: *mut c_void,
            flag: bool,
        ) -> NSTrackingRectTag;

        #[method(removeTrackingRect:)]
        pub unsafe fn removeTrackingRect(&self, tag: NSTrackingRectTag);
    }
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(all(
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSImage",
            feature = "AppKit_NSPasteboard"
        ))]
        #[deprecated = "Use -beginDraggingSessionWithItems:event:source: instead"]
        #[method(dragImage:at:offset:event:pasteboard:source:slideBack:)]
        pub unsafe fn dragImage_at_offset_event_pasteboard_source_slideBack(
            &self,
            image: &NSImage,
            view_location: NSPoint,
            initial_offset: NSSize,
            event: &NSEvent,
            pboard: &NSPasteboard,
            source_obj: &Object,
            slide_flag: bool,
        );

        #[cfg(all(feature = "AppKit_NSEvent", feature = "Foundation_NSString"))]
        #[deprecated = "Use -beginDraggingSessionWithItems:event:source: instead"]
        #[method(dragFile:fromRect:slideBack:event:)]
        pub unsafe fn dragFile_fromRect_slideBack_event(
            &self,
            filename: &NSString,
            rect: NSRect,
            flag: bool,
            event: &NSEvent,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSEvent",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString"
        ))]
        #[deprecated = "Use -beginDraggingSessionWithItems:event:source: with an NSFilePromiseProvider instead"]
        #[method(dragPromisedFilesOfTypes:fromRect:source:slideBack:event:)]
        pub unsafe fn dragPromisedFilesOfTypes_fromRect_source_slideBack_event(
            &self,
            type_array: &NSArray<NSString>,
            rect: NSRect,
            source_object: &Object,
            flag: bool,
            event: &NSEvent,
        ) -> bool;

        #[deprecated]
        #[method(convertPointToBase:)]
        pub unsafe fn convertPointToBase(&self, point: NSPoint) -> NSPoint;

        #[deprecated]
        #[method(convertPointFromBase:)]
        pub unsafe fn convertPointFromBase(&self, point: NSPoint) -> NSPoint;

        #[deprecated]
        #[method(convertSizeToBase:)]
        pub unsafe fn convertSizeToBase(&self, size: NSSize) -> NSSize;

        #[deprecated]
        #[method(convertSizeFromBase:)]
        pub unsafe fn convertSizeFromBase(&self, size: NSSize) -> NSSize;

        #[deprecated]
        #[method(convertRectToBase:)]
        pub unsafe fn convertRectToBase(&self, rect: NSRect) -> NSRect;

        #[deprecated]
        #[method(convertRectFromBase:)]
        pub unsafe fn convertRectFromBase(&self, rect: NSRect) -> NSRect;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "This has always returned NO and had no effect on macOS"]
        #[method(performMnemonic:)]
        pub unsafe fn performMnemonic(&self, string: &NSString) -> bool;

        #[deprecated = "This method no longer does anything"]
        #[method(shouldDrawColor)]
        pub unsafe fn shouldDrawColor(&self) -> bool;

        #[deprecated]
        #[method(gState)]
        pub unsafe fn gState(&self) -> NSInteger;

        #[deprecated]
        #[method(allocateGState)]
        pub unsafe fn allocateGState(&self);

        #[deprecated]
        #[method(setUpGState)]
        pub unsafe fn setUpGState(&self);

        #[deprecated]
        #[method(renewGState)]
        pub unsafe fn renewGState(&self);
    }
);

extern_static!(NSViewFrameDidChangeNotification: &'static NSNotificationName);

extern_static!(NSViewFocusDidChangeNotification: &'static NSNotificationName);

extern_static!(NSViewBoundsDidChangeNotification: &'static NSNotificationName);

extern_static!(NSViewGlobalFrameDidChangeNotification: &'static NSNotificationName);

extern_static!(NSViewDidUpdateTrackingAreasNotification: &'static NSNotificationName);
