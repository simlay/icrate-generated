//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSTabState {
        NSSelectedTab = 0,
        NSBackgroundTab = 1,
        NSPressedTab = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSTabViewItem")]
    pub struct NSTabViewItem;

    #[cfg(feature = "AppKit_NSTabViewItem")]
    unsafe impl ClassType for NSTabViewItem {
        type Super = NSObject;
    }
);

#[cfg(feature = "AppKit_NSTabViewItem")]
unsafe impl NSCoding for NSTabViewItem {}

#[cfg(feature = "AppKit_NSTabViewItem")]
unsafe impl NSObjectProtocol for NSTabViewItem {}

extern_methods!(
    #[cfg(feature = "AppKit_NSTabViewItem")]
    unsafe impl NSTabViewItem {
        #[cfg(feature = "AppKit_NSViewController")]
        #[method_id(@__retain_semantics Other tabViewItemWithViewController:)]
        pub unsafe fn tabViewItemWithViewController(view_controller: &NSViewController)
            -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithIdentifier:)]
        pub unsafe fn initWithIdentifier(
            this: Option<Allocated<Self>>,
            identifier: Option<&Object>,
        ) -> Id<Self>;

        #[method_id(@__retain_semantics Other identifier)]
        pub unsafe fn identifier(&self) -> Option<Id<Object>>;

        #[method(setIdentifier:)]
        pub unsafe fn setIdentifier(&self, identifier: Option<&Object>);

        #[cfg(feature = "AppKit_NSColor")]
        #[method_id(@__retain_semantics Other color)]
        pub unsafe fn color(&self) -> Id<NSColor>;

        #[cfg(feature = "AppKit_NSColor")]
        #[method(setColor:)]
        pub unsafe fn setColor(&self, color: &NSColor);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other label)]
        pub unsafe fn label(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setLabel:)]
        pub unsafe fn setLabel(&self, label: &NSString);

        #[cfg(feature = "AppKit_NSImage")]
        /**
          Get and set the image for this tab view item. The image may only be used in certain tab view styles and options.  The default value is nil.
        */
        #[method_id(@__retain_semantics Other image)]
        pub unsafe fn image(&self) -> Option<Id<NSImage>>;

        #[cfg(feature = "AppKit_NSImage")]
        /**
          Get and set the image for this tab view item. The image may only be used in certain tab view styles and options.  The default value is nil.
        */
        #[method(setImage:)]
        pub unsafe fn setImage(&self, image: Option<&NSImage>);

        #[cfg(feature = "AppKit_NSView")]
        #[method_id(@__retain_semantics Other view)]
        pub unsafe fn view(&self) -> Option<Id<NSView>>;

        #[cfg(feature = "AppKit_NSView")]
        #[method(setView:)]
        pub unsafe fn setView(&self, view: Option<&NSView>);

        #[cfg(feature = "AppKit_NSViewController")]
        /**
          The view controller wrapped by the tab view item. This property must be set if the tab view item will be added to an NSTabViewController, but can also be used if the tab view item is added to an NSTabView.
         If this is set, the tab view item will forward \c -view calls onto the viewController. Setting a viewController will also set the following properties on the tab view item: \c -identifier from the address of the viewController, \c -label from the viewController's title, and \c -image based on the classname as the view controller.
         An image named "ViewControllerClassName-TabViewItem" will be searched for first, followed by "ViewControllerClassName". It will search first using +[NSImage imageNamed:], then in \c viewController.nibBundle, and lastly in the bundle containing the view controller's class.
         As defined by: -[NSImage imageNamed:imageName], -[viewController.nibBundle imageForResource:imageName], -[[NSBundle bundleForClass:[viewController class]] imageForResource:imageName]. One pass with imageName as [NSStringFromClass([viewController class]) stringByAppendingString:@"-TabViewItem"], followed by imageName as NSStringFromClass([viewController class]).
        */
        #[method_id(@__retain_semantics Other viewController)]
        pub unsafe fn viewController(&self) -> Option<Id<NSViewController>>;

        #[cfg(feature = "AppKit_NSViewController")]
        /**
          The view controller wrapped by the tab view item. This property must be set if the tab view item will be added to an NSTabViewController, but can also be used if the tab view item is added to an NSTabView.
         If this is set, the tab view item will forward \c -view calls onto the viewController. Setting a viewController will also set the following properties on the tab view item: \c -identifier from the address of the viewController, \c -label from the viewController's title, and \c -image based on the classname as the view controller.
         An image named "ViewControllerClassName-TabViewItem" will be searched for first, followed by "ViewControllerClassName". It will search first using +[NSImage imageNamed:], then in \c viewController.nibBundle, and lastly in the bundle containing the view controller's class.
         As defined by: -[NSImage imageNamed:imageName], -[viewController.nibBundle imageForResource:imageName], -[[NSBundle bundleForClass:[viewController class]] imageForResource:imageName]. One pass with imageName as [NSStringFromClass([viewController class]) stringByAppendingString:@"-TabViewItem"], followed by imageName as NSStringFromClass([viewController class]).
        */
        #[method(setViewController:)]
        pub unsafe fn setViewController(&self, view_controller: Option<&NSViewController>);

        #[method(tabState)]
        pub unsafe fn tabState(&self) -> NSTabState;

        #[cfg(feature = "AppKit_NSTabView")]
        #[method_id(@__retain_semantics Other tabView)]
        pub unsafe fn tabView(&self) -> Option<Id<NSTabView>>;

        #[cfg(feature = "AppKit_NSView")]
        #[method_id(@__retain_semantics Other initialFirstResponder)]
        pub unsafe fn initialFirstResponder(&self) -> Option<Id<NSView>>;

        #[cfg(feature = "AppKit_NSView")]
        #[method(setInitialFirstResponder:)]
        pub unsafe fn setInitialFirstResponder(&self, initial_first_responder: Option<&NSView>);

        #[cfg(feature = "Foundation_NSString")]
        /**
          The following methods provide support for tooltips on the tabs a tab view.  The default behavior is to use the label as a tooltip if the label is truncated due to insufficient space; this automatic tooltip is never returned by the toolTip method.  If you explicitly set a non-nil tooltip, this default behavior is suppressed, and the given tooltip will be used whether or not the label is truncated.
        */
        #[method_id(@__retain_semantics Other toolTip)]
        pub unsafe fn toolTip(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          The following methods provide support for tooltips on the tabs a tab view.  The default behavior is to use the label as a tooltip if the label is truncated due to insufficient space; this automatic tooltip is never returned by the toolTip method.  If you explicitly set a non-nil tooltip, this default behavior is suppressed, and the given tooltip will be used whether or not the label is truncated.
        */
        #[method(setToolTip:)]
        pub unsafe fn setToolTip(&self, tool_tip: Option<&NSString>);

        #[method(drawLabel:inRect:)]
        pub unsafe fn drawLabel_inRect(&self, should_truncate_label: bool, label_rect: NSRect);

        #[method(sizeOfLabel:)]
        pub unsafe fn sizeOfLabel(&self, compute_min: bool) -> NSSize;
    }
);
