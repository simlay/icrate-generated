//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSTextStorageEditActions {
        NSTextStorageEditedAttributes = 1 << 0,
        NSTextStorageEditedCharacters = 1 << 1,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSTextStorage")]
    /**
      Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

    - (NSString *)string;
    - (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

    - (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
    - (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

    These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
    */
    pub struct NSTextStorage;

    #[cfg(feature = "AppKit_NSTextStorage")]
    unsafe impl ClassType for NSTextStorage {
        #[inherits(NSAttributedString, NSObject)]
        type Super = NSMutableAttributedString;
    }
);

#[cfg(feature = "AppKit_NSTextStorage")]
/**
  Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

- (NSString *)string;
- (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
*/
unsafe impl NSCoding for NSTextStorage {}

#[cfg(feature = "AppKit_NSTextStorage")]
/**
  Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

- (NSString *)string;
- (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
*/
unsafe impl NSObjectProtocol for NSTextStorage {}

#[cfg(feature = "AppKit_NSTextStorage")]
/**
  Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

- (NSString *)string;
- (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
*/
unsafe impl NSSecureCoding for NSTextStorage {}

extern_methods!(
    /**
      Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

    - (NSString *)string;
    - (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

    - (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
    - (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

    These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
    */
    #[cfg(feature = "AppKit_NSTextStorage")]
    unsafe impl NSTextStorage {
        #[cfg(all(feature = "AppKit_NSLayoutManager", feature = "Foundation_NSArray"))]
        /**
          NSLayoutManager objects owned by the receiver.
        */
        #[method_id(@__retain_semantics Other layoutManagers)]
        pub unsafe fn layoutManagers(&self) -> Id<NSArray<NSLayoutManager>>;

        #[cfg(feature = "AppKit_NSLayoutManager")]
        #[method(addLayoutManager:)]
        pub unsafe fn addLayoutManager(&self, a_layout_manager: &NSLayoutManager);

        #[cfg(feature = "AppKit_NSLayoutManager")]
        #[method(removeLayoutManager:)]
        pub unsafe fn removeLayoutManager(&self, a_layout_manager: &NSLayoutManager);

        /**
          The NSTextStorageEditActions mask indicating that there are pending changes for attributes, characters, or both.
        */
        #[method(editedMask)]
        pub unsafe fn editedMask(&self) -> NSTextStorageEditActions;

        /**
          The range for pending changes. {NSNotFound, 0} when there is no pending changes.
        */
        #[method(editedRange)]
        pub unsafe fn editedRange(&self) -> NSRange;

        /**
          The length delta for the pending changes.
        */
        #[method(changeInLength)]
        pub unsafe fn changeInLength(&self) -> NSInteger;

        /**
          Delegate
        */
        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSTextStorageDelegate>>>;

        /**
          Delegate
        */
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSTextStorageDelegate>>,
        );

        #[method(edited:range:changeInLength:)]
        pub unsafe fn edited_range_changeInLength(
            &self,
            edited_mask: NSTextStorageEditActions,
            edited_range: NSRange,
            delta: NSInteger,
        );

        #[method(processEditing)]
        pub unsafe fn processEditing(&self);

        /**
          Indicates if the receiver fixes invalidated attributes lazily.  The concrete UIKit subclass fixes attributes lazily by default.  The abstract class (hence, all custom subclasses) is not lazy.
        */
        #[method(fixesAttributesLazily)]
        pub unsafe fn fixesAttributesLazily(&self) -> bool;

        #[method(invalidateAttributesInRange:)]
        pub unsafe fn invalidateAttributesInRange(&self, range: NSRange);

        #[method(ensureAttributesAreFixedInRange:)]
        pub unsafe fn ensureAttributesAreFixedInRange(&self, range: NSRange);

        /**
          NSTextStorageObserving
        An object conforming to NSTextStorageObserving observing and retaining NSTextStorage
        */
        #[method_id(@__retain_semantics Other textStorageObserver)]
        pub unsafe fn textStorageObserver(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSTextStorageObserving>>>;

        /**
          NSTextStorageObserving
        An object conforming to NSTextStorageObserving observing and retaining NSTextStorage
        */
        #[method(setTextStorageObserver:)]
        pub unsafe fn setTextStorageObserver(
            &self,
            text_storage_observer: Option<&ProtocolObject<dyn NSTextStorageObserving>>,
        );
    }
);

extern_protocol!(
    /**
       NSTextStorage delegate methods
    */
    pub unsafe trait NSTextStorageDelegate: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSTextStorage")]
        #[optional]
        #[method(textStorage:willProcessEditing:range:changeInLength:)]
        unsafe fn textStorage_willProcessEditing_range_changeInLength(
            &self,
            text_storage: &NSTextStorage,
            edited_mask: NSTextStorageEditActions,
            edited_range: NSRange,
            delta: NSInteger,
        );

        #[cfg(feature = "AppKit_NSTextStorage")]
        #[optional]
        #[method(textStorage:didProcessEditing:range:changeInLength:)]
        unsafe fn textStorage_didProcessEditing_range_changeInLength(
            &self,
            text_storage: &NSTextStorage,
            edited_mask: NSTextStorageEditActions,
            edited_range: NSRange,
            delta: NSInteger,
        );
    }

    unsafe impl ProtocolType for dyn NSTextStorageDelegate {}
);

extern_static!(NSTextStorageWillProcessEditingNotification: &'static NSNotificationName);

extern_static!(NSTextStorageDidProcessEditingNotification: &'static NSNotificationName);

extern_protocol!(
    /**
      NSTextStorageObserving defines the protocol for NSTextStorage controller objects observing changes in the text backing-store.
    */
    pub unsafe trait NSTextStorageObserving: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSTextStorage")]
        /**
          The document object
        */
        #[method_id(@__retain_semantics Other textStorage)]
        unsafe fn textStorage(&self) -> Option<Id<NSTextStorage>>;

        #[cfg(feature = "AppKit_NSTextStorage")]
        /**
          The document object
        */
        #[method(setTextStorage:)]
        unsafe fn setTextStorage(&self, text_storage: Option<&NSTextStorage>);

        #[cfg(feature = "AppKit_NSTextStorage")]
        #[method(processEditingForTextStorage:edited:range:changeInLength:invalidatedRange:)]
        unsafe fn processEditingForTextStorage_edited_range_changeInLength_invalidatedRange(
            &self,
            text_storage: &NSTextStorage,
            edit_mask: NSTextStorageEditActions,
            new_char_range: NSRange,
            delta: NSInteger,
            invalidated_char_range: NSRange,
        );

        #[cfg(feature = "AppKit_NSTextStorage")]
        #[method(performEditingTransactionForTextStorage:usingBlock:)]
        unsafe fn performEditingTransactionForTextStorage_usingBlock(
            &self,
            text_storage: &NSTextStorage,
            transaction: &Block<(), ()>,
        );
    }

    unsafe impl ProtocolType for dyn NSTextStorageObserving {}
);

pub type NSTextStorageEditedOptions = NSUInteger;

extern_methods!(
    /// Methods declared on superclass `NSAttributedString`
    ///
    /**
      Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

    - (NSString *)string;
    - (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

    - (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
    - (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

    These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
    */
    /// NSAttributedStringDocumentFormats
    #[cfg(feature = "AppKit_NSTextStorage")]
    unsafe impl NSTextStorage {
        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Init initWithURL:options:documentAttributes:error:_)]
        pub unsafe fn initWithURL_options_documentAttributes_error(
            this: Option<Allocated<Self>>,
            url: &NSURL,
            options: &NSDictionary<NSAttributedStringDocumentReadingOptionKey, Object>,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Init initWithData:options:documentAttributes:error:_)]
        pub unsafe fn initWithData_options_documentAttributes_error(
            this: Option<Allocated<Self>>,
            data: &NSData,
            options: &NSDictionary<NSAttributedStringDocumentReadingOptionKey, Object>,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Init initWithRTF:documentAttributes:)]
        pub unsafe fn initWithRTF_documentAttributes(
            this: Option<Allocated<Self>>,
            data: &NSData,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Init initWithRTFD:documentAttributes:)]
        pub unsafe fn initWithRTFD_documentAttributes(
            this: Option<Allocated<Self>>,
            data: &NSData,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Init initWithHTML:documentAttributes:)]
        pub unsafe fn initWithHTML_documentAttributes(
            this: Option<Allocated<Self>>,
            data: &NSData,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Init initWithHTML:baseURL:documentAttributes:)]
        pub unsafe fn initWithHTML_baseURL_documentAttributes(
            this: Option<Allocated<Self>>,
            data: &NSData,
            base: &NSURL,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Init initWithDocFormat:documentAttributes:)]
        pub unsafe fn initWithDocFormat_documentAttributes(
            this: Option<Allocated<Self>>,
            data: &NSData,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Init initWithHTML:options:documentAttributes:)]
        pub unsafe fn initWithHTML_options_documentAttributes(
            this: Option<Allocated<Self>>,
            data: &NSData,
            options: &NSDictionary<NSAttributedStringDocumentReadingOptionKey, Object>,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSFileWrapper"
        ))]
        #[method_id(@__retain_semantics Init initWithRTFDFileWrapper:documentAttributes:)]
        pub unsafe fn initWithRTFDFileWrapper_documentAttributes(
            this: Option<Allocated<Self>>,
            wrapper: &NSFileWrapper,
            dict: Option<
                &mut Option<Id<NSDictionary<NSAttributedStringDocumentAttributeKey, Object>>>,
            >,
        ) -> Option<Id<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSAttributedString`
    ///
    /**
      Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

    - (NSString *)string;
    - (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

    - (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
    - (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

    These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
    */
    /// NSDeprecatedKitAdditions
    #[cfg(feature = "AppKit_NSTextStorage")]
    unsafe impl NSTextStorage {
        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSURL"))]
        #[deprecated = "Use -initWithURL:options:documentAttributes:error: instead"]
        #[method_id(@__retain_semantics Init initWithURL:documentAttributes:)]
        pub unsafe fn initWithURL_documentAttributes(
            this: Option<Allocated<Self>>,
            url: &NSURL,
            dict: Option<&mut Option<Id<NSDictionary>>>,
        ) -> Option<Id<Self>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[deprecated = "Use -initWithURL:options:documentAttributes:error: instead"]
        #[method_id(@__retain_semantics Init initWithPath:documentAttributes:)]
        pub unsafe fn initWithPath_documentAttributes(
            this: Option<Allocated<Self>>,
            path: &NSString,
            dict: Option<&mut Option<Id<NSDictionary>>>,
        ) -> Option<Id<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSAttributedString`
    ///
    /**
      Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

    - (NSString *)string;
    - (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

    - (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
    - (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

    These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
    */
    /// NSExtendedAttributedString
    #[cfg(feature = "AppKit_NSTextStorage")]
    unsafe impl NSTextStorage {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithString:)]
        pub unsafe fn initWithString(this: Option<Allocated<Self>>, str: &NSString) -> Id<Self>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Init initWithString:attributes:)]
        pub unsafe fn initWithString_attributes(
            this: Option<Allocated<Self>>,
            str: &NSString,
            attrs: Option<&NSDictionary<NSAttributedStringKey, Object>>,
        ) -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithAttributedString:)]
        pub unsafe fn initWithAttributedString(
            this: Option<Allocated<Self>>,
            attr_str: &NSAttributedString,
        ) -> Id<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSAttributedString`
    ///
    /**
      Note for subclassing NSTextStorage: NSTextStorage is a semi-abstract subclass of NSMutableAttributedString. It implements change management (beginEditing/endEditing), verification of attributes, delegate handling, and layout management notification. The one aspect it does not implement is the actual attributed string storage --- this is left up to the subclassers, which need to override the two NSMutableAttributedString primitives in addition to two NSAttributedString primitives:

    - (NSString *)string;
    - (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range;

    - (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;
    - (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;

    These primitives should perform the change then call edited:range:changeInLength: to get everything else to happen.
    */
    /// NSAttributedStringCreateFromMarkdown
    #[cfg(feature = "AppKit_NSTextStorage")]
    unsafe impl NSTextStorage {
        #[cfg(all(
            feature = "Foundation_NSAttributedStringMarkdownParsingOptions",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Init initWithContentsOfMarkdownFileAtURL:options:baseURL:error:_)]
        pub unsafe fn initWithContentsOfMarkdownFileAtURL_options_baseURL_error(
            this: Option<Allocated<Self>>,
            markdown_file: &NSURL,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSAttributedStringMarkdownParsingOptions",
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Init initWithMarkdown:options:baseURL:error:_)]
        pub unsafe fn initWithMarkdown_options_baseURL_error(
            this: Option<Allocated<Self>>,
            markdown: &NSData,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSAttributedStringMarkdownParsingOptions",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Init initWithMarkdownString:options:baseURL:error:_)]
        pub unsafe fn initWithMarkdownString_options_baseURL_error(
            this: Option<Allocated<Self>>,
            markdown_string: &NSString,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Id<Self>, Id<NSError>>;
    }
);
