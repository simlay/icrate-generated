//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSAnimationCurve {
        NSAnimationEaseInOut = 0,
        NSAnimationEaseIn = 1,
        NSAnimationEaseOut = 2,
        NSAnimationLinear = 3,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSAnimationBlockingMode {
        NSAnimationBlocking = 0,
        NSAnimationNonblocking = 1,
        NSAnimationNonblockingThreaded = 2,
    }
);

pub type NSAnimationProgress = c_float;

extern_static!(NSAnimationProgressMarkNotification: &'static NSNotificationName);

extern_static!(NSAnimationProgressMark: &'static NSString);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSAnimation")]
    pub struct NSAnimation;

    #[cfg(feature = "AppKit_NSAnimation")]
    unsafe impl ClassType for NSAnimation {
        type Super = NSObject;
    }
);

#[cfg(feature = "AppKit_NSAnimation")]
unsafe impl NSCoding for NSAnimation {}

#[cfg(feature = "AppKit_NSAnimation")]
unsafe impl NSObjectProtocol for NSAnimation {}

extern_methods!(
    #[cfg(feature = "AppKit_NSAnimation")]
    unsafe impl NSAnimation {
        #[method_id(@__retain_semantics Init initWithDuration:animationCurve:)]
        pub unsafe fn initWithDuration_animationCurve(
            this: Option<Allocated<Self>>,
            duration: NSTimeInterval,
            animation_curve: NSAnimationCurve,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Option<Allocated<Self>>,
            coder: &NSCoder,
        ) -> Option<Id<Self>>;

        #[method(startAnimation)]
        pub unsafe fn startAnimation(&self);

        #[method(stopAnimation)]
        pub unsafe fn stopAnimation(&self);

        #[method(isAnimating)]
        pub unsafe fn isAnimating(&self) -> bool;

        #[method(currentProgress)]
        pub unsafe fn currentProgress(&self) -> NSAnimationProgress;

        #[method(setCurrentProgress:)]
        pub unsafe fn setCurrentProgress(&self, current_progress: NSAnimationProgress);

        #[method(duration)]
        pub unsafe fn duration(&self) -> NSTimeInterval;

        #[method(setDuration:)]
        pub unsafe fn setDuration(&self, duration: NSTimeInterval);

        #[method(animationBlockingMode)]
        pub unsafe fn animationBlockingMode(&self) -> NSAnimationBlockingMode;

        #[method(setAnimationBlockingMode:)]
        pub unsafe fn setAnimationBlockingMode(
            &self,
            animation_blocking_mode: NSAnimationBlockingMode,
        );

        #[method(frameRate)]
        pub unsafe fn frameRate(&self) -> c_float;

        #[method(setFrameRate:)]
        pub unsafe fn setFrameRate(&self, frame_rate: c_float);

        #[method(animationCurve)]
        pub unsafe fn animationCurve(&self) -> NSAnimationCurve;

        #[method(setAnimationCurve:)]
        pub unsafe fn setAnimationCurve(&self, animation_curve: NSAnimationCurve);

        #[method(currentValue)]
        pub unsafe fn currentValue(&self) -> c_float;

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSAnimationDelegate>>>;

        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSAnimationDelegate>>,
        );

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSNumber"))]
        #[method_id(@__retain_semantics Other progressMarks)]
        pub unsafe fn progressMarks(&self) -> Id<NSArray<NSNumber>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSNumber"))]
        #[method(setProgressMarks:)]
        pub unsafe fn setProgressMarks(&self, progress_marks: &NSArray<NSNumber>);

        #[method(addProgressMark:)]
        pub unsafe fn addProgressMark(&self, progress_mark: NSAnimationProgress);

        #[method(removeProgressMark:)]
        pub unsafe fn removeProgressMark(&self, progress_mark: NSAnimationProgress);

        #[method(startWhenAnimation:reachesProgress:)]
        pub unsafe fn startWhenAnimation_reachesProgress(
            &self,
            animation: &NSAnimation,
            start_progress: NSAnimationProgress,
        );

        #[method(stopWhenAnimation:reachesProgress:)]
        pub unsafe fn stopWhenAnimation_reachesProgress(
            &self,
            animation: &NSAnimation,
            stop_progress: NSAnimationProgress,
        );

        #[method(clearStartAnimation)]
        pub unsafe fn clearStartAnimation(&self);

        #[method(clearStopAnimation)]
        pub unsafe fn clearStopAnimation(&self);

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other runLoopModesForAnimating)]
        pub unsafe fn runLoopModesForAnimating(&self) -> Option<Id<NSArray<NSRunLoopMode>>>;
    }
);

extern_protocol!(
    pub unsafe trait NSAnimationDelegate: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSAnimation")]
        #[optional]
        #[method(animationShouldStart:)]
        unsafe fn animationShouldStart(&self, animation: &NSAnimation) -> bool;

        #[cfg(feature = "AppKit_NSAnimation")]
        #[optional]
        #[method(animationDidStop:)]
        unsafe fn animationDidStop(&self, animation: &NSAnimation);

        #[cfg(feature = "AppKit_NSAnimation")]
        #[optional]
        #[method(animationDidEnd:)]
        unsafe fn animationDidEnd(&self, animation: &NSAnimation);

        #[cfg(feature = "AppKit_NSAnimation")]
        #[optional]
        #[method(animation:valueForProgress:)]
        unsafe fn animation_valueForProgress(
            &self,
            animation: &NSAnimation,
            progress: NSAnimationProgress,
        ) -> c_float;

        #[cfg(feature = "AppKit_NSAnimation")]
        #[optional]
        #[method(animation:didReachProgressMark:)]
        unsafe fn animation_didReachProgressMark(
            &self,
            animation: &NSAnimation,
            progress: NSAnimationProgress,
        );
    }

    unsafe impl ProtocolType for dyn NSAnimationDelegate {}
);

typed_enum!(
    pub type NSViewAnimationKey = NSString;
);

extern_static!(NSViewAnimationTargetKey: &'static NSViewAnimationKey);

extern_static!(NSViewAnimationStartFrameKey: &'static NSViewAnimationKey);

extern_static!(NSViewAnimationEndFrameKey: &'static NSViewAnimationKey);

extern_static!(NSViewAnimationEffectKey: &'static NSViewAnimationKey);

typed_enum!(
    pub type NSViewAnimationEffectName = NSString;
);

extern_static!(NSViewAnimationFadeInEffect: &'static NSViewAnimationEffectName);

extern_static!(NSViewAnimationFadeOutEffect: &'static NSViewAnimationEffectName);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSViewAnimation")]
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    pub struct NSViewAnimation;

    #[cfg(feature = "AppKit_NSViewAnimation")]
    unsafe impl ClassType for NSViewAnimation {
        #[inherits(NSObject)]
        type Super = NSAnimation;
    }
);

#[cfg(feature = "AppKit_NSViewAnimation")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSCoding for NSViewAnimation {}

#[cfg(feature = "AppKit_NSViewAnimation")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSObjectProtocol for NSViewAnimation {}

extern_methods!(
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    #[cfg(feature = "AppKit_NSViewAnimation")]
    unsafe impl NSViewAnimation {
        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Init initWithViewAnimations:)]
        pub unsafe fn initWithViewAnimations(
            this: Option<Allocated<Self>>,
            view_animations: &NSArray<NSDictionary<NSViewAnimationKey, Object>>,
        ) -> Id<Self>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Other viewAnimations)]
        pub unsafe fn viewAnimations(
            &self,
        ) -> Id<NSArray<NSDictionary<NSViewAnimationKey, Object>>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSDictionary"))]
        #[method(setViewAnimations:)]
        pub unsafe fn setViewAnimations(
            &self,
            view_animations: &NSArray<NSDictionary<NSViewAnimationKey, Object>>,
        );
    }
);

pub type NSAnimatablePropertyKey = NSString;

extern_protocol!(
    pub unsafe trait NSAnimatablePropertyContainer {
        #[method_id(@__retain_semantics Other animator)]
        unsafe fn animator(&self) -> Id<Self>;

        #[cfg(feature = "Foundation_NSDictionary")]
        /**
          An animatable property container's optional "animations" dictionary maps NSString keys to CAAnimation values. When an occurrence matching the key fires for the view, -animationForKey: first looks in this dictionary for an animation to execute in response. Typically, the key will name a property of the object whose value has just changed, but it may instead specify a special event trigger (NSAnimationTriggerOrderIn or NSAnimationTriggerOrderOut).
        */
        #[method_id(@__retain_semantics Other animations)]
        unsafe fn animations(&self) -> Id<NSDictionary<NSAnimatablePropertyKey, Object>>;

        #[cfg(feature = "Foundation_NSDictionary")]
        /**
          An animatable property container's optional "animations" dictionary maps NSString keys to CAAnimation values. When an occurrence matching the key fires for the view, -animationForKey: first looks in this dictionary for an animation to execute in response. Typically, the key will name a property of the object whose value has just changed, but it may instead specify a special event trigger (NSAnimationTriggerOrderIn or NSAnimationTriggerOrderOut).
        */
        #[method(setAnimations:)]
        unsafe fn setAnimations(&self, animations: &NSDictionary<NSAnimatablePropertyKey, Object>);

        #[method_id(@__retain_semantics Other animationForKey:)]
        unsafe fn animationForKey(&self, key: &NSAnimatablePropertyKey) -> Option<Id<Object>>;

        #[method_id(@__retain_semantics Other defaultAnimationForKey:)]
        unsafe fn defaultAnimationForKey(key: &NSAnimatablePropertyKey) -> Option<Id<Object>>;
    }

    unsafe impl ProtocolType for dyn NSAnimatablePropertyContainer {}
);

extern_static!(NSAnimationTriggerOrderIn: &'static NSAnimatablePropertyKey);

extern_static!(NSAnimationTriggerOrderOut: &'static NSAnimatablePropertyKey);

extern_methods!(
    /// Methods declared on superclass `NSAnimation`
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    #[cfg(feature = "AppKit_NSViewAnimation")]
    unsafe impl NSViewAnimation {
        #[method_id(@__retain_semantics Init initWithDuration:animationCurve:)]
        pub unsafe fn initWithDuration_animationCurve(
            this: Option<Allocated<Self>>,
            duration: NSTimeInterval,
            animation_curve: NSAnimationCurve,
        ) -> Id<Self>;
    }
);
