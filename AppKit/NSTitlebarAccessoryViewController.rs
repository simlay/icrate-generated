//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
    /**
      For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
    */
    pub struct NSTitlebarAccessoryViewController;

    #[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
    unsafe impl ClassType for NSTitlebarAccessoryViewController {
        #[inherits(NSResponder, NSObject)]
        type Super = NSViewController;
    }
);

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSAnimatablePropertyContainer for NSTitlebarAccessoryViewController {}

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSAnimationDelegate for NSTitlebarAccessoryViewController {}

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSCoding for NSTitlebarAccessoryViewController {}

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSEditor for NSTitlebarAccessoryViewController {}

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSObjectProtocol for NSTitlebarAccessoryViewController {}

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSSeguePerforming for NSTitlebarAccessoryViewController {}

#[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
/**
  For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
*/
unsafe impl NSUserInterfaceItemIdentification for NSTitlebarAccessoryViewController {}

extern_methods!(
    /**
      For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
    */
    #[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
    unsafe impl NSTitlebarAccessoryViewController {
        /**
          The layoutAttribute defaults to NSLayoutAttributeBottom, telling the window to place this view controller's view under the titlebar. NSLayoutAttributeRight is also supported, telling the window to place the view controller's view on the right side of the window. For applications linked on Mac OS 10.11 or later, NSLayoutAttributeLeft is also supported; placing the item on the left side of the window (adjacent and to the right of the close/minimize/maximize buttons). All other values are currently invalid and will assert.

        A layoutAttribute == NSLayoutAttributeRight will indent toolbar items for all toolbar styles except NSToolbarStyleExpanded and NSToolbarStyleCompact.

        For applications linked on 10.12 and higher, NSLayoutAttributeLeading and NSLayoutAttributeTrailing can also be used to specify an abstract position that automatically flips depending on the localized language.  For applications that do not link on 10.12, NSLayoutAttributeLeft will automatically flip to the Right when in a Right To Left language.

        For applications linked on 10.13 and higher, NSLayoutAttributeTop can also be used to specify a view that will be at the top of the titlebar area. Only one should be used per window, and if one is set the normal titlebar will not be drawn. Using the top attributed requires the window to have the NSWindowStyleMaskFullSizeContentView style mask set. The "hidden" property can be used to show and hide the view. The "hidden" property will animate the view via an alpha fade in and out if accessed through the animator proxy (such as: viewController.animator.hidden = YES).

        */
        #[method(layoutAttribute)]
        pub unsafe fn layoutAttribute(&self) -> NSLayoutAttribute;

        /**
          The layoutAttribute defaults to NSLayoutAttributeBottom, telling the window to place this view controller's view under the titlebar. NSLayoutAttributeRight is also supported, telling the window to place the view controller's view on the right side of the window. For applications linked on Mac OS 10.11 or later, NSLayoutAttributeLeft is also supported; placing the item on the left side of the window (adjacent and to the right of the close/minimize/maximize buttons). All other values are currently invalid and will assert.

        A layoutAttribute == NSLayoutAttributeRight will indent toolbar items for all toolbar styles except NSToolbarStyleExpanded and NSToolbarStyleCompact.

        For applications linked on 10.12 and higher, NSLayoutAttributeLeading and NSLayoutAttributeTrailing can also be used to specify an abstract position that automatically flips depending on the localized language.  For applications that do not link on 10.12, NSLayoutAttributeLeft will automatically flip to the Right when in a Right To Left language.

        For applications linked on 10.13 and higher, NSLayoutAttributeTop can also be used to specify a view that will be at the top of the titlebar area. Only one should be used per window, and if one is set the normal titlebar will not be drawn. Using the top attributed requires the window to have the NSWindowStyleMaskFullSizeContentView style mask set. The "hidden" property can be used to show and hide the view. The "hidden" property will animate the view via an alpha fade in and out if accessed through the animator proxy (such as: viewController.animator.hidden = YES).

        */
        #[method(setLayoutAttribute:)]
        pub unsafe fn setLayoutAttribute(&self, layout_attribute: NSLayoutAttribute);

        /**
          The fullScreenMinHeight controls the visual minimum height of the view when it is in full screen. It only applies to controllers with the layoutAttribute set to NSLayoutAttributeBottom. Note that the view's height is never actually changed, and it is automatically clipped by an internal clip view.

        The minimum height is used when the menu bar is hidden. A minimum height of 0 will fully hide the view when the menu bar is hidden.

        To always show a portion of the view, set the fullScreenMinHeight to some value greater than 0. To always have the view fully shown (i.e.: a fixed height accessory view), set the fullScreenMinHeight to the view.frame.size.height (and be sure to update it if you ever change the view's height).

        The default value is 0.
        */
        #[method(fullScreenMinHeight)]
        pub unsafe fn fullScreenMinHeight(&self) -> CGFloat;

        /**
          The fullScreenMinHeight controls the visual minimum height of the view when it is in full screen. It only applies to controllers with the layoutAttribute set to NSLayoutAttributeBottom. Note that the view's height is never actually changed, and it is automatically clipped by an internal clip view.

        The minimum height is used when the menu bar is hidden. A minimum height of 0 will fully hide the view when the menu bar is hidden.

        To always show a portion of the view, set the fullScreenMinHeight to some value greater than 0. To always have the view fully shown (i.e.: a fixed height accessory view), set the fullScreenMinHeight to the view.frame.size.height (and be sure to update it if you ever change the view's height).

        The default value is 0.
        */
        #[method(setFullScreenMinHeight:)]
        pub unsafe fn setFullScreenMinHeight(&self, full_screen_min_height: CGFloat);

        /**
          Indicates whether the accessory view is actually visible in the window. This property only applies to controllers set with the top or bottom layoutAtribute. When set, this property will collapse the accessory view to 0 height (animatable) but NOT remove it from the window. That way, you can easily show and hide it without difficulty. Set through the animator object to animate it.
        */
        #[method(isHidden)]
        pub unsafe fn isHidden(&self) -> bool;

        /**
          Indicates whether the accessory view is actually visible in the window. This property only applies to controllers set with the top or bottom layoutAtribute. When set, this property will collapse the accessory view to 0 height (animatable) but NOT remove it from the window. That way, you can easily show and hide it without difficulty. Set through the animator object to animate it.
        */
        #[method(setHidden:)]
        pub unsafe fn setHidden(&self, hidden: bool);

        /**
          Whether the accessory should automatically size to the standard system default sizing over the view's current frame size.

        Only valid for accessories with a layoutAttribute of NSLayoutAttributeBottom.

        The default value is YES.
        */
        #[method(automaticallyAdjustsSize)]
        pub unsafe fn automaticallyAdjustsSize(&self) -> bool;

        /**
          Whether the accessory should automatically size to the standard system default sizing over the view's current frame size.

        Only valid for accessories with a layoutAttribute of NSLayoutAttributeBottom.

        The default value is YES.
        */
        #[method(setAutomaticallyAdjustsSize:)]
        pub unsafe fn setAutomaticallyAdjustsSize(&self, automatically_adjusts_size: bool);

        #[method(viewWillAppear)]
        pub unsafe fn viewWillAppear(&self);

        #[method(viewDidAppear)]
        pub unsafe fn viewDidAppear(&self);

        #[method(viewDidDisappear)]
        pub unsafe fn viewDidDisappear(&self);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSViewController`
    /**
      For use with NSWindow's API addTitlebarAccessoryViewController:, etc.
    */
    #[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
    unsafe impl NSTitlebarAccessoryViewController {
        #[cfg(feature = "Foundation_NSBundle")]
        #[method_id(@__retain_semantics Init initWithNibName:bundle:)]
        pub unsafe fn initWithNibName_bundle(
            this: Option<Allocated<Self>>,
            nib_name_or_nil: Option<&NSNibName>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Id<Self>;
    }
);
