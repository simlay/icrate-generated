//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

extern_static!(NSAppKitVersionNumberWithCustomSheetPosition: NSAppKitVersion = 686.0);

extern_static!(NSAppKitVersionNumberWithDeferredWindowDisplaySupport: NSAppKitVersion = 1019.0);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      @typedef NSWindowStyleMask

     @const NSWindowStyleMaskBorderless
     @const NSWindowStyleMaskTitled
     @const NSWindowStyleMaskClosable
     @const NSWindowStyleMaskMiniaturizable
     @const NSWindowStyleMaskResizable
     @const NSWindowStyleMaskTexturedBackground  Textured window style is deprecated and should no longer be used. Specifies a window with textured background. Textured windows generally don't draw a top border line under the titlebar/toolbar. To get that line, use the \c NSUnifiedTitleAndToolbarWindowMask mask.
     @const NSWindowStyleMaskUnifiedTitleAndToolbar  Specifies a window whose titlebar and toolbar have a unified look - that is, a continuous background. Under the titlebar and toolbar a horizontal separator line will appear.
     @const NSWindowStyleMaskFullScreen  When present, the window will appear full screen. This mask is automatically toggled when \c -toggleFullScreen: is called.
     @const NSWindowStyleMaskFullSizeContentView If set, the \c contentView will consume the full size of the window; it can be combined with other window style masks, but is only respected for windows with a titlebar. Utilizing this mask opts-in to layer-backing. Utilize the \c contentLayoutRect or auto-layout \c contentLayoutGuide to layout views underneath the titlebar/toolbar area.
     @const NSWindowStyleMaskUtilityWindow Only applicable for \c NSPanel (or a subclass thereof).
     @const NSWindowStyleMaskDocModalWindow Only applicable for \c NSPanel (or a subclass thereof).
     @const NSWindowStyleMaskNonactivatingPanel  Specifies that a panel that does not activate the owning application. Only applicable for \c NSPanel (or a subclass thereof).
     @const NSWindowStyleMaskHUDWindow Specifies a heads up display panel.  Only applicable for \c NSPanel (or a subclass thereof).
    */
    pub enum NSWindowStyleMask {
        NSWindowStyleMaskBorderless = 0,
        NSWindowStyleMaskTitled = 1 << 0,
        NSWindowStyleMaskClosable = 1 << 1,
        NSWindowStyleMaskMiniaturizable = 1 << 2,
        NSWindowStyleMaskResizable = 1 << 3,
        #[deprecated = "Textured window style should no longer be used"]
        NSWindowStyleMaskTexturedBackground = 1 << 8,
        NSWindowStyleMaskUnifiedTitleAndToolbar = 1 << 12,
        NSWindowStyleMaskFullScreen = 1 << 14,
        NSWindowStyleMaskFullSizeContentView = 1 << 15,
        NSWindowStyleMaskUtilityWindow = 1 << 4,
        NSWindowStyleMaskDocModalWindow = 1 << 6,
        NSWindowStyleMaskNonactivatingPanel = 1 << 7,
        NSWindowStyleMaskHUDWindow = 1 << 13,
    }
);

extern_static!(NSModalResponseOK: NSModalResponse = 1);

extern_static!(NSModalResponseCancel: NSModalResponse = 0);

extern_enum!(
    #[underlying(c_uint)]
    /**
      Used with \c NSRunLoop's `-performSelector:target:argument:order:modes:`.
    */
    pub enum __anonymous__ {
        NSDisplayWindowRunLoopOrdering = 600000,
        NSResetCursorRectsRunLoopOrdering = 700000,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
      @typedef NSWindowSharingType

     @const NSWindowSharingNone          Window contents may not be read by another process.
     @const NSWindowSharingReadOnly   Window contents may be read but not modified by another process.
     @const NSWindowSharingReadWrite  Window contents may be read or modified by another process.
    */
    pub enum NSWindowSharingType {
        NSWindowSharingNone = 0,
        NSWindowSharingReadOnly = 1,
        NSWindowSharingReadWrite = 2,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      @typedef NSWindowCollectionBehavior

     @const NSWindowCollectionBehaviorPrimary Marks a window as primary. This collection behavior should commonly be used for document or viewer windows.
     @const NSWindowCollectionBehaviorAuxiliary Marks a window as auxiliary. This collection behavior should commonly be used for About or Settings windows, as well as utility panes.
     @const NSWindowCollectionBehaviorCanJoinAllApplications Marks a window as able to join all applications, allowing it to join other apps' sets and full screen spaces when eligible. This collection behavior should commonly be used for floating windows and system overlays.

     @discussion You may specify at most one of @c NSWindowCollectionBehaviorPrimary, @c NSWindowCollectionBehaviorAuxiliary, or @c NSWindowCollectionBehaviorCanJoinAllApplications. If unspecified, the window gets the default treatment determined by its other collection behaviors.

     @const NSWindowCollectionBehaviorDefault
     @const NSWindowCollectionBehaviorCanJoinAllSpaces
     @const NSWindowCollectionBehaviorMoveToActiveSpace

     @discussion You may specify at most one of \c NSWindowCollectionBehaviorManaged, \c NSWindowCollectionBehaviorTransient, or \c NSWindowCollectionBehaviorStationary.  If neither is specified, the window gets the default behavior determined by its window level.

     @const NSWindowCollectionBehaviorManaged Participates in spaces, exposé.  Default behavior if `windowLevel == NSNormalWindowLevel`.
     @const NSWindowCollectionBehaviorTransient Floats in spaces, hidden by exposé.  Default behavior if `windowLevel != NSNormalWindowLevel`.
     @const NSWindowCollectionBehaviorStationary Unaffected by exposé.  Stays visible and stationary, like desktop window.

     @discussion You may specify at most one of \c NSWindowCollectionBehaviorParticipatesInCycle or \c NSWindowCollectionBehaviorIgnoresCycle.  If unspecified, the window gets the default behavior determined by its window level.

     @const NSWindowCollectionBehaviorParticipatesInCycle Default behavior if `windowLevel != NSNormalWindowLevel`.
     @const NSWindowCollectionBehaviorIgnoresCycle Default behavior if `windowLevel != NSNormalWindowLevel`.

     @discussion You may specify at most one of \c NSWindowCollectionBehaviorFullScreenPrimary, \c NSWindowCollectionBehaviorFullScreenAuxiliary, or \c NSWindowCollectionBehaviorFullScreenNone.

     @const NSWindowCollectionBehaviorFullScreenPrimary The frontmost window with this collection behavior will be the fullscreen window.
     @const NSWindowCollectionBehaviorFullScreenAuxiliary Windows with this collection behavior can be shown with the fullscreen window.
     @const NSWindowCollectionBehaviorFullScreenNone The window can not be made fullscreen when this bit is set.

     @discussion You may specify at most one of \c NSWindowCollectionBehaviorFullScreenAllowsTiling or \c NSWindowCollectionBehaviorFullScreenDisallowsTiling, or an assertion will be raised.

     The default behavior is to allow any window to participate in full screen tiling, as long as it meets certain requirements, such as being resizable and not a panel or sheet. Windows which are not full screen capable can still become a secondary tile in full screen. A window can explicitly allow itself to be placed into a full screen tile by including \c NSWindowCollectionBehaviorFullScreenAllowsTiling. Even if a window allows itself to be placed in a tile, it still may not be put in the tile if its \c minFullScreenContentSize is too large to fit. A window can explicitly disallow itself from being placed in a full screen tile by including \c NSWindowCollectionBehaviorFullScreenDisallowsTiling. This is useful for non-full screen capable windows to explicitly prevent themselves from being tiled. It can also be used by a full screen window to prevent any other windows from being placed in its full screen tile.

     @const NSWindowCollectionBehaviorFullScreenAllowsTiling This window can be a full screen tile window. It does not have to have \c NSWindowCollectionBehaviorFullScreenPrimary set.
     @const NSWindowCollectionBehaviorFullScreenDisallowsTiling This window can NOT be made a full screen tile window; it still may be allowed to be a regular \c NSWindowCollectionBehaviorFullScreenPrimary window.
    */
    pub enum NSWindowCollectionBehavior {
        NSWindowCollectionBehaviorDefault = 0,
        NSWindowCollectionBehaviorCanJoinAllSpaces = 1 << 0,
        NSWindowCollectionBehaviorMoveToActiveSpace = 1 << 1,
        NSWindowCollectionBehaviorManaged = 1 << 2,
        NSWindowCollectionBehaviorTransient = 1 << 3,
        NSWindowCollectionBehaviorStationary = 1 << 4,
        NSWindowCollectionBehaviorParticipatesInCycle = 1 << 5,
        NSWindowCollectionBehaviorIgnoresCycle = 1 << 6,
        NSWindowCollectionBehaviorFullScreenPrimary = 1 << 7,
        NSWindowCollectionBehaviorFullScreenAuxiliary = 1 << 8,
        NSWindowCollectionBehaviorFullScreenNone = 1 << 9,
        NSWindowCollectionBehaviorFullScreenAllowsTiling = 1 << 11,
        NSWindowCollectionBehaviorFullScreenDisallowsTiling = 1 << 12,
        NSWindowCollectionBehaviorPrimary = 1 << 16,
        NSWindowCollectionBehaviorAuxiliary = 1 << 17,
        NSWindowCollectionBehaviorCanJoinAllApplications = 1 << 18,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    /**
      @typedef NSWindowAnimationBehavior

     @const NSWindowAnimationBehaviorDefault  Let AppKit infer animation behavior for this window.
     @const NSWindowAnimationBehaviorNone     Suppress inferred animations (don't animate).
     @const NSWindowAnimationBehaviorDocumentWindow
     @const NSWindowAnimationBehaviorUtilityWindow
     @const NSWindowAnimationBehaviorAlertPanel
    */
    pub enum NSWindowAnimationBehavior {
        NSWindowAnimationBehaviorDefault = 0,
        NSWindowAnimationBehaviorNone = 2,
        NSWindowAnimationBehaviorDocumentWindow = 3,
        NSWindowAnimationBehaviorUtilityWindow = 4,
        NSWindowAnimationBehaviorAlertPanel = 5,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      @typedef NSWindowNumberListOptions

     Options used in `+windowNumbersWithOptions:`.  If no options are specified, the returned list contains window numbers for visible windows on the active space belonging to the calling application.

     @const NSWindowNumberListAllApplications
     @const NSWindowNumberListAllSpaces
    */
    pub enum NSWindowNumberListOptions {
        NSWindowNumberListAllApplications = 1 << 0,
        NSWindowNumberListAllSpaces = 1 << 4,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      @typedef NSWindowOcclusionState

     @const NSWindowOcclusionStateVisible If set, at least part of the window is visible. If not set, the entire window is occluded. Windows with non-rectangular shapes may be completely occluded on screen but still count as visible, if their bounding box falls into a visible region. Windows that are completely transparent may also still count as visible.
    */
    pub enum NSWindowOcclusionState {
        NSWindowOcclusionStateVisible = 1 << 1,
    }
);

typed_extensible_enum!(
    pub type NSWindowLevel = NSInteger;
);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSSelectionDirection {
        NSDirectSelection = 0,
        NSSelectingNext = 1,
        NSSelectingPrevious = 2,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
      @typedef NSWindowButton

     Standard window buttons.
    */
    pub enum NSWindowButton {
        NSWindowCloseButton = 0,
        NSWindowMiniaturizeButton = 1,
        NSWindowZoomButton = 2,
        NSWindowToolbarButton = 3,
        NSWindowDocumentIconButton = 4,
        NSWindowDocumentVersionsButton = 6,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    /**
      @typedef NSWindowTitleVisibility

     @const NSWindowTitleVisible  The default mode has a normal window title and titlebar buttons.
     @const NSWindowTitleHidden The always hidden mode hides the title and moves the toolbar up into the area previously occupied by the title.
    */
    pub enum NSWindowTitleVisibility {
        NSWindowTitleVisible = 0,
        NSWindowTitleHidden = 1,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    /**
      @typedef NSWindowToolbarStyle

     @const NSWindowToolbarStyleAutomatic The default value. The style will be determined by the window's given configuration.
     @const NSWindowToolbarStyleExpanded The toolbar will appear below the window title.
     @const NSWindowToolbarStylePreference The toolbar will appear below the window title and the items in the toolbar will attempt to have equal widths when possible.
     @const NSWindowToolbarStyleUnified The window title will appear inline with the toolbar when visible.
     @const NSWindowToolbarStyleUnifiedCompact Same as \c NSWindowToolbarStyleUnified, but with reduced margins in the toolbar allowing more focus to be on the contents of the window.
    */
    pub enum NSWindowToolbarStyle {
        NSWindowToolbarStyleAutomatic = 0,
        NSWindowToolbarStyleExpanded = 1,
        NSWindowToolbarStylePreference = 2,
        NSWindowToolbarStyleUnified = 3,
        NSWindowToolbarStyleUnifiedCompact = 4,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSWindowUserTabbingPreference {
        NSWindowUserTabbingPreferenceManual = 0,
        NSWindowUserTabbingPreferenceAlways = 1,
        NSWindowUserTabbingPreferenceInFullScreen = 2,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    /**
      @typedef NSWindowTabbingMode

     @const NSWindowTabbingModeAutomatic The system automatically prefers to tab this window when appropriate.
     @const NSWindowTabbingModePreferred The window explicitly should prefer to tab when shown.
     @const NSWindowTabbingModeDisallowed The window explicitly should not prefer to tab when shown.
    */
    pub enum NSWindowTabbingMode {
        NSWindowTabbingModeAutomatic = 0,
        NSWindowTabbingModePreferred = 1,
        NSWindowTabbingModeDisallowed = 2,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSTitlebarSeparatorStyle {
        NSTitlebarSeparatorStyleAutomatic = 0,
        NSTitlebarSeparatorStyleNone = 1,
        NSTitlebarSeparatorStyleLine = 2,
        NSTitlebarSeparatorStyleShadow = 3,
    }
);

pub type NSWindowFrameAutosaveName = NSString;

pub type NSWindowPersistableFrameDescriptor = NSString;

pub type NSWindowTabbingIdentifier = NSString;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSWindow")]
    pub struct NSWindow;

    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl ClassType for NSWindow {
        #[inherits(NSObject)]
        type Super = NSResponder;
    }
);

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSAccessibility for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSAccessibilityElementProtocol for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSAnimatablePropertyContainer for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSAppearanceCustomization for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSCoding for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSMenuItemValidation for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSObjectProtocol for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSUserInterfaceItemIdentification for NSWindow {}

#[cfg(feature = "AppKit_NSWindow")]
unsafe impl NSUserInterfaceValidations for NSWindow {}

extern_methods!(
    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl NSWindow {
        #[method(frameRectForContentRect:styleMask:)]
        pub unsafe fn frameRectForContentRect_styleMask(
            c_rect: NSRect,
            style: NSWindowStyleMask,
        ) -> NSRect;

        #[method(contentRectForFrameRect:styleMask:)]
        pub unsafe fn contentRectForFrameRect_styleMask(
            f_rect: NSRect,
            style: NSWindowStyleMask,
        ) -> NSRect;

        #[cfg(feature = "Foundation_NSString")]
        #[method(minFrameWidthWithTitle:styleMask:)]
        pub unsafe fn minFrameWidthWithTitle_styleMask(
            title: &NSString,
            style: NSWindowStyleMask,
        ) -> CGFloat;

        #[method(defaultDepthLimit)]
        pub unsafe fn defaultDepthLimit() -> NSWindowDepth;

        #[method(frameRectForContentRect:)]
        pub unsafe fn frameRectForContentRect(&self, content_rect: NSRect) -> NSRect;

        #[method(contentRectForFrameRect:)]
        pub unsafe fn contentRectForFrameRect(&self, frame_rect: NSRect) -> NSRect;

        #[method_id(@__retain_semantics Init initWithContentRect:styleMask:backing:defer:)]
        pub unsafe fn initWithContentRect_styleMask_backing_defer(
            this: Option<Allocated<Self>>,
            content_rect: NSRect,
            style: NSWindowStyleMask,
            backing_store_type: NSBackingStoreType,
            flag: bool,
        ) -> Id<Self>;

        #[cfg(feature = "AppKit_NSScreen")]
        #[method_id(@__retain_semantics Init initWithContentRect:styleMask:backing:defer:screen:)]
        pub unsafe fn initWithContentRect_styleMask_backing_defer_screen(
            this: Option<Allocated<Self>>,
            content_rect: NSRect,
            style: NSWindowStyleMask,
            backing_store_type: NSBackingStoreType,
            flag: bool,
            screen: Option<&NSScreen>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(this: Option<Allocated<Self>>, coder: &NSCoder) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other title)]
        pub unsafe fn title(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setTitle:)]
        pub unsafe fn setTitle(&self, title: &NSString);

        #[cfg(feature = "Foundation_NSString")]
        /**
          Secondary text that may be displayed adjacent to or below the primary title depending on the configuration of the window.
         A value of empty string will remove the subtitle from the window layout.
        */
        #[method_id(@__retain_semantics Other subtitle)]
        pub unsafe fn subtitle(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Secondary text that may be displayed adjacent to or below the primary title depending on the configuration of the window.
         A value of empty string will remove the subtitle from the window layout.
        */
        #[method(setSubtitle:)]
        pub unsafe fn setSubtitle(&self, subtitle: &NSString);

        /**
          Default value is NSWindowTitleVisible
        */
        #[method(titleVisibility)]
        pub unsafe fn titleVisibility(&self) -> NSWindowTitleVisibility;

        /**
          Default value is NSWindowTitleVisible
        */
        #[method(setTitleVisibility:)]
        pub unsafe fn setTitleVisibility(&self, title_visibility: NSWindowTitleVisibility);

        /**
          When \c YES, the titlebar doesn't draw its background, allowing all buttons to show through, and "click through" to happen. In general, this is only useful when \c NSFullSizeContentViewWindowMask is set.
        */
        #[method(titlebarAppearsTransparent)]
        pub unsafe fn titlebarAppearsTransparent(&self) -> bool;

        /**
          When \c YES, the titlebar doesn't draw its background, allowing all buttons to show through, and "click through" to happen. In general, this is only useful when \c NSFullSizeContentViewWindowMask is set.
        */
        #[method(setTitlebarAppearsTransparent:)]
        pub unsafe fn setTitlebarAppearsTransparent(&self, titlebar_appears_transparent: bool);

        /**
          Specifies how the titlebar area of the window should appear when the window displays an NSToolbar
        */
        #[method(toolbarStyle)]
        pub unsafe fn toolbarStyle(&self) -> NSWindowToolbarStyle;

        /**
          Specifies how the titlebar area of the window should appear when the window displays an NSToolbar
        */
        #[method(setToolbarStyle:)]
        pub unsafe fn setToolbarStyle(&self, toolbar_style: NSWindowToolbarStyle);

        /**
          The \c contentLayoutRect will return the area inside the window that is for non-obscured content. Typically, this is the same thing as the `contentView`'s frame. However, for windows with the \c NSFullSizeContentViewWindowMask set, there needs to be a way to determine the portion that is not under the toolbar. The \c contentLayoutRect returns the portion of the layout that is not obscured under the toolbar. \c contentLayoutRect is in window coordinates. It is KVO compliant.
        */
        #[method(contentLayoutRect)]
        pub unsafe fn contentLayoutRect(&self) -> NSRect;

        /**
          \c contentLayoutGuide is a corollary to \c contentLayoutRect. It can be used by autolayout constraints to automatically bind to the \c contentLayoutRect.
        */
        #[method_id(@__retain_semantics Other contentLayoutGuide)]
        pub unsafe fn contentLayoutGuide(&self) -> Option<Id<Object>>;

        #[cfg(all(
            feature = "AppKit_NSTitlebarAccessoryViewController",
            feature = "Foundation_NSArray"
        ))]
        /**
          The following methods allow you to add accessory views to the titlebar/toolbar area of a window. See NSTitlebarAccessoryViewController for more details.
        */
        #[method_id(@__retain_semantics Other titlebarAccessoryViewControllers)]
        pub unsafe fn titlebarAccessoryViewControllers(
            &self,
        ) -> Id<NSArray<NSTitlebarAccessoryViewController>>;

        #[cfg(all(
            feature = "AppKit_NSTitlebarAccessoryViewController",
            feature = "Foundation_NSArray"
        ))]
        /**
          The following methods allow you to add accessory views to the titlebar/toolbar area of a window. See NSTitlebarAccessoryViewController for more details.
        */
        #[method(setTitlebarAccessoryViewControllers:)]
        pub unsafe fn setTitlebarAccessoryViewControllers(
            &self,
            titlebar_accessory_view_controllers: &NSArray<NSTitlebarAccessoryViewController>,
        );

        #[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
        #[method(addTitlebarAccessoryViewController:)]
        pub unsafe fn addTitlebarAccessoryViewController(
            &self,
            child_view_controller: &NSTitlebarAccessoryViewController,
        );

        #[cfg(feature = "AppKit_NSTitlebarAccessoryViewController")]
        #[method(insertTitlebarAccessoryViewController:atIndex:)]
        pub unsafe fn insertTitlebarAccessoryViewController_atIndex(
            &self,
            child_view_controller: &NSTitlebarAccessoryViewController,
            index: NSInteger,
        );

        #[method(removeTitlebarAccessoryViewControllerAtIndex:)]
        pub unsafe fn removeTitlebarAccessoryViewControllerAtIndex(&self, index: NSInteger);

        #[cfg(feature = "Foundation_NSURL")]
        /**
          If url is not nil and its path is not empty, the window will show a document icon in the titlebar.
         If the url represents a filename or other resource with a known icon, that icon will be used as the document icon.  Otherwise the default document icon will be used.  The icon can be customized using `-[[NSWindow standardWindowButton:NSWindowDocumentIconButton] setImage:customImage]`.  If url is not nil and its path is not empty, the window will have a pop-up menu which can be shown via command-click on the area containing the document icon and title.  By default, this menu will display the path components of the url.  The presence and contents of this menu can be controlled by the delegate method `-[window:shouldPopUpDocumentPathMenu:]`
         If the url is nil or has an empty path, the window will not show a document icon and will not have a pop-up menu available via command-click.
        */
        #[method_id(@__retain_semantics Other representedURL)]
        pub unsafe fn representedURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
          If url is not nil and its path is not empty, the window will show a document icon in the titlebar.
         If the url represents a filename or other resource with a known icon, that icon will be used as the document icon.  Otherwise the default document icon will be used.  The icon can be customized using `-[[NSWindow standardWindowButton:NSWindowDocumentIconButton] setImage:customImage]`.  If url is not nil and its path is not empty, the window will have a pop-up menu which can be shown via command-click on the area containing the document icon and title.  By default, this menu will display the path components of the url.  The presence and contents of this menu can be controlled by the delegate method `-[window:shouldPopUpDocumentPathMenu:]`
         If the url is nil or has an empty path, the window will not show a document icon and will not have a pop-up menu available via command-click.
        */
        #[method(setRepresentedURL:)]
        pub unsafe fn setRepresentedURL(&self, represented_url: Option<&NSURL>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other representedFilename)]
        pub unsafe fn representedFilename(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setRepresentedFilename:)]
        pub unsafe fn setRepresentedFilename(&self, represented_filename: &NSString);

        #[cfg(feature = "Foundation_NSString")]
        #[method(setTitleWithRepresentedFilename:)]
        pub unsafe fn setTitleWithRepresentedFilename(&self, filename: &NSString);

        #[method(isExcludedFromWindowsMenu)]
        pub unsafe fn isExcludedFromWindowsMenu(&self) -> bool;

        #[method(setExcludedFromWindowsMenu:)]
        pub unsafe fn setExcludedFromWindowsMenu(&self, excluded_from_windows_menu: bool);

        #[cfg(feature = "AppKit_NSView")]
        #[method_id(@__retain_semantics Other contentView)]
        pub unsafe fn contentView(&self) -> Option<Id<NSView>>;

        #[cfg(feature = "AppKit_NSView")]
        #[method(setContentView:)]
        pub unsafe fn setContentView(&self, content_view: Option<&NSView>);

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSWindowDelegate>>>;

        #[method(setDelegate:)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSWindowDelegate>>);

        #[method(windowNumber)]
        pub unsafe fn windowNumber(&self) -> NSInteger;

        /**
          @note The styleMask can only be set on macOS 10.6 and later. Valid \c styleMask settings have the same restrictions as the \c styleMask passed to `-initWithContentRect:styleMask:backing:defer:`.  Some \c styleMask changes will cause the view hierarchy to be rebuilt, since there is a different subclass for the top level view of a borderless window than for the top level view of a titled window.
        */
        #[method(styleMask)]
        pub unsafe fn styleMask(&self) -> NSWindowStyleMask;

        /**
          @note The styleMask can only be set on macOS 10.6 and later. Valid \c styleMask settings have the same restrictions as the \c styleMask passed to `-initWithContentRect:styleMask:backing:defer:`.  Some \c styleMask changes will cause the view hierarchy to be rebuilt, since there is a different subclass for the top level view of a borderless window than for the top level view of a titled window.
        */
        #[method(setStyleMask:)]
        pub unsafe fn setStyleMask(&self, style_mask: NSWindowStyleMask);

        #[cfg(feature = "AppKit_NSText")]
        #[method_id(@__retain_semantics Other fieldEditor:forObject:)]
        pub unsafe fn fieldEditor_forObject(
            &self,
            create_flag: bool,
            object: Option<&Object>,
        ) -> Option<Id<NSText>>;

        #[method(endEditingFor:)]
        pub unsafe fn endEditingFor(&self, object: Option<&Object>);

        #[cfg(feature = "AppKit_NSScreen")]
        #[method(constrainFrameRect:toScreen:)]
        pub unsafe fn constrainFrameRect_toScreen(
            &self,
            frame_rect: NSRect,
            screen: Option<&NSScreen>,
        ) -> NSRect;

        #[method(setFrame:display:)]
        pub unsafe fn setFrame_display(&self, frame_rect: NSRect, flag: bool);

        #[method(setContentSize:)]
        pub unsafe fn setContentSize(&self, size: NSSize);

        #[method(setFrameOrigin:)]
        pub unsafe fn setFrameOrigin(&self, point: NSPoint);

        #[method(setFrameTopLeftPoint:)]
        pub unsafe fn setFrameTopLeftPoint(&self, point: NSPoint);

        #[method(cascadeTopLeftFromPoint:)]
        pub unsafe fn cascadeTopLeftFromPoint(&self, top_left_point: NSPoint) -> NSPoint;

        #[method(frame)]
        pub unsafe fn frame(&self) -> NSRect;

        #[method(animationResizeTime:)]
        pub unsafe fn animationResizeTime(&self, new_frame: NSRect) -> NSTimeInterval;

        #[method(setFrame:display:animate:)]
        pub unsafe fn setFrame_display_animate(
            &self,
            frame_rect: NSRect,
            display_flag: bool,
            animate_flag: bool,
        );

        #[method(inLiveResize)]
        pub unsafe fn inLiveResize(&self) -> bool;

        #[method(resizeIncrements)]
        pub unsafe fn resizeIncrements(&self) -> NSSize;

        #[method(setResizeIncrements:)]
        pub unsafe fn setResizeIncrements(&self, resize_increments: NSSize);

        #[method(aspectRatio)]
        pub unsafe fn aspectRatio(&self) -> NSSize;

        #[method(setAspectRatio:)]
        pub unsafe fn setAspectRatio(&self, aspect_ratio: NSSize);

        #[method(contentResizeIncrements)]
        pub unsafe fn contentResizeIncrements(&self) -> NSSize;

        #[method(setContentResizeIncrements:)]
        pub unsafe fn setContentResizeIncrements(&self, content_resize_increments: NSSize);

        #[method(contentAspectRatio)]
        pub unsafe fn contentAspectRatio(&self) -> NSSize;

        #[method(setContentAspectRatio:)]
        pub unsafe fn setContentAspectRatio(&self, content_aspect_ratio: NSSize);

        #[method(viewsNeedDisplay)]
        pub unsafe fn viewsNeedDisplay(&self) -> bool;

        #[method(setViewsNeedDisplay:)]
        pub unsafe fn setViewsNeedDisplay(&self, views_need_display: bool);

        #[method(displayIfNeeded)]
        pub unsafe fn displayIfNeeded(&self);

        #[method(display)]
        pub unsafe fn display(&self);

        #[method(preservesContentDuringLiveResize)]
        pub unsafe fn preservesContentDuringLiveResize(&self) -> bool;

        #[method(setPreservesContentDuringLiveResize:)]
        pub unsafe fn setPreservesContentDuringLiveResize(
            &self,
            preserves_content_during_live_resize: bool,
        );

        #[method(update)]
        pub unsafe fn update(&self);

        #[method(makeFirstResponder:)]
        pub unsafe fn makeFirstResponder(&self, responder: Option<&NSResponder>) -> bool;

        /**
          firstResponder is Key Value Observing (KVO) compliant.
        */
        #[method_id(@__retain_semantics Other firstResponder)]
        pub unsafe fn firstResponder(&self) -> Option<Id<NSResponder>>;

        #[method(resizeFlags)]
        pub unsafe fn resizeFlags(&self) -> NSEventModifierFlags;

        #[method(close)]
        pub unsafe fn close(&self);

        #[method(isReleasedWhenClosed)]
        pub unsafe fn isReleasedWhenClosed(&self) -> bool;

        #[method(setReleasedWhenClosed:)]
        pub unsafe fn setReleasedWhenClosed(&self, released_when_closed: bool);

        #[method(miniaturize:)]
        pub unsafe fn miniaturize(&self, sender: Option<&Object>);

        #[method(deminiaturize:)]
        pub unsafe fn deminiaturize(&self, sender: Option<&Object>);

        #[method(isZoomed)]
        pub unsafe fn isZoomed(&self) -> bool;

        #[method(zoom:)]
        pub unsafe fn zoom(&self, sender: Option<&Object>);

        #[method(isMiniaturized)]
        pub unsafe fn isMiniaturized(&self) -> bool;

        #[method(tryToPerform:with:)]
        pub unsafe fn tryToPerform_with(&self, action: Sel, object: Option<&Object>) -> bool;

        #[method_id(@__retain_semantics Other validRequestorForSendType:returnType:)]
        pub unsafe fn validRequestorForSendType_returnType(
            &self,
            send_type: Option<&NSPasteboardType>,
            return_type: Option<&NSPasteboardType>,
        ) -> Option<Id<Object>>;

        #[cfg(feature = "AppKit_NSColor")]
        #[method_id(@__retain_semantics Other backgroundColor)]
        pub unsafe fn backgroundColor(&self) -> Id<NSColor>;

        #[cfg(feature = "AppKit_NSColor")]
        #[method(setBackgroundColor:)]
        pub unsafe fn setBackgroundColor(&self, background_color: Option<&NSColor>);

        #[method(setContentBorderThickness:forEdge:)]
        pub unsafe fn setContentBorderThickness_forEdge(
            &self,
            thickness: CGFloat,
            edge: NSRectEdge,
        );

        #[method(contentBorderThicknessForEdge:)]
        pub unsafe fn contentBorderThicknessForEdge(&self, edge: NSRectEdge) -> CGFloat;

        #[method(setAutorecalculatesContentBorderThickness:forEdge:)]
        pub unsafe fn setAutorecalculatesContentBorderThickness_forEdge(
            &self,
            flag: bool,
            edge: NSRectEdge,
        );

        #[method(autorecalculatesContentBorderThicknessForEdge:)]
        pub unsafe fn autorecalculatesContentBorderThicknessForEdge(
            &self,
            edge: NSRectEdge,
        ) -> bool;

        /**
          Calling -setMovable with a flag of NO will disable server-side dragging of the window via titlebar or background.  -setMovableByWindowBackground:YES is ignored on a window that returns NO from -isMovable.  When a window returns NO for -isMovable, it can be assigned to a different space with its relative screen position preserved.  Note that a resizable window may still be resized, and the window frame may be changed programmatically.  Applications may choose to enable application-controlled window dragging after disabling server-side dragging (perhaps to achieve snapping or pinnning) by handling the mouseDown/mouseDragged/mouseUp sequence in -sendEvent: in an NSWindow subclass.  Note that a non movable window will also not be moved (or resized) by the system in response to a display reconfiguration.
        */
        #[method(isMovable)]
        pub unsafe fn isMovable(&self) -> bool;

        /**
          Calling -setMovable with a flag of NO will disable server-side dragging of the window via titlebar or background.  -setMovableByWindowBackground:YES is ignored on a window that returns NO from -isMovable.  When a window returns NO for -isMovable, it can be assigned to a different space with its relative screen position preserved.  Note that a resizable window may still be resized, and the window frame may be changed programmatically.  Applications may choose to enable application-controlled window dragging after disabling server-side dragging (perhaps to achieve snapping or pinnning) by handling the mouseDown/mouseDragged/mouseUp sequence in -sendEvent: in an NSWindow subclass.  Note that a non movable window will also not be moved (or resized) by the system in response to a display reconfiguration.
        */
        #[method(setMovable:)]
        pub unsafe fn setMovable(&self, movable: bool);

        #[method(isMovableByWindowBackground)]
        pub unsafe fn isMovableByWindowBackground(&self) -> bool;

        #[method(setMovableByWindowBackground:)]
        pub unsafe fn setMovableByWindowBackground(&self, movable_by_window_background: bool);

        #[method(hidesOnDeactivate)]
        pub unsafe fn hidesOnDeactivate(&self) -> bool;

        #[method(setHidesOnDeactivate:)]
        pub unsafe fn setHidesOnDeactivate(&self, hides_on_deactivate: bool);

        /**
          Indicates whether a window can be hidden during `-[NSApplication hide:]`.  Default is \c YES.
        */
        #[method(canHide)]
        pub unsafe fn canHide(&self) -> bool;

        /**
          Indicates whether a window can be hidden during `-[NSApplication hide:]`.  Default is \c YES.
        */
        #[method(setCanHide:)]
        pub unsafe fn setCanHide(&self, can_hide: bool);

        #[method(center)]
        pub unsafe fn center(&self);

        #[method(makeKeyAndOrderFront:)]
        pub unsafe fn makeKeyAndOrderFront(&self, sender: Option<&Object>);

        #[method(orderFront:)]
        pub unsafe fn orderFront(&self, sender: Option<&Object>);

        #[method(orderBack:)]
        pub unsafe fn orderBack(&self, sender: Option<&Object>);

        #[method(orderOut:)]
        pub unsafe fn orderOut(&self, sender: Option<&Object>);

        #[method(orderWindow:relativeTo:)]
        pub unsafe fn orderWindow_relativeTo(
            &self,
            place: NSWindowOrderingMode,
            other_win: NSInteger,
        );

        #[method(orderFrontRegardless)]
        pub unsafe fn orderFrontRegardless(&self);

        #[cfg(feature = "AppKit_NSImage")]
        #[method_id(@__retain_semantics Other miniwindowImage)]
        pub unsafe fn miniwindowImage(&self) -> Option<Id<NSImage>>;

        #[cfg(feature = "AppKit_NSImage")]
        #[method(setMiniwindowImage:)]
        pub unsafe fn setMiniwindowImage(&self, miniwindow_image: Option<&NSImage>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other miniwindowTitle)]
        pub unsafe fn miniwindowTitle(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setMiniwindowTitle:)]
        pub unsafe fn setMiniwindowTitle(&self, miniwindow_title: Option<&NSString>);

        #[cfg(feature = "AppKit_NSDockTile")]
        #[method_id(@__retain_semantics Other dockTile)]
        pub unsafe fn dockTile(&self) -> Id<NSDockTile>;

        #[method(isDocumentEdited)]
        pub unsafe fn isDocumentEdited(&self) -> bool;

        #[method(setDocumentEdited:)]
        pub unsafe fn setDocumentEdited(&self, document_edited: bool);

        #[method(isVisible)]
        pub unsafe fn isVisible(&self) -> bool;

        #[method(isKeyWindow)]
        pub unsafe fn isKeyWindow(&self) -> bool;

        #[method(isMainWindow)]
        pub unsafe fn isMainWindow(&self) -> bool;

        #[method(canBecomeKeyWindow)]
        pub unsafe fn canBecomeKeyWindow(&self) -> bool;

        #[method(canBecomeMainWindow)]
        pub unsafe fn canBecomeMainWindow(&self) -> bool;

        #[method(makeKeyWindow)]
        pub unsafe fn makeKeyWindow(&self);

        #[method(makeMainWindow)]
        pub unsafe fn makeMainWindow(&self);

        #[method(becomeKeyWindow)]
        pub unsafe fn becomeKeyWindow(&self);

        #[method(resignKeyWindow)]
        pub unsafe fn resignKeyWindow(&self);

        #[method(becomeMainWindow)]
        pub unsafe fn becomeMainWindow(&self);

        #[method(resignMainWindow)]
        pub unsafe fn resignMainWindow(&self);

        #[method(worksWhenModal)]
        pub unsafe fn worksWhenModal(&self) -> bool;

        /**
          Normally, application termination is prohibited when a modal window or sheet is open, without consulting the application delegate.  Some windows like the open panel or toolbar customization sheet should not prevent application termination.  `-setPreventsApplicationTerminationWhenModal:NO` on a modal window or sheet will override the default behavior and allow application termination to proceed, either through the sudden termination path if enabled, or on to the next step of consulting the application delegate.  By default, `-preventsApplicationTerminationWhenModal` returns \c YES
        */
        #[method(preventsApplicationTerminationWhenModal)]
        pub unsafe fn preventsApplicationTerminationWhenModal(&self) -> bool;

        /**
          Normally, application termination is prohibited when a modal window or sheet is open, without consulting the application delegate.  Some windows like the open panel or toolbar customization sheet should not prevent application termination.  `-setPreventsApplicationTerminationWhenModal:NO` on a modal window or sheet will override the default behavior and allow application termination to proceed, either through the sudden termination path if enabled, or on to the next step of consulting the application delegate.  By default, `-preventsApplicationTerminationWhenModal` returns \c YES
        */
        #[method(setPreventsApplicationTerminationWhenModal:)]
        pub unsafe fn setPreventsApplicationTerminationWhenModal(
            &self,
            prevents_application_termination_when_modal: bool,
        );

        #[method(convertRectToScreen:)]
        pub unsafe fn convertRectToScreen(&self, rect: NSRect) -> NSRect;

        #[method(convertRectFromScreen:)]
        pub unsafe fn convertRectFromScreen(&self, rect: NSRect) -> NSRect;

        #[method(convertPointToScreen:)]
        pub unsafe fn convertPointToScreen(&self, point: NSPoint) -> NSPoint;

        #[method(convertPointFromScreen:)]
        pub unsafe fn convertPointFromScreen(&self, point: NSPoint) -> NSPoint;

        #[method(convertRectToBacking:)]
        pub unsafe fn convertRectToBacking(&self, rect: NSRect) -> NSRect;

        #[method(convertRectFromBacking:)]
        pub unsafe fn convertRectFromBacking(&self, rect: NSRect) -> NSRect;

        #[method(convertPointToBacking:)]
        pub unsafe fn convertPointToBacking(&self, point: NSPoint) -> NSPoint;

        #[method(convertPointFromBacking:)]
        pub unsafe fn convertPointFromBacking(&self, point: NSPoint) -> NSPoint;

        #[method(backingAlignedRect:options:)]
        pub unsafe fn backingAlignedRect_options(
            &self,
            rect: NSRect,
            options: NSAlignmentOptions,
        ) -> NSRect;

        /**
          Returns the scale factor representing the number of backing store pixels corresponding to each linear unit in window space on this \c NSWindow. This method is provided for rare cases when the explicit scale factor is needed. Please use `-convert*ToBacking:` methods whenever possible.
        */
        #[method(backingScaleFactor)]
        pub unsafe fn backingScaleFactor(&self) -> CGFloat;

        #[method(performClose:)]
        pub unsafe fn performClose(&self, sender: Option<&Object>);

        #[method(performMiniaturize:)]
        pub unsafe fn performMiniaturize(&self, sender: Option<&Object>);

        #[method(performZoom:)]
        pub unsafe fn performZoom(&self, sender: Option<&Object>);

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other dataWithEPSInsideRect:)]
        pub unsafe fn dataWithEPSInsideRect(&self, rect: NSRect) -> Id<NSData>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other dataWithPDFInsideRect:)]
        pub unsafe fn dataWithPDFInsideRect(&self, rect: NSRect) -> Id<NSData>;

        #[method(print:)]
        pub unsafe fn print(&self, sender: Option<&Object>);

        /**
          Default is \c NO. Set to \c YES to allow a window to display tooltips even when the application is in the background.  Note that, enabling tooltips in an inactive application will cause the app to do work any time the mouse passes over the window.  This can degrade system performance.
         Returns \c YES if this window displays tooltips even when the application is in the background.  To configure this setting you should call `-setAllowsToolTipsWhenApplicationIsInactive:` instead of overriding `-allowsToolTipsWhenApplicationIsInactive`.
        */
        #[method(allowsToolTipsWhenApplicationIsInactive)]
        pub unsafe fn allowsToolTipsWhenApplicationIsInactive(&self) -> bool;

        /**
          Default is \c NO. Set to \c YES to allow a window to display tooltips even when the application is in the background.  Note that, enabling tooltips in an inactive application will cause the app to do work any time the mouse passes over the window.  This can degrade system performance.
         Returns \c YES if this window displays tooltips even when the application is in the background.  To configure this setting you should call `-setAllowsToolTipsWhenApplicationIsInactive:` instead of overriding `-allowsToolTipsWhenApplicationIsInactive`.
        */
        #[method(setAllowsToolTipsWhenApplicationIsInactive:)]
        pub unsafe fn setAllowsToolTipsWhenApplicationIsInactive(
            &self,
            allows_tool_tips_when_application_is_inactive: bool,
        );

        #[method(backingType)]
        pub unsafe fn backingType(&self) -> NSBackingStoreType;

        #[method(setBackingType:)]
        pub unsafe fn setBackingType(&self, backing_type: NSBackingStoreType);

        #[method(level)]
        pub unsafe fn level(&self) -> NSWindowLevel;

        #[method(setLevel:)]
        pub unsafe fn setLevel(&self, level: NSWindowLevel);

        #[method(depthLimit)]
        pub unsafe fn depthLimit(&self) -> NSWindowDepth;

        #[method(setDepthLimit:)]
        pub unsafe fn setDepthLimit(&self, depth_limit: NSWindowDepth);

        #[method(setDynamicDepthLimit:)]
        pub unsafe fn setDynamicDepthLimit(&self, flag: bool);

        #[method(hasDynamicDepthLimit)]
        pub unsafe fn hasDynamicDepthLimit(&self) -> bool;

        #[cfg(feature = "AppKit_NSScreen")]
        /**
          The screen property returns the best screen for the window. If the window only intersects one screen, it returns that screen. If it intersects more than one screen, then it resolves the tie through based on what space it is mostly on. It may return nil if there are no available screens, or it is completely off screen.
        */
        #[method_id(@__retain_semantics Other screen)]
        pub unsafe fn screen(&self) -> Option<Id<NSScreen>>;

        #[cfg(feature = "AppKit_NSScreen")]
        #[method_id(@__retain_semantics Other deepestScreen)]
        pub unsafe fn deepestScreen(&self) -> Option<Id<NSScreen>>;

        #[method(hasShadow)]
        pub unsafe fn hasShadow(&self) -> bool;

        #[method(setHasShadow:)]
        pub unsafe fn setHasShadow(&self, has_shadow: bool);

        #[method(invalidateShadow)]
        pub unsafe fn invalidateShadow(&self);

        #[method(alphaValue)]
        pub unsafe fn alphaValue(&self) -> CGFloat;

        #[method(setAlphaValue:)]
        pub unsafe fn setAlphaValue(&self, alpha_value: CGFloat);

        #[method(isOpaque)]
        pub unsafe fn isOpaque(&self) -> bool;

        #[method(setOpaque:)]
        pub unsafe fn setOpaque(&self, opaque: bool);

        /**
          `-setSharingType:` specifies whether the window content can be read and/or written from another process.  The default sharing type is \c NSWindowSharingReadOnly, which means other processes can read the window content (eg. for window capture) but cannot modify it.  If you set your window sharing type to \c NSWindowSharingNone, so that the content cannot be captured, your window will also not be able to participate in a number of system services, so this setting should be used with caution.  If you set your window sharing type to \c NSWindowSharingReadWrite, other processes can both read and modify the window content.
        */
        #[method(sharingType)]
        pub unsafe fn sharingType(&self) -> NSWindowSharingType;

        /**
          `-setSharingType:` specifies whether the window content can be read and/or written from another process.  The default sharing type is \c NSWindowSharingReadOnly, which means other processes can read the window content (eg. for window capture) but cannot modify it.  If you set your window sharing type to \c NSWindowSharingNone, so that the content cannot be captured, your window will also not be able to participate in a number of system services, so this setting should be used with caution.  If you set your window sharing type to \c NSWindowSharingReadWrite, other processes can both read and modify the window content.
        */
        #[method(setSharingType:)]
        pub unsafe fn setSharingType(&self, sharing_type: NSWindowSharingType);

        /**
          Controls whether threading of view drawing should be enabled for this window.  Defaults to \c YES.  When this is set to \c YES, AppKit's view system is allowed to perform `-drawRect:` activity for the window's views on threads other than the main thread, for views that have `canDrawConcurrently == YES`.  When this is set to \c NO, the window's views will be drawn serially as on 10.5 and earlier, even though some of the views may have `canDrawConcurrently == YES`.
        */
        #[method(allowsConcurrentViewDrawing)]
        pub unsafe fn allowsConcurrentViewDrawing(&self) -> bool;

        /**
          Controls whether threading of view drawing should be enabled for this window.  Defaults to \c YES.  When this is set to \c YES, AppKit's view system is allowed to perform `-drawRect:` activity for the window's views on threads other than the main thread, for views that have `canDrawConcurrently == YES`.  When this is set to \c NO, the window's views will be drawn serially as on 10.5 and earlier, even though some of the views may have `canDrawConcurrently == YES`.
        */
        #[method(setAllowsConcurrentViewDrawing:)]
        pub unsafe fn setAllowsConcurrentViewDrawing(&self, allows_concurrent_view_drawing: bool);

        #[method(displaysWhenScreenProfileChanges)]
        pub unsafe fn displaysWhenScreenProfileChanges(&self) -> bool;

        #[method(setDisplaysWhenScreenProfileChanges:)]
        pub unsafe fn setDisplaysWhenScreenProfileChanges(
            &self,
            displays_when_screen_profile_changes: bool,
        );

        #[method(disableScreenUpdatesUntilFlush)]
        pub unsafe fn disableScreenUpdatesUntilFlush(&self);

        /**
          This API controls whether the receiver is permitted onscreen before the user has logged in.  This property is off by default.  Alert panels and windows presented by input managers are examples of windows which should have this property set.
        */
        #[method(canBecomeVisibleWithoutLogin)]
        pub unsafe fn canBecomeVisibleWithoutLogin(&self) -> bool;

        /**
          This API controls whether the receiver is permitted onscreen before the user has logged in.  This property is off by default.  Alert panels and windows presented by input managers are examples of windows which should have this property set.
        */
        #[method(setCanBecomeVisibleWithoutLogin:)]
        pub unsafe fn setCanBecomeVisibleWithoutLogin(
            &self,
            can_become_visible_without_login: bool,
        );

        #[method(collectionBehavior)]
        pub unsafe fn collectionBehavior(&self) -> NSWindowCollectionBehavior;

        #[method(setCollectionBehavior:)]
        pub unsafe fn setCollectionBehavior(&self, collection_behavior: NSWindowCollectionBehavior);

        /**
          Provides for per-window control over automatic orderFront/orderOut animation behaviors added in 10.7.  Can be set to \c NSWindowAnimationBehaviorNone to disable Appkit's automatic animations for a given window, or to one of the other non-Default \c NSWindowAnimationBehavior values to override AppKit's automatic inference of appropriate animation behavior based on the window's apparent type.
        */
        #[method(animationBehavior)]
        pub unsafe fn animationBehavior(&self) -> NSWindowAnimationBehavior;

        /**
          Provides for per-window control over automatic orderFront/orderOut animation behaviors added in 10.7.  Can be set to \c NSWindowAnimationBehaviorNone to disable Appkit's automatic animations for a given window, or to one of the other non-Default \c NSWindowAnimationBehavior values to override AppKit's automatic inference of appropriate animation behavior based on the window's apparent type.
        */
        #[method(setAnimationBehavior:)]
        pub unsafe fn setAnimationBehavior(&self, animation_behavior: NSWindowAnimationBehavior);

        /**
          Returns \c YES if this window is associated with the active space.  For visible windows, this API indicates whether the window is currently visible on the active space.  For offscreen windows, it indicates whether ordering the window onscreen would make it bring it onto the active space
        */
        #[method(isOnActiveSpace)]
        pub unsafe fn isOnActiveSpace(&self) -> bool;

        #[method(toggleFullScreen:)]
        pub unsafe fn toggleFullScreen(&self, sender: Option<&Object>);

        #[method_id(@__retain_semantics Other stringWithSavedFrame)]
        pub unsafe fn stringWithSavedFrame(&self) -> Id<NSWindowPersistableFrameDescriptor>;

        #[method(setFrameFromString:)]
        pub unsafe fn setFrameFromString(&self, string: &NSWindowPersistableFrameDescriptor);

        #[method(saveFrameUsingName:)]
        pub unsafe fn saveFrameUsingName(&self, name: &NSWindowFrameAutosaveName);

        #[method(setFrameUsingName:force:)]
        pub unsafe fn setFrameUsingName_force(
            &self,
            name: &NSWindowFrameAutosaveName,
            force: bool,
        ) -> bool;

        #[method(setFrameUsingName:)]
        pub unsafe fn setFrameUsingName(&self, name: &NSWindowFrameAutosaveName) -> bool;

        #[method(setFrameAutosaveName:)]
        pub unsafe fn setFrameAutosaveName(&self, name: &NSWindowFrameAutosaveName) -> bool;

        #[method_id(@__retain_semantics Other frameAutosaveName)]
        pub unsafe fn frameAutosaveName(&self) -> Id<NSWindowFrameAutosaveName>;

        #[method(removeFrameUsingName:)]
        pub unsafe fn removeFrameUsingName(name: &NSWindowFrameAutosaveName);

        /**
          NOTE: minSize/contentMinSize and maxSize/contentMaxSize are ignored when using autolayout.
        */
        #[method(minSize)]
        pub unsafe fn minSize(&self) -> NSSize;

        /**
          NOTE: minSize/contentMinSize and maxSize/contentMaxSize are ignored when using autolayout.
        */
        #[method(setMinSize:)]
        pub unsafe fn setMinSize(&self, min_size: NSSize);

        #[method(maxSize)]
        pub unsafe fn maxSize(&self) -> NSSize;

        #[method(setMaxSize:)]
        pub unsafe fn setMaxSize(&self, max_size: NSSize);

        #[method(contentMinSize)]
        pub unsafe fn contentMinSize(&self) -> NSSize;

        #[method(setContentMinSize:)]
        pub unsafe fn setContentMinSize(&self, content_min_size: NSSize);

        #[method(contentMaxSize)]
        pub unsafe fn contentMaxSize(&self) -> NSSize;

        #[method(setContentMaxSize:)]
        pub unsafe fn setContentMaxSize(&self, content_max_size: NSSize);

        /**
          These are the min and max values for a full screen tiled window.

        In general, one should not need to explicitly set the min/maxFullScreenContentSize. If an application does not change its window content upon entering full screen, then the normal auto layout min and max size will be sufficient, and one should not set these values. If an application does significantly rework the UI in full screen, then it may be necessary to set a min/maxFullScreenContentSize. This size is what is used to determine if a window can fit when it is in full screen in a tile. This property may be used even if the window does not support full screen, but are implicitly opted into supporting a full screen tile based on resizing behavior and window properties (see the collectionBehavior property). By default, the system uses auto layout to determine the min and max sizes. If auto layout is not used, contentMinSize and contentMaxSize are queried.
        */
        #[method(minFullScreenContentSize)]
        pub unsafe fn minFullScreenContentSize(&self) -> NSSize;

        /**
          These are the min and max values for a full screen tiled window.

        In general, one should not need to explicitly set the min/maxFullScreenContentSize. If an application does not change its window content upon entering full screen, then the normal auto layout min and max size will be sufficient, and one should not set these values. If an application does significantly rework the UI in full screen, then it may be necessary to set a min/maxFullScreenContentSize. This size is what is used to determine if a window can fit when it is in full screen in a tile. This property may be used even if the window does not support full screen, but are implicitly opted into supporting a full screen tile based on resizing behavior and window properties (see the collectionBehavior property). By default, the system uses auto layout to determine the min and max sizes. If auto layout is not used, contentMinSize and contentMaxSize are queried.
        */
        #[method(setMinFullScreenContentSize:)]
        pub unsafe fn setMinFullScreenContentSize(&self, min_full_screen_content_size: NSSize);

        #[method(maxFullScreenContentSize)]
        pub unsafe fn maxFullScreenContentSize(&self) -> NSSize;

        #[method(setMaxFullScreenContentSize:)]
        pub unsafe fn setMaxFullScreenContentSize(&self, max_full_screen_content_size: NSSize);

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method_id(@__retain_semantics Other deviceDescription)]
        pub unsafe fn deviceDescription(&self) -> Id<NSDictionary<NSDeviceDescriptionKey, Object>>;

        #[cfg(feature = "AppKit_NSWindowController")]
        #[method_id(@__retain_semantics Other windowController)]
        pub unsafe fn windowController(&self) -> Option<Id<NSWindowController>>;

        #[cfg(feature = "AppKit_NSWindowController")]
        #[method(setWindowController:)]
        pub unsafe fn setWindowController(&self, window_controller: Option<&NSWindowController>);

        #[method(beginSheet:completionHandler:)]
        pub unsafe fn beginSheet_completionHandler(
            &self,
            sheet_window: &NSWindow,
            handler: Option<&Block<(NSModalResponse,), ()>>,
        );

        #[method(beginCriticalSheet:completionHandler:)]
        pub unsafe fn beginCriticalSheet_completionHandler(
            &self,
            sheet_window: &NSWindow,
            handler: Option<&Block<(NSModalResponse,), ()>>,
        );

        #[method(endSheet:)]
        pub unsafe fn endSheet(&self, sheet_window: &NSWindow);

        #[method(endSheet:returnCode:)]
        pub unsafe fn endSheet_returnCode(
            &self,
            sheet_window: &NSWindow,
            return_code: NSModalResponse,
        );

        #[cfg(feature = "Foundation_NSArray")]
        /**
          An ordered array of the sheets on the window. This consists of the presented sheets in top-to-bottom order, followed by queued sheets in the order they were queued. This does not include nested/sub-sheets.
        */
        #[method_id(@__retain_semantics Other sheets)]
        pub unsafe fn sheets(&self) -> Id<NSArray<NSWindow>>;

        /**
          Returns the top-most sheet if there is one or more sheets, or nil if there is no sheet.
        */
        #[method_id(@__retain_semantics Other attachedSheet)]
        pub unsafe fn attachedSheet(&self) -> Option<Id<NSWindow>>;

        #[method(isSheet)]
        pub unsafe fn isSheet(&self) -> bool;

        /**
          Returns the window that the sheet is directly attached to. This is based on the logical attachment of the sheet, not visual attachment.
         This relationship exists starting when the sheet is begun (using \c NSApplication's `-beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo: or NSWindow's -beginSheet:completionHandler:`), and ending once it is ordered out.
         Returns nil if the window is not a sheet or has no sheet parent.
        */
        #[method_id(@__retain_semantics Other sheetParent)]
        pub unsafe fn sheetParent(&self) -> Option<Id<NSWindow>>;

        #[cfg(feature = "AppKit_NSButton")]
        #[method_id(@__retain_semantics Other standardWindowButton:forStyleMask:)]
        pub unsafe fn standardWindowButton_forStyleMask(
            b: NSWindowButton,
            style_mask: NSWindowStyleMask,
        ) -> Option<Id<NSButton>>;

        #[cfg(feature = "AppKit_NSButton")]
        #[method_id(@__retain_semantics Other standardWindowButton:)]
        pub unsafe fn standardWindowButton(&self, b: NSWindowButton) -> Option<Id<NSButton>>;

        #[method(addChildWindow:ordered:)]
        pub unsafe fn addChildWindow_ordered(
            &self,
            child_win: &NSWindow,
            place: NSWindowOrderingMode,
        );

        #[method(removeChildWindow:)]
        pub unsafe fn removeChildWindow(&self, child_win: &NSWindow);

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other childWindows)]
        pub unsafe fn childWindows(&self) -> Option<Id<NSArray<NSWindow>>>;

        #[method_id(@__retain_semantics Other parentWindow)]
        pub unsafe fn parentWindow(&self) -> Option<Id<NSWindow>>;

        #[method(setParentWindow:)]
        pub unsafe fn setParentWindow(&self, parent_window: Option<&NSWindow>);

        /**
          If set, the receiver will inherit the appearance of that object, as well as use KVO to observe its effectiveAppearance for changes. Typically this is used for child windows that are shown from a parent window or specific view. Defaults to NSApp.
        */
        #[method_id(@__retain_semantics Other appearanceSource)]
        pub unsafe fn appearanceSource(&self) -> Option<Id<NSObject>>;

        /**
          If set, the receiver will inherit the appearance of that object, as well as use KVO to observe its effectiveAppearance for changes. Typically this is used for child windows that are shown from a parent window or specific view. Defaults to NSApp.
        */
        #[method(setAppearanceSource:)]
        pub unsafe fn setAppearanceSource(&self, appearance_source: Option<&NSObject>);

        #[cfg(feature = "AppKit_NSColorSpace")]
        #[method_id(@__retain_semantics Other colorSpace)]
        pub unsafe fn colorSpace(&self) -> Option<Id<NSColorSpace>>;

        #[cfg(feature = "AppKit_NSColorSpace")]
        #[method(setColorSpace:)]
        pub unsafe fn setColorSpace(&self, color_space: Option<&NSColorSpace>);

        #[method(canRepresentDisplayGamut:)]
        pub unsafe fn canRepresentDisplayGamut(&self, display_gamut: NSDisplayGamut) -> bool;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSNumber"))]
        #[method_id(@__retain_semantics Other windowNumbersWithOptions:)]
        pub unsafe fn windowNumbersWithOptions(
            options: NSWindowNumberListOptions,
        ) -> Option<Id<NSArray<NSNumber>>>;

        #[method(windowNumberAtPoint:belowWindowWithWindowNumber:)]
        pub unsafe fn windowNumberAtPoint_belowWindowWithWindowNumber(
            point: NSPoint,
            window_number: NSInteger,
        ) -> NSInteger;

        #[method(occlusionState)]
        pub unsafe fn occlusionState(&self) -> NSWindowOcclusionState;

        /**
          Specifies the style of separator displayed between the window's titlebar and content.

        The default value is NSTitlebarSeparatorStyleAutomatic. Changing this value will override any preference made by `NSSplitViewItem`.
        */
        #[method(titlebarSeparatorStyle)]
        pub unsafe fn titlebarSeparatorStyle(&self) -> NSTitlebarSeparatorStyle;

        /**
          Specifies the style of separator displayed between the window's titlebar and content.

        The default value is NSTitlebarSeparatorStyleAutomatic. Changing this value will override any preference made by `NSSplitViewItem`.
        */
        #[method(setTitlebarSeparatorStyle:)]
        pub unsafe fn setTitlebarSeparatorStyle(
            &self,
            titlebar_separator_style: NSTitlebarSeparatorStyle,
        );

        #[cfg(feature = "AppKit_NSViewController")]
        /**
          The main content view controller for the window. This provides the contentView of the window. Assigning this value will remove the existing contentView and will make the contentViewController.view the main contentView for the window. The default value is nil. The contentViewController only controls the contentView, and not the title of the window. The window title can easily be bound to the contentViewController with the following: [window bind:NSTitleBinding toObject:contentViewController withKeyPath:@"title" options:nil]. Setting the contentViewController will cause the window to resize based on the current size of the contentViewController. Autolayout should be used to restrict the size of the window. The value of the contentViewController is encoded in the NIB. Directly assigning a contentView will clear out the contentViewController.
        */
        #[method_id(@__retain_semantics Other contentViewController)]
        pub unsafe fn contentViewController(&self) -> Option<Id<NSViewController>>;

        #[cfg(feature = "AppKit_NSViewController")]
        /**
          The main content view controller for the window. This provides the contentView of the window. Assigning this value will remove the existing contentView and will make the contentViewController.view the main contentView for the window. The default value is nil. The contentViewController only controls the contentView, and not the title of the window. The window title can easily be bound to the contentViewController with the following: [window bind:NSTitleBinding toObject:contentViewController withKeyPath:@"title" options:nil]. Setting the contentViewController will cause the window to resize based on the current size of the contentViewController. Autolayout should be used to restrict the size of the window. The value of the contentViewController is encoded in the NIB. Directly assigning a contentView will clear out the contentViewController.
        */
        #[method(setContentViewController:)]
        pub unsafe fn setContentViewController(
            &self,
            content_view_controller: Option<&NSViewController>,
        );

        #[cfg(feature = "AppKit_NSViewController")]
        #[method_id(@__retain_semantics Other windowWithContentViewController:)]
        pub unsafe fn windowWithContentViewController(
            content_view_controller: &NSViewController,
        ) -> Id<Self>;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(performWindowDragWithEvent:)]
        pub unsafe fn performWindowDragWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "AppKit_NSView")]
        #[method_id(@__retain_semantics Other initialFirstResponder)]
        pub unsafe fn initialFirstResponder(&self) -> Option<Id<NSView>>;

        #[cfg(feature = "AppKit_NSView")]
        #[method(setInitialFirstResponder:)]
        pub unsafe fn setInitialFirstResponder(&self, initial_first_responder: Option<&NSView>);

        #[method(selectNextKeyView:)]
        pub unsafe fn selectNextKeyView(&self, sender: Option<&Object>);

        #[method(selectPreviousKeyView:)]
        pub unsafe fn selectPreviousKeyView(&self, sender: Option<&Object>);

        #[cfg(feature = "AppKit_NSView")]
        #[method(selectKeyViewFollowingView:)]
        pub unsafe fn selectKeyViewFollowingView(&self, view: &NSView);

        #[cfg(feature = "AppKit_NSView")]
        #[method(selectKeyViewPrecedingView:)]
        pub unsafe fn selectKeyViewPrecedingView(&self, view: &NSView);

        #[method(keyViewSelectionDirection)]
        pub unsafe fn keyViewSelectionDirection(&self) -> NSSelectionDirection;

        #[cfg(feature = "AppKit_NSButtonCell")]
        #[method_id(@__retain_semantics Other defaultButtonCell)]
        pub unsafe fn defaultButtonCell(&self) -> Option<Id<NSButtonCell>>;

        #[cfg(feature = "AppKit_NSButtonCell")]
        #[method(setDefaultButtonCell:)]
        pub unsafe fn setDefaultButtonCell(&self, default_button_cell: Option<&NSButtonCell>);

        #[method(disableKeyEquivalentForDefaultButtonCell)]
        pub unsafe fn disableKeyEquivalentForDefaultButtonCell(&self);

        #[method(enableKeyEquivalentForDefaultButtonCell)]
        pub unsafe fn enableKeyEquivalentForDefaultButtonCell(&self);

        #[method(autorecalculatesKeyViewLoop)]
        pub unsafe fn autorecalculatesKeyViewLoop(&self) -> bool;

        #[method(setAutorecalculatesKeyViewLoop:)]
        pub unsafe fn setAutorecalculatesKeyViewLoop(&self, autorecalculates_key_view_loop: bool);

        #[method(recalculateKeyViewLoop)]
        pub unsafe fn recalculateKeyViewLoop(&self);

        #[cfg(feature = "AppKit_NSToolbar")]
        #[method_id(@__retain_semantics Other toolbar)]
        pub unsafe fn toolbar(&self) -> Option<Id<NSToolbar>>;

        #[cfg(feature = "AppKit_NSToolbar")]
        #[method(setToolbar:)]
        pub unsafe fn setToolbar(&self, toolbar: Option<&NSToolbar>);

        #[method(toggleToolbarShown:)]
        pub unsafe fn toggleToolbarShown(&self, sender: Option<&Object>);

        #[method(runToolbarCustomizationPalette:)]
        pub unsafe fn runToolbarCustomizationPalette(&self, sender: Option<&Object>);

        #[deprecated = "This property has no effect"]
        #[method(showsToolbarButton)]
        pub unsafe fn showsToolbarButton(&self) -> bool;

        #[deprecated = "This property has no effect"]
        #[method(setShowsToolbarButton:)]
        pub unsafe fn setShowsToolbarButton(&self, shows_toolbar_button: bool);

        /**
          Allows automatic window tabbing when the value is \c YES. By default, this will be set to \c YES, but applications can explicitly opt out of all automatic tabbing by setting it to NO, and can still adopted explicit window tabbing, if desired.
        */
        #[method(allowsAutomaticWindowTabbing)]
        pub unsafe fn allowsAutomaticWindowTabbing() -> bool;

        /**
          Allows automatic window tabbing when the value is \c YES. By default, this will be set to \c YES, but applications can explicitly opt out of all automatic tabbing by setting it to NO, and can still adopted explicit window tabbing, if desired.
        */
        #[method(setAllowsAutomaticWindowTabbing:)]
        pub unsafe fn setAllowsAutomaticWindowTabbing(allows_automatic_window_tabbing: bool);

        /**
          Returns the user's tabbing preference as set in System Preferences. This value should be queried anytime a new window is made to see if the user wants to automatically show it in tabs.
        */
        #[method(userTabbingPreference)]
        pub unsafe fn userTabbingPreference() -> NSWindowUserTabbingPreference;

        /**
          Get and set the tabbing mode for this window. This should be set before a window is shown. The default value is \c NSWindowTabbingModeAutomatic. When the value is \c NSWindowTabbingModeAutomatic, the system will look at the \c userTabbingPreference and automatically tab windows together based on the tabbingIdentifier, when it is appropriate to do so.
        */
        #[method(tabbingMode)]
        pub unsafe fn tabbingMode(&self) -> NSWindowTabbingMode;

        /**
          Get and set the tabbing mode for this window. This should be set before a window is shown. The default value is \c NSWindowTabbingModeAutomatic. When the value is \c NSWindowTabbingModeAutomatic, the system will look at the \c userTabbingPreference and automatically tab windows together based on the tabbingIdentifier, when it is appropriate to do so.
        */
        #[method(setTabbingMode:)]
        pub unsafe fn setTabbingMode(&self, tabbing_mode: NSWindowTabbingMode);

        /**
          Windows with the same \c tabbingIdentifier will have the ability to be tabbed together when a window is being shown. This allows aggregation of similar windows. By default, the \c tabbingIdentifier will be generated based on inherent window properties, such as the window class name, the delegate class name, the window controller class name, and some additional state. Windows can be explicitly made to group together by using the same \c tabbingIdentifier.
        */
        #[method_id(@__retain_semantics Other tabbingIdentifier)]
        pub unsafe fn tabbingIdentifier(&self) -> Id<NSWindowTabbingIdentifier>;

        /**
          Windows with the same \c tabbingIdentifier will have the ability to be tabbed together when a window is being shown. This allows aggregation of similar windows. By default, the \c tabbingIdentifier will be generated based on inherent window properties, such as the window class name, the delegate class name, the window controller class name, and some additional state. Windows can be explicitly made to group together by using the same \c tabbingIdentifier.
        */
        #[method(setTabbingIdentifier:)]
        pub unsafe fn setTabbingIdentifier(&self, tabbing_identifier: &NSWindowTabbingIdentifier);

        #[method(selectNextTab:)]
        pub unsafe fn selectNextTab(&self, sender: Option<&Object>);

        #[method(selectPreviousTab:)]
        pub unsafe fn selectPreviousTab(&self, sender: Option<&Object>);

        #[method(moveTabToNewWindow:)]
        pub unsafe fn moveTabToNewWindow(&self, sender: Option<&Object>);

        #[method(mergeAllWindows:)]
        pub unsafe fn mergeAllWindows(&self, sender: Option<&Object>);

        #[method(toggleTabBar:)]
        pub unsafe fn toggleTabBar(&self, sender: Option<&Object>);

        #[method(toggleTabOverview:)]
        pub unsafe fn toggleTabOverview(&self, sender: Option<&Object>);

        #[cfg(feature = "Foundation_NSArray")]
        /**
          This is now a cover for `self.tabGroup.windows`, but will return nil if the window is not showing a tab bar.
        */
        #[method_id(@__retain_semantics Other tabbedWindows)]
        pub unsafe fn tabbedWindows(&self) -> Option<Id<NSArray<NSWindow>>>;

        #[method(addTabbedWindow:ordered:)]
        pub unsafe fn addTabbedWindow_ordered(
            &self,
            window: &NSWindow,
            ordered: NSWindowOrderingMode,
        );

        #[cfg(feature = "AppKit_NSWindowTab")]
        /**
          Access the properties for this window when it is a tabbed window environment. See the \c NSWindowTab header and comments for more information.
        */
        #[method_id(@__retain_semantics Other tab)]
        pub unsafe fn tab(&self) -> Id<NSWindowTab>;

        #[cfg(feature = "AppKit_NSWindowTabGroup")]
        /**
          Represents a tab group of windows. This \c tabGroup is lazily created on demand.
        */
        #[method_id(@__retain_semantics Other tabGroup)]
        pub unsafe fn tabGroup(&self) -> Option<Id<NSWindowTabGroup>>;

        /**
          Retrieve the layout direction of the window titlebar: this includes the standard window buttons (close/minimize/maximize buttons) and the title for this window. In general, this will return "right to left" (RTL) if the primary system language is RTL. The layout direction may be RTL even in applications that do not have a RTL language localization. This value should be utilized if an application uses titlebarAppearsTransparent and places controls underneath the titlebar.
        */
        #[method(windowTitlebarLayoutDirection)]
        pub unsafe fn windowTitlebarLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;
    }
);

extern_methods!(
    /// NSEvent
    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl NSWindow {
        #[cfg(feature = "AppKit_NSEvent")]
        #[method(trackEventsMatchingMask:timeout:mode:handler:)]
        pub unsafe fn trackEventsMatchingMask_timeout_mode_handler(
            &self,
            mask: NSEventMask,
            timeout: NSTimeInterval,
            mode: &NSRunLoopMode,
            tracking_handler: &Block<(*mut NSEvent, NonNull<Bool>), ()>,
        );

        #[cfg(feature = "AppKit_NSEvent")]
        #[method_id(@__retain_semantics Other nextEventMatchingMask:)]
        pub unsafe fn nextEventMatchingMask(&self, mask: NSEventMask) -> Option<Id<NSEvent>>;

        #[cfg(all(feature = "AppKit_NSEvent", feature = "Foundation_NSDate"))]
        #[method_id(@__retain_semantics Other nextEventMatchingMask:untilDate:inMode:dequeue:)]
        pub unsafe fn nextEventMatchingMask_untilDate_inMode_dequeue(
            &self,
            mask: NSEventMask,
            expiration: Option<&NSDate>,
            mode: &NSRunLoopMode,
            deq_flag: bool,
        ) -> Option<Id<NSEvent>>;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(discardEventsMatchingMask:beforeEvent:)]
        pub unsafe fn discardEventsMatchingMask_beforeEvent(
            &self,
            mask: NSEventMask,
            last_event: Option<&NSEvent>,
        );

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(postEvent:atStart:)]
        pub unsafe fn postEvent_atStart(&self, event: &NSEvent, flag: bool);

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(sendEvent:)]
        pub unsafe fn sendEvent(&self, event: &NSEvent);

        #[cfg(feature = "AppKit_NSEvent")]
        #[method_id(@__retain_semantics Other currentEvent)]
        pub unsafe fn currentEvent(&self) -> Option<Id<NSEvent>>;

        #[method(acceptsMouseMovedEvents)]
        pub unsafe fn acceptsMouseMovedEvents(&self) -> bool;

        #[method(setAcceptsMouseMovedEvents:)]
        pub unsafe fn setAcceptsMouseMovedEvents(&self, accepts_mouse_moved_events: bool);

        #[method(ignoresMouseEvents)]
        pub unsafe fn ignoresMouseEvents(&self) -> bool;

        #[method(setIgnoresMouseEvents:)]
        pub unsafe fn setIgnoresMouseEvents(&self, ignores_mouse_events: bool);

        #[method(mouseLocationOutsideOfEventStream)]
        pub unsafe fn mouseLocationOutsideOfEventStream(&self) -> NSPoint;
    }
);

extern_methods!(
    /// NSCursorRect
    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl NSWindow {
        #[method(disableCursorRects)]
        pub unsafe fn disableCursorRects(&self);

        #[method(enableCursorRects)]
        pub unsafe fn enableCursorRects(&self);

        #[method(discardCursorRects)]
        pub unsafe fn discardCursorRects(&self);

        #[method(areCursorRectsEnabled)]
        pub unsafe fn areCursorRectsEnabled(&self) -> bool;

        #[cfg(feature = "AppKit_NSView")]
        #[method(invalidateCursorRectsForView:)]
        pub unsafe fn invalidateCursorRectsForView(&self, view: &NSView);

        #[method(resetCursorRects)]
        pub unsafe fn resetCursorRects(&self);
    }
);

extern_methods!(
    /// NSDrag
    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl NSWindow {
        #[cfg(all(
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSImage",
            feature = "AppKit_NSPasteboard"
        ))]
        #[method(dragImage:at:offset:event:pasteboard:source:slideBack:)]
        pub unsafe fn dragImage_at_offset_event_pasteboard_source_slideBack(
            &self,
            image: &NSImage,
            base_location: NSPoint,
            initial_offset: NSSize,
            event: &NSEvent,
            pboard: &NSPasteboard,
            source_obj: &Object,
            slide_flag: bool,
        );

        #[cfg(feature = "Foundation_NSArray")]
        #[method(registerForDraggedTypes:)]
        pub unsafe fn registerForDraggedTypes(&self, new_types: &NSArray<NSPasteboardType>);

        #[method(unregisterDraggedTypes)]
        pub unsafe fn unregisterDraggedTypes(&self);
    }
);

extern_methods!(
    /// NSCarbonExtensions
    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl NSWindow {
        #[method_id(@__retain_semantics Init initWithWindowRef:)]
        pub unsafe fn initWithWindowRef(
            this: Option<Allocated<Self>>,
            window_ref: NonNull<c_void>,
        ) -> Option<Id<NSWindow>>;

        /**
          WindowRef
        */
        #[method(windowRef)]
        pub unsafe fn windowRef(&self) -> NonNull<c_void>;
    }
);

extern_protocol!(
    pub unsafe trait NSWindowDelegate: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(windowShouldClose:)]
        unsafe fn windowShouldClose(&self, sender: &NSWindow) -> bool;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method_id(@__retain_semantics Other windowWillReturnFieldEditor:toObject:)]
        unsafe fn windowWillReturnFieldEditor_toObject(
            &self,
            sender: &NSWindow,
            client: Option<&Object>,
        ) -> Option<Id<Object>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(windowWillResize:toSize:)]
        unsafe fn windowWillResize_toSize(&self, sender: &NSWindow, frame_size: NSSize) -> NSSize;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(windowWillUseStandardFrame:defaultFrame:)]
        unsafe fn windowWillUseStandardFrame_defaultFrame(
            &self,
            window: &NSWindow,
            new_frame: NSRect,
        ) -> NSRect;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(windowShouldZoom:toFrame:)]
        unsafe fn windowShouldZoom_toFrame(&self, window: &NSWindow, new_frame: NSRect) -> bool;

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSUndoManager"))]
        #[optional]
        #[method_id(@__retain_semantics Other windowWillReturnUndoManager:)]
        unsafe fn windowWillReturnUndoManager(
            &self,
            window: &NSWindow,
        ) -> Option<Id<NSUndoManager>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(window:willPositionSheet:usingRect:)]
        unsafe fn window_willPositionSheet_usingRect(
            &self,
            window: &NSWindow,
            sheet: &NSWindow,
            rect: NSRect,
        ) -> NSRect;

        #[cfg(all(feature = "AppKit_NSMenu", feature = "AppKit_NSWindow"))]
        #[optional]
        #[method(window:shouldPopUpDocumentPathMenu:)]
        unsafe fn window_shouldPopUpDocumentPathMenu(
            &self,
            window: &NSWindow,
            menu: &NSMenu,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSPasteboard",
            feature = "AppKit_NSWindow"
        ))]
        #[optional]
        #[method(window:shouldDragDocumentWithEvent:from:withPasteboard:)]
        unsafe fn window_shouldDragDocumentWithEvent_from_withPasteboard(
            &self,
            window: &NSWindow,
            event: &NSEvent,
            drag_image_location: NSPoint,
            pasteboard: &NSPasteboard,
        ) -> bool;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(window:willUseFullScreenContentSize:)]
        unsafe fn window_willUseFullScreenContentSize(
            &self,
            window: &NSWindow,
            proposed_size: NSSize,
        ) -> NSSize;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(window:willUseFullScreenPresentationOptions:)]
        unsafe fn window_willUseFullScreenPresentationOptions(
            &self,
            window: &NSWindow,
            proposed_options: NSApplicationPresentationOptions,
        ) -> NSApplicationPresentationOptions;

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSArray"))]
        #[optional]
        #[method_id(@__retain_semantics Other customWindowsToEnterFullScreenForWindow:)]
        unsafe fn customWindowsToEnterFullScreenForWindow(
            &self,
            window: &NSWindow,
        ) -> Option<Id<NSArray<NSWindow>>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(window:startCustomAnimationToEnterFullScreenWithDuration:)]
        unsafe fn window_startCustomAnimationToEnterFullScreenWithDuration(
            &self,
            window: &NSWindow,
            duration: NSTimeInterval,
        );

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(windowDidFailToEnterFullScreen:)]
        unsafe fn windowDidFailToEnterFullScreen(&self, window: &NSWindow);

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSArray"))]
        #[optional]
        #[method_id(@__retain_semantics Other customWindowsToExitFullScreenForWindow:)]
        unsafe fn customWindowsToExitFullScreenForWindow(
            &self,
            window: &NSWindow,
        ) -> Option<Id<NSArray<NSWindow>>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(window:startCustomAnimationToExitFullScreenWithDuration:)]
        unsafe fn window_startCustomAnimationToExitFullScreenWithDuration(
            &self,
            window: &NSWindow,
            duration: NSTimeInterval,
        );

        #[cfg(all(
            feature = "AppKit_NSScreen",
            feature = "AppKit_NSWindow",
            feature = "Foundation_NSArray"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other customWindowsToEnterFullScreenForWindow:onScreen:)]
        unsafe fn customWindowsToEnterFullScreenForWindow_onScreen(
            &self,
            window: &NSWindow,
            screen: &NSScreen,
        ) -> Option<Id<NSArray<NSWindow>>>;

        #[cfg(all(feature = "AppKit_NSScreen", feature = "AppKit_NSWindow"))]
        #[optional]
        #[method(window:startCustomAnimationToEnterFullScreenOnScreen:withDuration:)]
        unsafe fn window_startCustomAnimationToEnterFullScreenOnScreen_withDuration(
            &self,
            window: &NSWindow,
            screen: &NSScreen,
            duration: NSTimeInterval,
        );

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(windowDidFailToExitFullScreen:)]
        unsafe fn windowDidFailToExitFullScreen(&self, window: &NSWindow);

        #[cfg(feature = "AppKit_NSWindow")]
        #[optional]
        #[method(window:willResizeForVersionBrowserWithMaxPreferredSize:maxAllowedSize:)]
        unsafe fn window_willResizeForVersionBrowserWithMaxPreferredSize_maxAllowedSize(
            &self,
            window: &NSWindow,
            max_preferred_frame_size: NSSize,
            max_allowed_frame_size: NSSize,
        ) -> NSSize;

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSCoder"))]
        #[optional]
        #[method(window:willEncodeRestorableState:)]
        unsafe fn window_willEncodeRestorableState(&self, window: &NSWindow, state: &NSCoder);

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSCoder"))]
        #[optional]
        #[method(window:didDecodeRestorableState:)]
        unsafe fn window_didDecodeRestorableState(&self, window: &NSWindow, state: &NSCoder);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidResize:)]
        unsafe fn windowDidResize(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidExpose:)]
        unsafe fn windowDidExpose(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillMove:)]
        unsafe fn windowWillMove(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidMove:)]
        unsafe fn windowDidMove(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidBecomeKey:)]
        unsafe fn windowDidBecomeKey(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidResignKey:)]
        unsafe fn windowDidResignKey(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidBecomeMain:)]
        unsafe fn windowDidBecomeMain(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidResignMain:)]
        unsafe fn windowDidResignMain(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillClose:)]
        unsafe fn windowWillClose(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillMiniaturize:)]
        unsafe fn windowWillMiniaturize(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidMiniaturize:)]
        unsafe fn windowDidMiniaturize(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidDeminiaturize:)]
        unsafe fn windowDidDeminiaturize(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidUpdate:)]
        unsafe fn windowDidUpdate(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidChangeScreen:)]
        unsafe fn windowDidChangeScreen(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidChangeScreenProfile:)]
        unsafe fn windowDidChangeScreenProfile(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidChangeBackingProperties:)]
        unsafe fn windowDidChangeBackingProperties(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillBeginSheet:)]
        unsafe fn windowWillBeginSheet(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidEndSheet:)]
        unsafe fn windowDidEndSheet(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillStartLiveResize:)]
        unsafe fn windowWillStartLiveResize(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidEndLiveResize:)]
        unsafe fn windowDidEndLiveResize(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillEnterFullScreen:)]
        unsafe fn windowWillEnterFullScreen(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidEnterFullScreen:)]
        unsafe fn windowDidEnterFullScreen(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillExitFullScreen:)]
        unsafe fn windowWillExitFullScreen(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidExitFullScreen:)]
        unsafe fn windowDidExitFullScreen(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillEnterVersionBrowser:)]
        unsafe fn windowWillEnterVersionBrowser(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidEnterVersionBrowser:)]
        unsafe fn windowDidEnterVersionBrowser(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowWillExitVersionBrowser:)]
        unsafe fn windowWillExitVersionBrowser(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidExitVersionBrowser:)]
        unsafe fn windowDidExitVersionBrowser(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(windowDidChangeOcclusionState:)]
        unsafe fn windowDidChangeOcclusionState(&self, notification: &NSNotification);
    }

    unsafe impl ProtocolType for dyn NSWindowDelegate {}
);

extern_static!(NSWindowDidBecomeKeyNotification: &'static NSNotificationName);

extern_static!(NSWindowDidBecomeMainNotification: &'static NSNotificationName);

extern_static!(NSWindowDidChangeScreenNotification: &'static NSNotificationName);

extern_static!(NSWindowDidDeminiaturizeNotification: &'static NSNotificationName);

extern_static!(NSWindowDidExposeNotification: &'static NSNotificationName);

extern_static!(NSWindowDidMiniaturizeNotification: &'static NSNotificationName);

extern_static!(NSWindowDidMoveNotification: &'static NSNotificationName);

extern_static!(NSWindowDidResignKeyNotification: &'static NSNotificationName);

extern_static!(NSWindowDidResignMainNotification: &'static NSNotificationName);

extern_static!(NSWindowDidResizeNotification: &'static NSNotificationName);

extern_static!(NSWindowDidUpdateNotification: &'static NSNotificationName);

extern_static!(NSWindowWillCloseNotification: &'static NSNotificationName);

extern_static!(NSWindowWillMiniaturizeNotification: &'static NSNotificationName);

extern_static!(NSWindowWillMoveNotification: &'static NSNotificationName);

extern_static!(NSWindowWillBeginSheetNotification: &'static NSNotificationName);

extern_static!(NSWindowDidEndSheetNotification: &'static NSNotificationName);

extern_static!(NSWindowDidChangeBackingPropertiesNotification: &'static NSNotificationName);

extern_static!(NSBackingPropertyOldScaleFactorKey: &'static NSString);

extern_static!(NSBackingPropertyOldColorSpaceKey: &'static NSString);

extern_static!(NSWindowDidChangeScreenProfileNotification: &'static NSNotificationName);

extern_static!(NSWindowWillStartLiveResizeNotification: &'static NSNotificationName);

extern_static!(NSWindowDidEndLiveResizeNotification: &'static NSNotificationName);

extern_static!(NSWindowWillEnterFullScreenNotification: &'static NSNotificationName);

extern_static!(NSWindowDidEnterFullScreenNotification: &'static NSNotificationName);

extern_static!(NSWindowWillExitFullScreenNotification: &'static NSNotificationName);

extern_static!(NSWindowDidExitFullScreenNotification: &'static NSNotificationName);

extern_static!(NSWindowWillEnterVersionBrowserNotification: &'static NSNotificationName);

extern_static!(NSWindowDidEnterVersionBrowserNotification: &'static NSNotificationName);

extern_static!(NSWindowWillExitVersionBrowserNotification: &'static NSNotificationName);

extern_static!(NSWindowDidExitVersionBrowserNotification: &'static NSNotificationName);

extern_static!(NSWindowDidChangeOcclusionStateNotification: &'static NSNotificationName);

ns_enum!(
    #[underlying(NSUInteger)]
    #[deprecated]
    pub enum NSWindowBackingLocation {
        NSWindowBackingLocationDefault = 0,
        NSWindowBackingLocationVideoMemory = 1,
        NSWindowBackingLocationMainMemory = 2,
    }
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "AppKit_NSWindow")]
    unsafe impl NSWindow {
        #[deprecated = "This method shouldn’t be used as it doesn’t work in all drawing situations; instead, a subview should be used that implements the desired drawing behavior"]
        #[method(cacheImageInRect:)]
        pub unsafe fn cacheImageInRect(&self, rect: NSRect);

        #[deprecated = "This method shouldn’t be used as it doesn’t work in all drawing situations; instead, a subview should be used that implements the desired drawing behavior"]
        #[method(restoreCachedImage)]
        pub unsafe fn restoreCachedImage(&self);

        #[deprecated = "This method shouldn’t be used as it doesn’t work in all drawing situations; instead, a subview should be used that implements the desired drawing behavior"]
        #[method(discardCachedImage)]
        pub unsafe fn discardCachedImage(&self);

        #[cfg(feature = "AppKit_NSMenu")]
        #[deprecated = "This method does not do anything and should not be called."]
        #[method(menuChanged:)]
        pub unsafe fn menuChanged(menu: &NSMenu);

        #[deprecated = "This method is unused and should not be called."]
        #[method(gState)]
        pub unsafe fn gState(&self) -> NSInteger;

        #[deprecated = "Use -convertRectToScreen: or -convertPointToScreen: instead"]
        #[method(convertBaseToScreen:)]
        pub unsafe fn convertBaseToScreen(&self, point: NSPoint) -> NSPoint;

        #[deprecated = "Use -convertRectFromScreen or -convertPointFromScreen: instead"]
        #[method(convertScreenToBase:)]
        pub unsafe fn convertScreenToBase(&self, point: NSPoint) -> NSPoint;

        #[deprecated = "Use -convertRectToBacking: and -backingScaleFactor instead"]
        #[method(userSpaceScaleFactor)]
        pub unsafe fn userSpaceScaleFactor(&self) -> CGFloat;

        #[deprecated = "This method does not do anything and should not be called."]
        #[method(useOptimizedDrawing:)]
        pub unsafe fn useOptimizedDrawing(&self, flag: bool);

        #[deprecated = "This method does not do anything and should not be called."]
        #[method(canStoreColor)]
        pub unsafe fn canStoreColor(&self) -> bool;

        #[deprecated = "Use +[NSAnimationContext runAnimationGroup:completionHandler:] to perform atomic updates across runloop invocations."]
        #[method(disableFlushWindow)]
        pub unsafe fn disableFlushWindow(&self);

        #[deprecated = "Use +[NSAnimationContext runAnimationGroup:completionHandler:] to perform atomic updates across runloop invocations."]
        #[method(enableFlushWindow)]
        pub unsafe fn enableFlushWindow(&self);

        #[deprecated = "Use +[NSAnimationContext runAnimationGroup:completionHandler:] to perform atomic updates across runloop invocations."]
        #[method(isFlushWindowDisabled)]
        pub unsafe fn isFlushWindowDisabled(&self) -> bool;

        #[deprecated = "Allow AppKit's automatic deferred display mechanism to take care of flushing any graphics contexts as needed."]
        #[method(flushWindow)]
        pub unsafe fn flushWindow(&self);

        #[deprecated = "Allow AppKit's automatic deferred display mechanism to take care of flushing any graphics contexts as needed."]
        #[method(flushWindowIfNeeded)]
        pub unsafe fn flushWindowIfNeeded(&self);

        #[deprecated = "Use +[NSAnimationContext runAnimationGroup:completionHandler:] to temporarily prevent AppKit's automatic deferred display mechanism from drawing."]
        #[method(isAutodisplay)]
        pub unsafe fn isAutodisplay(&self) -> bool;

        #[deprecated = "Use +[NSAnimationContext runAnimationGroup:completionHandler:] to temporarily prevent AppKit's automatic deferred display mechanism from drawing."]
        #[method(setAutodisplay:)]
        pub unsafe fn setAutodisplay(&self, autodisplay: bool);

        #[cfg(feature = "AppKit_NSGraphicsContext")]
        /**
          Returns NSGraphicsContext used to render the receiver's content on the screen for the calling thread.
        */
        #[deprecated = "Add instances of NSView to display content in a window."]
        #[method_id(@__retain_semantics Other graphicsContext)]
        pub unsafe fn graphicsContext(&self) -> Option<Id<NSGraphicsContext>>;

        #[deprecated = "This property does not do anything and should not be used"]
        #[method(isOneShot)]
        pub unsafe fn isOneShot(&self) -> bool;

        #[deprecated = "This property does not do anything and should not be used"]
        #[method(setOneShot:)]
        pub unsafe fn setOneShot(&self, one_shot: bool);

        #[deprecated = "This property does not do anything and should not be used"]
        #[method(preferredBackingLocation)]
        pub unsafe fn preferredBackingLocation(&self) -> NSWindowBackingLocation;

        #[deprecated = "This property does not do anything and should not be used"]
        #[method(setPreferredBackingLocation:)]
        pub unsafe fn setPreferredBackingLocation(
            &self,
            preferred_backing_location: NSWindowBackingLocation,
        );

        #[deprecated = "This property does not do anything and should not be used"]
        #[method(backingLocation)]
        pub unsafe fn backingLocation(&self) -> NSWindowBackingLocation;

        /**
          showsResizeIndicator is soft-deprecated in 10.14. It is ignored on 10.7 and newer, and should not be used.
        */
        #[method(showsResizeIndicator)]
        pub unsafe fn showsResizeIndicator(&self) -> bool;

        /**
          showsResizeIndicator is soft-deprecated in 10.14. It is ignored on 10.7 and newer, and should not be used.
        */
        #[method(setShowsResizeIndicator:)]
        pub unsafe fn setShowsResizeIndicator(&self, shows_resize_indicator: bool);
    }
);

extern_static!(NSBorderlessWindowMask: NSWindowStyleMask = NSWindowStyleMaskBorderless);

extern_static!(NSTitledWindowMask: NSWindowStyleMask = NSWindowStyleMaskTitled);

extern_static!(NSClosableWindowMask: NSWindowStyleMask = NSWindowStyleMaskClosable);

extern_static!(NSMiniaturizableWindowMask: NSWindowStyleMask = NSWindowStyleMaskMiniaturizable);

extern_static!(NSResizableWindowMask: NSWindowStyleMask = NSWindowStyleMaskResizable);

extern_static!(
    NSTexturedBackgroundWindowMask: NSWindowStyleMask = NSWindowStyleMaskTexturedBackground
);

extern_static!(
    NSUnifiedTitleAndToolbarWindowMask: NSWindowStyleMask = NSWindowStyleMaskUnifiedTitleAndToolbar
);

extern_static!(NSFullScreenWindowMask: NSWindowStyleMask = NSWindowStyleMaskFullScreen);

extern_static!(
    NSFullSizeContentViewWindowMask: NSWindowStyleMask = NSWindowStyleMaskFullSizeContentView
);

extern_static!(NSUtilityWindowMask: NSWindowStyleMask = NSWindowStyleMaskUtilityWindow);

extern_static!(NSDocModalWindowMask: NSWindowStyleMask = NSWindowStyleMaskDocModalWindow);

extern_static!(NSNonactivatingPanelMask: NSWindowStyleMask = NSWindowStyleMaskNonactivatingPanel);

extern_static!(NSHUDWindowMask: NSWindowStyleMask = NSWindowStyleMaskHUDWindow);

extern_static!(NSUnscaledWindowMask: NSWindowStyleMask = 1 << 11);

extern_static!(NSWindowFullScreenButton: NSWindowButton = 7);
