//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

typed_extensible_enum!(
    pub type NSAppKitVersion = c_double;
);

extern_static!(NSAppKitVersionNumber: NSAppKitVersion);

extern_static!(NSAppKitVersionNumber10_0: NSAppKitVersion = 577);

extern_static!(NSAppKitVersionNumber10_1: NSAppKitVersion = 620);

extern_static!(NSAppKitVersionNumber10_2: NSAppKitVersion = 663);

extern_static!(NSAppKitVersionNumber10_2_3: NSAppKitVersion = 663.6);

extern_static!(NSAppKitVersionNumber10_3: NSAppKitVersion = 743);

extern_static!(NSAppKitVersionNumber10_3_2: NSAppKitVersion = 743.14);

extern_static!(NSAppKitVersionNumber10_3_3: NSAppKitVersion = 743.2);

extern_static!(NSAppKitVersionNumber10_3_5: NSAppKitVersion = 743.24);

extern_static!(NSAppKitVersionNumber10_3_7: NSAppKitVersion = 743.33);

extern_static!(NSAppKitVersionNumber10_3_9: NSAppKitVersion = 743.36);

extern_static!(NSAppKitVersionNumber10_4: NSAppKitVersion = 824);

extern_static!(NSAppKitVersionNumber10_4_1: NSAppKitVersion = 824.1);

extern_static!(NSAppKitVersionNumber10_4_3: NSAppKitVersion = 824.23);

extern_static!(NSAppKitVersionNumber10_4_4: NSAppKitVersion = 824.33);

extern_static!(NSAppKitVersionNumber10_4_7: NSAppKitVersion = 824.41);

extern_static!(NSAppKitVersionNumber10_5: NSAppKitVersion = 949);

extern_static!(NSAppKitVersionNumber10_5_2: NSAppKitVersion = 949.27);

extern_static!(NSAppKitVersionNumber10_5_3: NSAppKitVersion = 949.33);

extern_static!(NSAppKitVersionNumber10_6: NSAppKitVersion = 1038);

extern_static!(NSAppKitVersionNumber10_7: NSAppKitVersion = 1138);

extern_static!(NSAppKitVersionNumber10_7_2: NSAppKitVersion = 1138.23);

extern_static!(NSAppKitVersionNumber10_7_3: NSAppKitVersion = 1138.32);

extern_static!(NSAppKitVersionNumber10_7_4: NSAppKitVersion = 1138.47);

extern_static!(NSAppKitVersionNumber10_8: NSAppKitVersion = 1187);

extern_static!(NSAppKitVersionNumber10_9: NSAppKitVersion = 1265);

extern_static!(NSAppKitVersionNumber10_10: NSAppKitVersion = 1343);

extern_static!(NSAppKitVersionNumber10_10_2: NSAppKitVersion = 1344);

extern_static!(NSAppKitVersionNumber10_10_3: NSAppKitVersion = 1347);

extern_static!(NSAppKitVersionNumber10_10_4: NSAppKitVersion = 1348);

extern_static!(NSAppKitVersionNumber10_10_5: NSAppKitVersion = 1348);

extern_static!(NSAppKitVersionNumber10_10_Max: NSAppKitVersion = 1349);

extern_static!(NSAppKitVersionNumber10_11: NSAppKitVersion = 1404);

extern_static!(NSAppKitVersionNumber10_11_1: NSAppKitVersion = 1404.13);

extern_static!(NSAppKitVersionNumber10_11_2: NSAppKitVersion = 1404.34);

extern_static!(NSAppKitVersionNumber10_11_3: NSAppKitVersion = 1404.34);

extern_static!(NSAppKitVersionNumber10_12: NSAppKitVersion = 1504);

extern_static!(NSAppKitVersionNumber10_12_1: NSAppKitVersion = 1504.60);

extern_static!(NSAppKitVersionNumber10_12_2: NSAppKitVersion = 1504.76);

extern_static!(NSAppKitVersionNumber10_13: NSAppKitVersion = 1561);

extern_static!(NSAppKitVersionNumber10_13_1: NSAppKitVersion = 1561.1);

extern_static!(NSAppKitVersionNumber10_13_2: NSAppKitVersion = 1561.2);

extern_static!(NSAppKitVersionNumber10_13_4: NSAppKitVersion = 1561.4);

extern_static!(NSAppKitVersionNumber10_14: NSAppKitVersion = 1671);

extern_static!(NSAppKitVersionNumber10_14_1: NSAppKitVersion = 1671.1);

extern_static!(NSAppKitVersionNumber10_14_2: NSAppKitVersion = 1671.2);

extern_static!(NSAppKitVersionNumber10_14_3: NSAppKitVersion = 1671.3);

extern_static!(NSAppKitVersionNumber10_14_4: NSAppKitVersion = 1671.4);

extern_static!(NSAppKitVersionNumber10_14_5: NSAppKitVersion = 1671.5);

extern_static!(NSAppKitVersionNumber10_15: NSAppKitVersion = 1894);

extern_static!(NSAppKitVersionNumber10_15_1: NSAppKitVersion = 1894.1);

extern_static!(NSAppKitVersionNumber10_15_2: NSAppKitVersion = 1894.2);

extern_static!(NSAppKitVersionNumber10_15_3: NSAppKitVersion = 1894.3);

extern_static!(NSAppKitVersionNumber10_15_4: NSAppKitVersion = 1894.4);

extern_static!(NSAppKitVersionNumber10_15_5: NSAppKitVersion = 1894.5);

extern_static!(NSAppKitVersionNumber10_15_6: NSAppKitVersion = 1894.6);

extern_static!(NSAppKitVersionNumber11_0: NSAppKitVersion = 2022);

extern_static!(NSAppKitVersionNumber11_1: NSAppKitVersion = 2022.2);

extern_static!(NSAppKitVersionNumber11_2: NSAppKitVersion = 2022.3);

extern_static!(NSAppKitVersionNumber11_3: NSAppKitVersion = 2022.4);

extern_static!(NSAppKitVersionNumber11_4: NSAppKitVersion = 2022.5);

extern_static!(NSModalPanelRunLoopMode: &'static NSRunLoopMode);

extern_static!(NSEventTrackingRunLoopMode: &'static NSRunLoopMode);

typed_extensible_enum!(
    pub type NSModalResponse = NSInteger;
);

extern_static!(NSModalResponseStop: NSModalResponse = -1000);

extern_static!(NSModalResponseAbort: NSModalResponse = -1001);

extern_static!(NSModalResponseContinue: NSModalResponse = -1002);

extern_enum!(
    #[underlying(c_uint)]
    /**
      used with NSRunLoop's performSelector:target:argument:order:modes:
    */
    pub enum __anonymous__ {
        NSUpdateWindowsRunLoopOrdering = 500000,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSApplicationPresentationOptions {
        NSApplicationPresentationDefault = 0,
        NSApplicationPresentationAutoHideDock = 1 << 0,
        NSApplicationPresentationHideDock = 1 << 1,
        NSApplicationPresentationAutoHideMenuBar = 1 << 2,
        NSApplicationPresentationHideMenuBar = 1 << 3,
        NSApplicationPresentationDisableAppleMenu = 1 << 4,
        NSApplicationPresentationDisableProcessSwitching = 1 << 5,
        NSApplicationPresentationDisableForceQuit = 1 << 6,
        NSApplicationPresentationDisableSessionTermination = 1 << 7,
        NSApplicationPresentationDisableHideApplication = 1 << 8,
        NSApplicationPresentationDisableMenuBarTransparency = 1 << 9,
        NSApplicationPresentationFullScreen = 1 << 10,
        NSApplicationPresentationAutoHideToolbar = 1 << 11,
        NSApplicationPresentationDisableCursorLocationAssistance = 1 << 12,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSApplicationOcclusionState {
        NSApplicationOcclusionStateVisible = 1 << 1,
    }
);

ns_options!(
    #[underlying(NSInteger)]
    pub enum NSWindowListOptions {
        NSWindowListOrderedFrontToBack = 1 << 0,
    }
);

pub type NSModalSession = *mut c_void;

extern_static!(NSApp: Option<&'static NSApplication>);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSRequestUserAttentionType {
        NSCriticalRequest = 0,
        NSInformationalRequest = 10,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSApplicationDelegateReply {
        NSApplicationDelegateReplySuccess = 0,
        NSApplicationDelegateReplyCancel = 1,
        NSApplicationDelegateReplyFailure = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSApplication")]
    pub struct NSApplication;

    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl ClassType for NSApplication {
        #[inherits(NSObject)]
        type Super = NSResponder;
    }
);

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSAccessibility for NSApplication {}

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSAccessibilityElementProtocol for NSApplication {}

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSCoding for NSApplication {}

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSMenuItemValidation for NSApplication {}

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSObjectProtocol for NSApplication {}

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSUserInterfaceValidations for NSApplication {}

extern_methods!(
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[method_id(@__retain_semantics Other sharedApplication)]
        pub unsafe fn sharedApplication() -> Id<NSApplication>;

        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSApplicationDelegate>>>;

        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSApplicationDelegate>>,
        );

        #[method(hide:)]
        pub unsafe fn hide(&self, sender: Option<&Object>);

        #[method(unhide:)]
        pub unsafe fn unhide(&self, sender: Option<&Object>);

        #[method(unhideWithoutActivation)]
        pub unsafe fn unhideWithoutActivation(&self);

        #[cfg(feature = "AppKit_NSWindow")]
        #[method_id(@__retain_semantics Other windowWithWindowNumber:)]
        pub unsafe fn windowWithWindowNumber(&self, window_num: NSInteger) -> Option<Id<NSWindow>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[method_id(@__retain_semantics Other mainWindow)]
        pub unsafe fn mainWindow(&self) -> Option<Id<NSWindow>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[method_id(@__retain_semantics Other keyWindow)]
        pub unsafe fn keyWindow(&self) -> Option<Id<NSWindow>>;

        #[method(isActive)]
        pub unsafe fn isActive(&self) -> bool;

        #[method(isHidden)]
        pub unsafe fn isHidden(&self) -> bool;

        #[method(isRunning)]
        pub unsafe fn isRunning(&self) -> bool;

        #[method(deactivate)]
        pub unsafe fn deactivate(&self);

        #[method(activateIgnoringOtherApps:)]
        pub unsafe fn activateIgnoringOtherApps(&self, flag: bool);

        #[method(hideOtherApplications:)]
        pub unsafe fn hideOtherApplications(&self, sender: Option<&Object>);

        #[method(unhideAllApplications:)]
        pub unsafe fn unhideAllApplications(&self, sender: Option<&Object>);

        #[method(finishLaunching)]
        pub unsafe fn finishLaunching(&self);

        #[method(run)]
        pub unsafe fn run(&self);

        #[cfg(feature = "AppKit_NSWindow")]
        #[method(runModalForWindow:)]
        pub unsafe fn runModalForWindow(&self, window: &NSWindow) -> NSModalResponse;

        #[method(stop:)]
        pub unsafe fn stop(&self, sender: Option<&Object>);

        #[method(stopModal)]
        pub unsafe fn stopModal(&self);

        #[method(stopModalWithCode:)]
        pub unsafe fn stopModalWithCode(&self, return_code: NSModalResponse);

        #[method(abortModal)]
        pub unsafe fn abortModal(&self);

        #[cfg(feature = "AppKit_NSWindow")]
        #[method_id(@__retain_semantics Other modalWindow)]
        pub unsafe fn modalWindow(&self) -> Option<Id<NSWindow>>;

        #[cfg(feature = "AppKit_NSWindow")]
        #[method(beginModalSessionForWindow:)]
        pub unsafe fn beginModalSessionForWindow(&self, window: &NSWindow) -> NSModalSession;

        #[method(runModalSession:)]
        pub unsafe fn runModalSession(&self, session: NSModalSession) -> NSModalResponse;

        #[method(endModalSession:)]
        pub unsafe fn endModalSession(&self, session: NSModalSession);

        #[method(terminate:)]
        pub unsafe fn terminate(&self, sender: Option<&Object>);

        #[method(requestUserAttention:)]
        pub unsafe fn requestUserAttention(
            &self,
            request_type: NSRequestUserAttentionType,
        ) -> NSInteger;

        #[method(cancelUserAttentionRequest:)]
        pub unsafe fn cancelUserAttentionRequest(&self, request: NSInteger);

        #[cfg(feature = "AppKit_NSWindow")]
        #[method(enumerateWindowsWithOptions:usingBlock:)]
        pub unsafe fn enumerateWindowsWithOptions_usingBlock(
            &self,
            options: NSWindowListOptions,
            block: &Block<(NonNull<NSWindow>, NonNull<Bool>), ()>,
        );

        #[method(preventWindowOrdering)]
        pub unsafe fn preventWindowOrdering(&self);

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other windows)]
        pub unsafe fn windows(&self) -> Id<NSArray<NSWindow>>;

        #[method(setWindowsNeedUpdate:)]
        pub unsafe fn setWindowsNeedUpdate(&self, need_update: bool);

        #[method(updateWindows)]
        pub unsafe fn updateWindows(&self);

        #[cfg(feature = "AppKit_NSMenu")]
        #[method_id(@__retain_semantics Other mainMenu)]
        pub unsafe fn mainMenu(&self) -> Option<Id<NSMenu>>;

        #[cfg(feature = "AppKit_NSMenu")]
        #[method(setMainMenu:)]
        pub unsafe fn setMainMenu(&self, main_menu: Option<&NSMenu>);

        #[cfg(feature = "AppKit_NSMenu")]
        /**
          Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from -helpMenu).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.  NSApplication retains its Help menu and releases it when a different menu is set.
        */
        #[method_id(@__retain_semantics Other helpMenu)]
        pub unsafe fn helpMenu(&self) -> Option<Id<NSMenu>>;

        #[cfg(feature = "AppKit_NSMenu")]
        /**
          Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from -helpMenu).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.  NSApplication retains its Help menu and releases it when a different menu is set.
        */
        #[method(setHelpMenu:)]
        pub unsafe fn setHelpMenu(&self, help_menu: Option<&NSMenu>);

        #[cfg(feature = "AppKit_NSImage")]
        #[method_id(@__retain_semantics Other applicationIconImage)]
        pub unsafe fn applicationIconImage(&self) -> Option<Id<NSImage>>;

        #[cfg(feature = "AppKit_NSImage")]
        #[method(setApplicationIconImage:)]
        pub unsafe fn setApplicationIconImage(&self, application_icon_image: Option<&NSImage>);

        #[method(activationPolicy)]
        pub unsafe fn activationPolicy(&self) -> NSApplicationActivationPolicy;

        #[method(setActivationPolicy:)]
        pub unsafe fn setActivationPolicy(
            &self,
            activation_policy: NSApplicationActivationPolicy,
        ) -> bool;

        #[cfg(feature = "AppKit_NSDockTile")]
        #[method_id(@__retain_semantics Other dockTile)]
        pub unsafe fn dockTile(&self) -> Id<NSDockTile>;

        #[cfg(feature = "Foundation_NSException")]
        #[method(reportException:)]
        pub unsafe fn reportException(&self, exception: &NSException);

        #[method(detachDrawingThread:toTarget:withObject:)]
        pub unsafe fn detachDrawingThread_toTarget_withObject(
            selector: Sel,
            target: &Object,
            argument: Option<&Object>,
        );

        #[method(replyToApplicationShouldTerminate:)]
        pub unsafe fn replyToApplicationShouldTerminate(&self, should_terminate: bool);

        #[method(replyToOpenOrPrint:)]
        pub unsafe fn replyToOpenOrPrint(&self, reply: NSApplicationDelegateReply);

        #[method(orderFrontCharacterPalette:)]
        pub unsafe fn orderFrontCharacterPalette(&self, sender: Option<&Object>);

        /**
          Gets or sets the presentationOptions that should be in effect for the system when this application is the active application.  Only certain combinations of NSApplicationPresentationOptions flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for -setPresentationOptions:.  When given an invalid combination of option flags, -setPresentationOptions: raises an exception.
        */
        #[method(presentationOptions)]
        pub unsafe fn presentationOptions(&self) -> NSApplicationPresentationOptions;

        /**
          Gets or sets the presentationOptions that should be in effect for the system when this application is the active application.  Only certain combinations of NSApplicationPresentationOptions flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for -setPresentationOptions:.  When given an invalid combination of option flags, -setPresentationOptions: raises an exception.
        */
        #[method(setPresentationOptions:)]
        pub unsafe fn setPresentationOptions(
            &self,
            presentation_options: NSApplicationPresentationOptions,
        );

        /**
          Returns the set of application presentation options that are currently in effect for the system.  These are the presentation options that have been put into effect by the currently active application.
        */
        #[method(currentSystemPresentationOptions)]
        pub unsafe fn currentSystemPresentationOptions(&self) -> NSApplicationPresentationOptions;

        #[method(occlusionState)]
        pub unsafe fn occlusionState(&self) -> NSApplicationOcclusionState;

        #[method(isProtectedDataAvailable)]
        pub unsafe fn isProtectedDataAvailable(&self) -> bool;
    }
);

extern_methods!(
    /// NSAppearanceCustomization
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[cfg(feature = "AppKit_NSAppearance")]
        #[method_id(@__retain_semantics Other appearance)]
        pub unsafe fn appearance(&self) -> Option<Id<NSAppearance>>;

        #[cfg(feature = "AppKit_NSAppearance")]
        #[method(setAppearance:)]
        pub unsafe fn setAppearance(&self, appearance: Option<&NSAppearance>);

        #[cfg(feature = "AppKit_NSAppearance")]
        #[method_id(@__retain_semantics Other effectiveAppearance)]
        pub unsafe fn effectiveAppearance(&self) -> Id<NSAppearance>;
    }
);

#[cfg(feature = "AppKit_NSApplication")]
unsafe impl NSAppearanceCustomization for NSApplication {}

extern_methods!(
    /// NSEvent
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[cfg(feature = "AppKit_NSEvent")]
        #[method(sendEvent:)]
        pub unsafe fn sendEvent(&self, event: &NSEvent);

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(postEvent:atStart:)]
        pub unsafe fn postEvent_atStart(&self, event: &NSEvent, flag: bool);

        #[cfg(feature = "AppKit_NSEvent")]
        #[method_id(@__retain_semantics Other currentEvent)]
        pub unsafe fn currentEvent(&self) -> Option<Id<NSEvent>>;

        #[cfg(all(feature = "AppKit_NSEvent", feature = "Foundation_NSDate"))]
        #[method_id(@__retain_semantics Other nextEventMatchingMask:untilDate:inMode:dequeue:)]
        pub unsafe fn nextEventMatchingMask_untilDate_inMode_dequeue(
            &self,
            mask: NSEventMask,
            expiration: Option<&NSDate>,
            mode: &NSRunLoopMode,
            deq_flag: bool,
        ) -> Option<Id<NSEvent>>;

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(discardEventsMatchingMask:beforeEvent:)]
        pub unsafe fn discardEventsMatchingMask_beforeEvent(
            &self,
            mask: NSEventMask,
            last_event: Option<&NSEvent>,
        );
    }
);

extern_methods!(
    /// NSResponder
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[method(sendAction:to:from:)]
        pub unsafe fn sendAction_to_from(
            &self,
            action: Sel,
            target: Option<&Object>,
            sender: Option<&Object>,
        ) -> bool;

        #[method_id(@__retain_semantics Other targetForAction:)]
        pub unsafe fn targetForAction(&self, action: Sel) -> Option<Id<Object>>;

        #[method_id(@__retain_semantics Other targetForAction:to:from:)]
        pub unsafe fn targetForAction_to_from(
            &self,
            action: Sel,
            target: Option<&Object>,
            sender: Option<&Object>,
        ) -> Option<Id<Object>>;

        #[method(tryToPerform:with:)]
        pub unsafe fn tryToPerform_with(&self, action: Sel, object: Option<&Object>) -> bool;

        #[method_id(@__retain_semantics Other validRequestorForSendType:returnType:)]
        pub unsafe fn validRequestorForSendType_returnType(
            &self,
            send_type: Option<&NSPasteboardType>,
            return_type: Option<&NSPasteboardType>,
        ) -> Option<Id<Object>>;
    }
);

extern_methods!(
    /// NSWindowsMenu
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[cfg(feature = "AppKit_NSMenu")]
        #[method_id(@__retain_semantics Other windowsMenu)]
        pub unsafe fn windowsMenu(&self) -> Option<Id<NSMenu>>;

        #[cfg(feature = "AppKit_NSMenu")]
        #[method(setWindowsMenu:)]
        pub unsafe fn setWindowsMenu(&self, windows_menu: Option<&NSMenu>);

        #[method(arrangeInFront:)]
        pub unsafe fn arrangeInFront(&self, sender: Option<&Object>);

        #[cfg(feature = "AppKit_NSWindow")]
        #[method(removeWindowsItem:)]
        pub unsafe fn removeWindowsItem(&self, win: &NSWindow);

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSString"))]
        #[method(addWindowsItem:title:filename:)]
        pub unsafe fn addWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(all(feature = "AppKit_NSWindow", feature = "Foundation_NSString"))]
        #[method(changeWindowsItem:title:filename:)]
        pub unsafe fn changeWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "AppKit_NSWindow")]
        #[method(updateWindowsItem:)]
        pub unsafe fn updateWindowsItem(&self, win: &NSWindow);

        #[method(miniaturizeAll:)]
        pub unsafe fn miniaturizeAll(&self, sender: Option<&Object>);
    }
);

extern_methods!(
    /// NSFullKeyboardAccess
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        /**
          Use this method to get the status of Full Keyboard Access, as configured in the Keyboard preference pane. You may use this status to implement your own key loop or to implement in-control tabbing behavior similar to NSTableView. Because of the nature of the preference storage, you will not be notified of changes to the key if you attempt to observe it via key-value observing; however, calling this method is fairly inexpensive, so you should always call it when you need the underlying value instead of caching it.
        */
        #[method(isFullKeyboardAccessEnabled)]
        pub unsafe fn isFullKeyboardAccessEnabled(&self) -> bool;
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
      return values for -applicationShouldTerminate:
    */
    pub enum NSApplicationTerminateReply {
        NSTerminateCancel = 0,
        NSTerminateNow = 1,
        NSTerminateLater = 2,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
      return values for -application:printFiles:withSettings:showPrintPanels:.
    */
    pub enum NSApplicationPrintReply {
        NSPrintingCancelled = 0,
        NSPrintingSuccess = 1,
        NSPrintingFailure = 3,
        NSPrintingReplyLater = 2,
    }
);

extern_protocol!(
    pub unsafe trait NSApplicationDelegate: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationShouldTerminate:)]
        unsafe fn applicationShouldTerminate(
            &self,
            sender: &NSApplication,
        ) -> NSApplicationTerminateReply;

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSURL"
        ))]
        #[optional]
        #[method(application:openURLs:)]
        unsafe fn application_openURLs(&self, application: &NSApplication, urls: &NSArray<NSURL>);

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSString"))]
        #[optional]
        #[method(application:openFile:)]
        unsafe fn application_openFile(&self, sender: &NSApplication, filename: &NSString) -> bool;

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method(application:openFiles:)]
        unsafe fn application_openFiles(
            &self,
            sender: &NSApplication,
            filenames: &NSArray<NSString>,
        );

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSString"))]
        #[optional]
        #[method(application:openTempFile:)]
        unsafe fn application_openTempFile(
            &self,
            sender: &NSApplication,
            filename: &NSString,
        ) -> bool;

        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationShouldOpenUntitledFile:)]
        unsafe fn applicationShouldOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationOpenUntitledFile:)]
        unsafe fn applicationOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[optional]
        #[method(application:openFileWithoutUI:)]
        unsafe fn application_openFileWithoutUI(
            &self,
            sender: &Object,
            filename: &NSString,
        ) -> bool;

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSString"))]
        #[optional]
        #[method(application:printFile:)]
        unsafe fn application_printFile(&self, sender: &NSApplication, filename: &NSString)
            -> bool;

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method(application:printFiles:withSettings:showPrintPanels:)]
        unsafe fn application_printFiles_withSettings_showPrintPanels(
            &self,
            application: &NSApplication,
            file_names: &NSArray<NSString>,
            print_settings: &NSDictionary<NSPrintInfoAttributeKey, Object>,
            show_print_panels: bool,
        ) -> NSApplicationPrintReply;

        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationShouldTerminateAfterLastWindowClosed:)]
        unsafe fn applicationShouldTerminateAfterLastWindowClosed(
            &self,
            sender: &NSApplication,
        ) -> bool;

        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationShouldHandleReopen:hasVisibleWindows:)]
        unsafe fn applicationShouldHandleReopen_hasVisibleWindows(
            &self,
            sender: &NSApplication,
            flag: bool,
        ) -> bool;

        #[cfg(all(feature = "AppKit_NSApplication", feature = "AppKit_NSMenu"))]
        #[optional]
        #[method_id(@__retain_semantics Other applicationDockMenu:)]
        unsafe fn applicationDockMenu(&self, sender: &NSApplication) -> Option<Id<NSMenu>>;

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSError"))]
        #[optional]
        #[method_id(@__retain_semantics Other application:willPresentError:)]
        unsafe fn application_willPresentError(
            &self,
            application: &NSApplication,
            error: &NSError,
        ) -> Id<NSError>;

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSData"))]
        #[optional]
        #[method(application:didRegisterForRemoteNotificationsWithDeviceToken:)]
        unsafe fn application_didRegisterForRemoteNotificationsWithDeviceToken(
            &self,
            application: &NSApplication,
            device_token: &NSData,
        );

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSError"))]
        #[optional]
        #[method(application:didFailToRegisterForRemoteNotificationsWithError:)]
        unsafe fn application_didFailToRegisterForRemoteNotificationsWithError(
            &self,
            application: &NSApplication,
            error: &NSError,
        );

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method(application:didReceiveRemoteNotification:)]
        unsafe fn application_didReceiveRemoteNotification(
            &self,
            application: &NSApplication,
            user_info: &NSDictionary<NSString, Object>,
        );

        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationSupportsSecureRestorableState:)]
        unsafe fn applicationSupportsSecureRestorableState(&self, app: &NSApplication) -> bool;

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSCoder"))]
        #[optional]
        #[method(application:willEncodeRestorableState:)]
        unsafe fn application_willEncodeRestorableState(
            &self,
            app: &NSApplication,
            coder: &NSCoder,
        );

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSCoder"))]
        #[optional]
        #[method(application:didDecodeRestorableState:)]
        unsafe fn application_didDecodeRestorableState(&self, app: &NSApplication, coder: &NSCoder);

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSString"))]
        #[optional]
        #[method(application:willContinueUserActivityWithType:)]
        unsafe fn application_willContinueUserActivityWithType(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSUserActivity"
        ))]
        #[optional]
        #[method(application:continueUserActivity:restorationHandler:)]
        unsafe fn application_continueUserActivity_restorationHandler(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
            restoration_handler: &Block<
                (NonNull<NSArray<ProtocolObject<dyn NSUserActivityRestoring>>>,),
                (),
            >,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method(application:didFailToContinueUserActivityWithType:error:)]
        unsafe fn application_didFailToContinueUserActivityWithType_error(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
            error: &NSError,
        );

        #[cfg(all(
            feature = "AppKit_NSApplication",
            feature = "Foundation_NSUserActivity"
        ))]
        #[optional]
        #[method(application:didUpdateUserActivity:)]
        unsafe fn application_didUpdateUserActivity(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
        );

        #[cfg(all(feature = "AppKit_NSApplication", feature = "Foundation_NSString"))]
        #[optional]
        #[method(application:delegateHandlesKey:)]
        unsafe fn application_delegateHandlesKey(
            &self,
            sender: &NSApplication,
            key: &NSString,
        ) -> bool;

        #[cfg(feature = "AppKit_NSApplication")]
        #[optional]
        #[method(applicationShouldAutomaticallyLocalizeKeyEquivalents:)]
        unsafe fn applicationShouldAutomaticallyLocalizeKeyEquivalents(
            &self,
            application: &NSApplication,
        ) -> bool;

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillFinishLaunching:)]
        unsafe fn applicationWillFinishLaunching(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidFinishLaunching:)]
        unsafe fn applicationDidFinishLaunching(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillHide:)]
        unsafe fn applicationWillHide(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidHide:)]
        unsafe fn applicationDidHide(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillUnhide:)]
        unsafe fn applicationWillUnhide(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidUnhide:)]
        unsafe fn applicationDidUnhide(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillBecomeActive:)]
        unsafe fn applicationWillBecomeActive(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidBecomeActive:)]
        unsafe fn applicationDidBecomeActive(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillResignActive:)]
        unsafe fn applicationWillResignActive(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidResignActive:)]
        unsafe fn applicationDidResignActive(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillUpdate:)]
        unsafe fn applicationWillUpdate(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidUpdate:)]
        unsafe fn applicationDidUpdate(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationWillTerminate:)]
        unsafe fn applicationWillTerminate(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidChangeScreenParameters:)]
        unsafe fn applicationDidChangeScreenParameters(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationDidChangeOcclusionState:)]
        unsafe fn applicationDidChangeOcclusionState(&self, notification: &NSNotification);

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationProtectedDataWillBecomeUnavailable:)]
        unsafe fn applicationProtectedDataWillBecomeUnavailable(
            &self,
            notification: &NSNotification,
        );

        #[cfg(feature = "Foundation_NSNotification")]
        #[optional]
        #[method(applicationProtectedDataDidBecomeAvailable:)]
        unsafe fn applicationProtectedDataDidBecomeAvailable(&self, notification: &NSNotification);
    }

    unsafe impl ProtocolType for dyn NSApplicationDelegate {}
);

extern_methods!(
    /// NSServicesMenu
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[cfg(feature = "AppKit_NSMenu")]
        #[method_id(@__retain_semantics Other servicesMenu)]
        pub unsafe fn servicesMenu(&self) -> Option<Id<NSMenu>>;

        #[cfg(feature = "AppKit_NSMenu")]
        #[method(setServicesMenu:)]
        pub unsafe fn setServicesMenu(&self, services_menu: Option<&NSMenu>);

        #[cfg(feature = "Foundation_NSArray")]
        #[method(registerServicesMenuSendTypes:returnTypes:)]
        pub unsafe fn registerServicesMenuSendTypes_returnTypes(
            &self,
            send_types: &NSArray<NSPasteboardType>,
            return_types: &NSArray<NSPasteboardType>,
        );
    }
);

extern_protocol!(
    pub unsafe trait NSServicesMenuRequestor: NSObjectProtocol {
        #[cfg(all(feature = "AppKit_NSPasteboard", feature = "Foundation_NSArray"))]
        #[optional]
        #[method(writeSelectionToPasteboard:types:)]
        unsafe fn writeSelectionToPasteboard_types(
            &self,
            pboard: &NSPasteboard,
            types: &NSArray<NSPasteboardType>,
        ) -> bool;

        #[cfg(feature = "AppKit_NSPasteboard")]
        #[optional]
        #[method(readSelectionFromPasteboard:)]
        unsafe fn readSelectionFromPasteboard(&self, pboard: &NSPasteboard) -> bool;
    }

    unsafe impl ProtocolType for dyn NSServicesMenuRequestor {}
);

extern_methods!(
    /// NSServicesHandling
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[method_id(@__retain_semantics Other servicesProvider)]
        pub unsafe fn servicesProvider(&self) -> Option<Id<Object>>;

        #[method(setServicesProvider:)]
        pub unsafe fn setServicesProvider(&self, services_provider: Option<&Object>);
    }
);

typed_enum!(
    pub type NSAboutPanelOptionKey = NSString;
);

extern_static!(NSAboutPanelOptionCredits: &'static NSAboutPanelOptionKey);

extern_static!(NSAboutPanelOptionApplicationName: &'static NSAboutPanelOptionKey);

extern_static!(NSAboutPanelOptionApplicationIcon: &'static NSAboutPanelOptionKey);

extern_static!(NSAboutPanelOptionVersion: &'static NSAboutPanelOptionKey);

extern_static!(NSAboutPanelOptionApplicationVersion: &'static NSAboutPanelOptionKey);

extern_methods!(
    /// NSStandardAboutPanel
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[method(orderFrontStandardAboutPanel:)]
        pub unsafe fn orderFrontStandardAboutPanel(&self, sender: Option<&Object>);

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method(orderFrontStandardAboutPanelWithOptions:)]
        pub unsafe fn orderFrontStandardAboutPanelWithOptions(
            &self,
            options_dictionary: &NSDictionary<NSAboutPanelOptionKey, Object>,
        );
    }
);

extern_methods!(
    /**
      Bi-directional User Interface
    */
    /// NSApplicationLayoutDirection
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        /**
          Returns the application-wide user interface layout direction.
        */
        #[method(userInterfaceLayoutDirection)]
        pub unsafe fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;
    }
);

extern_methods!(
    /// NSRestorableUserInterface
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[method(disableRelaunchOnLogin)]
        pub unsafe fn disableRelaunchOnLogin(&self);

        #[method(enableRelaunchOnLogin)]
        pub unsafe fn enableRelaunchOnLogin(&self);
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      Soft deprecated. Please use NSApplication's registerForRemoteNotifications along with requestAuthorizationWithOptions: from the UserNotifications.framework to specify allowable notification types.
    */
    pub enum NSRemoteNotificationType {
        NSRemoteNotificationTypeNone = 0,
        NSRemoteNotificationTypeBadge = 1 << 0,
        NSRemoteNotificationTypeSound = 1 << 1,
        NSRemoteNotificationTypeAlert = 1 << 2,
    }
);

extern_methods!(
    /// NSRemoteNotifications
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[method(registerForRemoteNotifications)]
        pub unsafe fn registerForRemoteNotifications(&self);

        #[method(unregisterForRemoteNotifications)]
        pub unsafe fn unregisterForRemoteNotifications(&self);

        /**
          Returns YES if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn't relate to connectivity.
        */
        #[method(isRegisteredForRemoteNotifications)]
        pub unsafe fn isRegisteredForRemoteNotifications(&self) -> bool;

        #[method(registerForRemoteNotificationTypes:)]
        pub unsafe fn registerForRemoteNotificationTypes(&self, types: NSRemoteNotificationType);

        #[method(enabledRemoteNotificationTypes)]
        pub unsafe fn enabledRemoteNotificationTypes(&self) -> NSRemoteNotificationType;
    }
);

extern_fn!(
    pub unsafe fn NSApplicationMain(argc: c_int, argv: NonNull<NonNull<c_char>>) -> c_int;
);

extern_fn!(
    pub unsafe fn NSApplicationLoad() -> Bool;
);

extern_fn!(
    #[cfg(feature = "Foundation_NSString")]
    pub unsafe fn NSShowsServicesMenuItem(item_name: &NSString) -> Bool;
);

extern_fn!(
    #[cfg(feature = "Foundation_NSString")]
    pub unsafe fn NSSetShowsServicesMenuItem(item_name: &NSString, enabled: Bool) -> NSInteger;
);

extern_fn!(
    pub unsafe fn NSUpdateDynamicServices();
);

extern_fn!(
    #[cfg(all(feature = "AppKit_NSPasteboard", feature = "Foundation_NSString"))]
    pub unsafe fn NSPerformService(item_name: &NSString, pboard: Option<&NSPasteboard>) -> Bool;
);

pub type NSServiceProviderName = NSString;

extern_fn!(
    pub unsafe fn NSRegisterServicesProvider(
        provider: Option<&Object>,
        name: &NSServiceProviderName,
    );
);

extern_fn!(
    pub unsafe fn NSUnregisterServicesProvider(name: &NSServiceProviderName);
);

extern_static!(NSApplicationDidBecomeActiveNotification: &'static NSNotificationName);

extern_static!(NSApplicationDidHideNotification: &'static NSNotificationName);

extern_static!(NSApplicationDidFinishLaunchingNotification: &'static NSNotificationName);

extern_static!(NSApplicationDidResignActiveNotification: &'static NSNotificationName);

extern_static!(NSApplicationDidUnhideNotification: &'static NSNotificationName);

extern_static!(NSApplicationDidUpdateNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillBecomeActiveNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillHideNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillFinishLaunchingNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillResignActiveNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillUnhideNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillUpdateNotification: &'static NSNotificationName);

extern_static!(NSApplicationWillTerminateNotification: &'static NSNotificationName);

extern_static!(NSApplicationDidChangeScreenParametersNotification: &'static NSNotificationName);

extern_static!(
    NSApplicationProtectedDataWillBecomeUnavailableNotification: &'static NSNotificationName
);

extern_static!(
    NSApplicationProtectedDataDidBecomeAvailableNotification: &'static NSNotificationName
);

extern_static!(NSApplicationLaunchIsDefaultLaunchKey: &'static NSString);

extern_static!(NSApplicationLaunchUserNotificationKey: &'static NSString);

extern_static!(NSApplicationLaunchRemoteNotificationKey: &'static NSString);

extern_static!(NSApplicationDidChangeOcclusionStateNotification: &'static NSNotificationName);

extern_enum!(
    #[underlying(c_int)]
    pub enum __anonymous__ {
        #[deprecated = "Use NSModalResponseStop instead"]
        NSRunStoppedResponse = -1000,
        #[deprecated = "Use NSModalResponseAbort instead"]
        NSRunAbortedResponse = -1001,
        #[deprecated = "Use NSModalResponseContinue instead"]
        NSRunContinuesResponse = -1002,
    }
);

extern_methods!(
    /**
      Deprecated Methods
    */
    /// NSDeprecated
    #[cfg(feature = "AppKit_NSApplication")]
    unsafe impl NSApplication {
        #[cfg(feature = "AppKit_NSWindow")]
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(runModalForWindow:relativeToWindow:)]
        pub unsafe fn runModalForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSInteger;

        #[cfg(feature = "AppKit_NSWindow")]
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(beginModalSessionForWindow:relativeToWindow:)]
        pub unsafe fn beginModalSessionForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSModalSession;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[deprecated]
        #[method(application:printFiles:)]
        pub unsafe fn application_printFiles(
            &self,
            sender: Option<&NSApplication>,
            filenames: Option<&NSArray<NSString>>,
        );

        #[cfg(feature = "AppKit_NSWindow")]
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[method(beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:)]
        pub unsafe fn beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(
            &self,
            sheet: &NSWindow,
            doc_window: &NSWindow,
            modal_delegate: Option<&Object>,
            did_end_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "AppKit_NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:] instead"]
        #[method(endSheet:)]
        pub unsafe fn endSheet(&self, sheet: &NSWindow);

        #[cfg(feature = "AppKit_NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:returnCode:] instead"]
        #[method(endSheet:returnCode:)]
        pub unsafe fn endSheet_returnCode(&self, sheet: &NSWindow, return_code: NSInteger);

        #[cfg(feature = "AppKit_NSWindow")]
        #[deprecated = "Use -enumerateWindowsWithOptions:usingBlock: instead"]
        #[method_id(@__retain_semantics Other makeWindowsPerform:inOrder:)]
        pub unsafe fn makeWindowsPerform_inOrder(
            &self,
            selector: Sel,
            flag: bool,
        ) -> Option<Id<NSWindow>>;

        #[cfg(feature = "AppKit_NSGraphicsContext")]
        /**
          This method is deprecated as of macOS 10.12. Beginning in OS X 10.11 it would always return nil. Prior to this it would return an undefined graphics context that was not generally suitable for drawing.
        */
        #[deprecated = "This method always returns nil. If you need access to the current drawing context, use [NSGraphicsContext currentContext] inside of a draw operation."]
        #[method_id(@__retain_semantics Other context)]
        pub unsafe fn context(&self) -> Option<Id<NSGraphicsContext>>;
    }
);
