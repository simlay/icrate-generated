//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSRulerOrientation {
        NSHorizontalRuler = 0,
        NSVerticalRuler = 1,
    }
);

typed_extensible_enum!(
    pub type NSRulerViewUnitName = NSString;
);

extern_static!(NSRulerViewUnitInches: &'static NSRulerViewUnitName);

extern_static!(NSRulerViewUnitCentimeters: &'static NSRulerViewUnitName);

extern_static!(NSRulerViewUnitPoints: &'static NSRulerViewUnitName);

extern_static!(NSRulerViewUnitPicas: &'static NSRulerViewUnitName);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSRulerView")]
    pub struct NSRulerView;

    #[cfg(feature = "AppKit_NSRulerView")]
    unsafe impl ClassType for NSRulerView {
        #[inherits(NSResponder, NSObject)]
        type Super = NSView;
    }
);

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSAccessibility for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSAccessibilityElementProtocol for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSAnimatablePropertyContainer for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSAppearanceCustomization for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSCoding for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSDraggingDestination for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSObjectProtocol for NSRulerView {}

#[cfg(feature = "AppKit_NSRulerView")]
unsafe impl NSUserInterfaceItemIdentification for NSRulerView {}

extern_methods!(
    #[cfg(feature = "AppKit_NSRulerView")]
    unsafe impl NSRulerView {
        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSNumber",
            feature = "Foundation_NSString"
        ))]
        #[method(registerUnitWithName:abbreviation:unitToPointsConversionFactor:stepUpCycle:stepDownCycle:)]
        pub unsafe fn registerUnitWithName_abbreviation_unitToPointsConversionFactor_stepUpCycle_stepDownCycle(
            unit_name: &NSRulerViewUnitName,
            abbreviation: &NSString,
            conversion_factor: CGFloat,
            step_up_cycle: &NSArray<NSNumber>,
            step_down_cycle: &NSArray<NSNumber>,
        );

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(this: Option<Allocated<Self>>, coder: &NSCoder) -> Id<Self>;

        #[cfg(feature = "AppKit_NSScrollView")]
        #[method_id(@__retain_semantics Init initWithScrollView:orientation:)]
        pub unsafe fn initWithScrollView_orientation(
            this: Option<Allocated<Self>>,
            scroll_view: Option<&NSScrollView>,
            orientation: NSRulerOrientation,
        ) -> Id<Self>;

        #[cfg(feature = "AppKit_NSScrollView")]
        /**
          Basic setup
        */
        #[method_id(@__retain_semantics Other scrollView)]
        pub unsafe fn scrollView(&self) -> Option<Id<NSScrollView>>;

        #[cfg(feature = "AppKit_NSScrollView")]
        /**
          Basic setup
        */
        #[method(setScrollView:)]
        pub unsafe fn setScrollView(&self, scroll_view: Option<&NSScrollView>);

        /**
          A ruler uses its scrollView to finds its document view to see whether it should be flipped.  The set method is generally called only by the scroll view itself.  You should not have to set this.
        */
        #[method(orientation)]
        pub unsafe fn orientation(&self) -> NSRulerOrientation;

        /**
          A ruler uses its scrollView to finds its document view to see whether it should be flipped.  The set method is generally called only by the scroll view itself.  You should not have to set this.
        */
        #[method(setOrientation:)]
        pub unsafe fn setOrientation(&self, orientation: NSRulerOrientation);

        /**
          Ruler geometry
        */
        #[method(baselineLocation)]
        pub unsafe fn baselineLocation(&self) -> CGFloat;

        /**
          Returns the location of the baseline.  The location is a y position for horizontal rulers and an x position for vertical ones.  The value is based on the sizes of the various areas of the ruler, some of which can be set below.
        */
        #[method(requiredThickness)]
        pub unsafe fn requiredThickness(&self) -> CGFloat;

        /**
          The required height for a horizontal ruler or the required width for a vertical ruler.  Used by the scrollview when tiling.  The value is based on the sizes of the various areas of the ruler, some of which can be set below.
        */
        #[method(ruleThickness)]
        pub unsafe fn ruleThickness(&self) -> CGFloat;

        /**
          The required height for a horizontal ruler or the required width for a vertical ruler.  Used by the scrollview when tiling.  The value is based on the sizes of the various areas of the ruler, some of which can be set below.
        */
        #[method(setRuleThickness:)]
        pub unsafe fn setRuleThickness(&self, rule_thickness: CGFloat);

        /**
          The rule size is the height of the area used to draw the ruler hash marks in a horizontal ruler or the width of that area in a vertical ruler.  This value will be interpretted in the coordinate system of the ruler's superview (like the ruler's frame).
        */
        #[method(reservedThicknessForMarkers)]
        pub unsafe fn reservedThicknessForMarkers(&self) -> CGFloat;

        /**
          The rule size is the height of the area used to draw the ruler hash marks in a horizontal ruler or the width of that area in a vertical ruler.  This value will be interpretted in the coordinate system of the ruler's superview (like the ruler's frame).
        */
        #[method(setReservedThicknessForMarkers:)]
        pub unsafe fn setReservedThicknessForMarkers(
            &self,
            reserved_thickness_for_markers: CGFloat,
        );

        /**
          This indicates to the ruler how much room it should leave for objects which sit above or to the left of the rule (such as tab stops, margins, etc...).  Default is 15.0.  If you expect that no view in your document view will ever put objects on the ruler, you can set this to 0.0.  If objects are ever set on the ruler, and not enough space was reserved for them, the ruler grows itself and retiles the scroll view.
        */
        #[method(reservedThicknessForAccessoryView)]
        pub unsafe fn reservedThicknessForAccessoryView(&self) -> CGFloat;

        /**
          This indicates to the ruler how much room it should leave for objects which sit above or to the left of the rule (such as tab stops, margins, etc...).  Default is 15.0.  If you expect that no view in your document view will ever put objects on the ruler, you can set this to 0.0.  If objects are ever set on the ruler, and not enough space was reserved for them, the ruler grows itself and retiles the scroll view.
        */
        #[method(setReservedThicknessForAccessoryView:)]
        pub unsafe fn setReservedThicknessForAccessoryView(
            &self,
            reserved_thickness_for_accessory_view: CGFloat,
        );

        /**
          Rule configuration
        */
        #[method_id(@__retain_semantics Other measurementUnits)]
        pub unsafe fn measurementUnits(&self) -> Id<NSRulerViewUnitName>;

        /**
          Rule configuration
        */
        #[method(setMeasurementUnits:)]
        pub unsafe fn setMeasurementUnits(&self, measurement_units: &NSRulerViewUnitName);

        /**
          The units of the ruler start out with the user's preferred measurement.  They can be changed if desired.  The units set must be registered with the ruler factory.  By default Inches, Centimeters, Picas, and Points are supported.
        */
        #[method(originOffset)]
        pub unsafe fn originOffset(&self) -> CGFloat;

        /**
          The units of the ruler start out with the user's preferred measurement.  They can be changed if desired.  The units set must be registered with the ruler factory.  By default Inches, Centimeters, Picas, and Points are supported.
        */
        #[method(setOriginOffset:)]
        pub unsafe fn setOriginOffset(&self, origin_offset: CGFloat);

        /**
          Client view setup
        */
        #[method_id(@__retain_semantics Other clientView)]
        pub unsafe fn clientView(&self) -> Option<Id<NSView>>;

        /**
          Client view setup
        */
        #[method(setClientView:)]
        pub unsafe fn setClientView(&self, client_view: Option<&NSView>);

        #[cfg(feature = "AppKit_NSRulerMarker")]
        #[method(addMarker:)]
        pub unsafe fn addMarker(&self, marker: &NSRulerMarker);

        #[cfg(feature = "AppKit_NSRulerMarker")]
        #[method(removeMarker:)]
        pub unsafe fn removeMarker(&self, marker: &NSRulerMarker);

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other markers)]
        pub unsafe fn markers(&self) -> Option<Id<NSArray<NSRulerMarker>>>;

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "Foundation_NSArray"))]
        #[method(setMarkers:)]
        pub unsafe fn setMarkers(&self, markers: Option<&NSArray<NSRulerMarker>>);

        #[cfg(all(feature = "AppKit_NSEvent", feature = "AppKit_NSRulerMarker"))]
        #[method(trackMarker:withMouseEvent:)]
        pub unsafe fn trackMarker_withMouseEvent(
            &self,
            marker: &NSRulerMarker,
            event: &NSEvent,
        ) -> bool;

        /**
          Given a ruler object and a mouse event (either MouseDown or MouseDragged) this will take over the tracking of the mouse until MouseUp.  While tracking it will snap to the baseline of the ruler when it gets within a certain distance.  At that point it becomes stuck to the baseline (this may happen immediately) and won't come off below (or to the right of) the ruler.  It may still be dragged off the baseline upward (or leftward) if its removable.  It is strongly recommended that any ruler object that acan be added to the ruler should be removable as well and it must be movable.  When the mouse goes up, if the object is currently stuck to the baseline it is added to the ruler (and the client object is notified), if its not stuck on the baseline, it is not added.
        */
        #[method_id(@__retain_semantics Other accessoryView)]
        pub unsafe fn accessoryView(&self) -> Option<Id<NSView>>;

        /**
          Given a ruler object and a mouse event (either MouseDown or MouseDragged) this will take over the tracking of the mouse until MouseUp.  While tracking it will snap to the baseline of the ruler when it gets within a certain distance.  At that point it becomes stuck to the baseline (this may happen immediately) and won't come off below (or to the right of) the ruler.  It may still be dragged off the baseline upward (or leftward) if its removable.  It is strongly recommended that any ruler object that acan be added to the ruler should be removable as well and it must be movable.  When the mouse goes up, if the object is currently stuck to the baseline it is added to the ruler (and the client object is notified), if its not stuck on the baseline, it is not added.
        */
        #[method(setAccessoryView:)]
        pub unsafe fn setAccessoryView(&self, accessory_view: Option<&NSView>);

        #[method(moveRulerlineFromLocation:toLocation:)]
        pub unsafe fn moveRulerlineFromLocation_toLocation(
            &self,
            old_location: CGFloat,
            new_location: CGFloat,
        );

        #[method(invalidateHashMarks)]
        pub unsafe fn invalidateHashMarks(&self);

        #[method(drawHashMarksAndLabelsInRect:)]
        pub unsafe fn drawHashMarksAndLabelsInRect(&self, rect: NSRect);

        #[method(drawMarkersInRect:)]
        pub unsafe fn drawMarkersInRect(&self, rect: NSRect);

        /**
          Key overrides
        */
        #[method(isFlipped)]
        pub unsafe fn isFlipped(&self) -> bool;
    }
);

extern_methods!(
    /**
      This informal protocol defines the communication between a ruler and its client view during mouse tracking.
    */
    /// NSRulerMarkerClientViewDelegation
    #[cfg(feature = "AppKit_NSView")]
    unsafe impl NSView {
        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:shouldMoveMarker:)]
        pub unsafe fn rulerView_shouldMoveMarker(
            &self,
            ruler: &NSRulerView,
            marker: &NSRulerMarker,
        ) -> bool;

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:willMoveMarker:toLocation:)]
        pub unsafe fn rulerView_willMoveMarker_toLocation(
            &self,
            ruler: &NSRulerView,
            marker: &NSRulerMarker,
            location: CGFloat,
        ) -> CGFloat;

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:didMoveMarker:)]
        pub unsafe fn rulerView_didMoveMarker(&self, ruler: &NSRulerView, marker: &NSRulerMarker);

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:shouldRemoveMarker:)]
        pub unsafe fn rulerView_shouldRemoveMarker(
            &self,
            ruler: &NSRulerView,
            marker: &NSRulerMarker,
        ) -> bool;

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:didRemoveMarker:)]
        pub unsafe fn rulerView_didRemoveMarker(&self, ruler: &NSRulerView, marker: &NSRulerMarker);

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:shouldAddMarker:)]
        pub unsafe fn rulerView_shouldAddMarker(
            &self,
            ruler: &NSRulerView,
            marker: &NSRulerMarker,
        ) -> bool;

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:willAddMarker:atLocation:)]
        pub unsafe fn rulerView_willAddMarker_atLocation(
            &self,
            ruler: &NSRulerView,
            marker: &NSRulerMarker,
            location: CGFloat,
        ) -> CGFloat;

        #[cfg(all(feature = "AppKit_NSRulerMarker", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:didAddMarker:)]
        pub unsafe fn rulerView_didAddMarker(&self, ruler: &NSRulerView, marker: &NSRulerMarker);

        #[cfg(all(feature = "AppKit_NSEvent", feature = "AppKit_NSRulerView"))]
        #[method(rulerView:handleMouseDown:)]
        pub unsafe fn rulerView_handleMouseDown(&self, ruler: &NSRulerView, event: &NSEvent);

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method(rulerView:willSetClientView:)]
        pub unsafe fn rulerView_willSetClientView(&self, ruler: &NSRulerView, new_client: &NSView);

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method(rulerView:locationForPoint:)]
        pub unsafe fn rulerView_locationForPoint(
            &self,
            ruler: &NSRulerView,
            point: NSPoint,
        ) -> CGFloat;

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method(rulerView:pointForLocation:)]
        pub unsafe fn rulerView_pointForLocation(
            &self,
            ruler: &NSRulerView,
            point: CGFloat,
        ) -> NSPoint;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSView`
    #[cfg(feature = "AppKit_NSRulerView")]
    unsafe impl NSRulerView {
        #[method_id(@__retain_semantics Init initWithFrame:)]
        pub unsafe fn initWithFrame(this: Option<Allocated<Self>>, frame_rect: NSRect) -> Id<Self>;
    }
);
