//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSCollectionViewDropOperation {
        NSCollectionViewDropOn = 0,
        NSCollectionViewDropBefore = 1,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSCollectionViewItemHighlightState {
        NSCollectionViewItemHighlightNone = 0,
        NSCollectionViewItemHighlightForSelection = 1,
        NSCollectionViewItemHighlightForDeselection = 2,
        NSCollectionViewItemHighlightAsDropTarget = 3,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      Used with NSCollectionView's -selectItemsAtIndexPaths:scrollPosition: and -scrollToItemsAtIndexPaths:scrollPosition: to specify how the bounding box of the specified items should be positioned within the CollectionView's visibleRect.  NSCollectionView will try to satisfy this request as closely as feasible, while staying within the enclosing ClipView's scrollable range.
    */
    pub enum NSCollectionViewScrollPosition {
        NSCollectionViewScrollPositionNone = 0,
        NSCollectionViewScrollPositionTop = 1 << 0,
        NSCollectionViewScrollPositionCenteredVertically = 1 << 1,
        NSCollectionViewScrollPositionBottom = 1 << 2,
        NSCollectionViewScrollPositionNearestHorizontalEdge = 1 << 9,
        NSCollectionViewScrollPositionLeft = 1 << 3,
        NSCollectionViewScrollPositionCenteredHorizontally = 1 << 4,
        NSCollectionViewScrollPositionRight = 1 << 5,
        NSCollectionViewScrollPositionLeadingEdge = 1 << 6,
        NSCollectionViewScrollPositionTrailingEdge = 1 << 7,
        NSCollectionViewScrollPositionNearestVerticalEdge = 1 << 8,
    }
);

pub type NSCollectionViewSupplementaryElementKind = NSString;

extern_protocol!(
    /**
      NSCollectionViewElement declares functionality shared by (1) NSCollectionViewItems and (2) "supplementary" or "decoration" views that can be added to an NSCollectionView.  Each such reusable entity has the ability to be reset to its initial state by being sent -prepareForReuse, the ability to take size, position, and other state from an NSCollectionViewLayoutAttributes instance, and the ability to respond to transitions from one layout to another.  Note that, since these methods are all optional and invoked only when found to be present, all existing NSView classes can be considered conforming, and are therefore eligible to be used a supplementary and decorative views.  NSView and NSCollectionViewElement both conform to NSUserInterfaceItemIdentification, which provides an "identifier" property that CollectionView uses to track an item or supplementary/decoration view's kind.
    */
    pub unsafe trait NSCollectionViewElement:
        NSObjectProtocol + NSUserInterfaceItemIdentification
    {
        #[optional]
        #[method(prepareForReuse)]
        unsafe fn prepareForReuse(&self);

        #[cfg(feature = "AppKit_NSCollectionViewLayoutAttributes")]
        #[optional]
        #[method(applyLayoutAttributes:)]
        unsafe fn applyLayoutAttributes(
            &self,
            layout_attributes: &NSCollectionViewLayoutAttributes,
        );

        #[cfg(feature = "AppKit_NSCollectionViewLayout")]
        #[optional]
        #[method(willTransitionFromLayout:toLayout:)]
        unsafe fn willTransitionFromLayout_toLayout(
            &self,
            old_layout: &NSCollectionViewLayout,
            new_layout: &NSCollectionViewLayout,
        );

        #[cfg(feature = "AppKit_NSCollectionViewLayout")]
        #[optional]
        #[method(didTransitionFromLayout:toLayout:)]
        unsafe fn didTransitionFromLayout_toLayout(
            &self,
            old_layout: &NSCollectionViewLayout,
            new_layout: &NSCollectionViewLayout,
        );

        #[cfg(feature = "AppKit_NSCollectionViewLayoutAttributes")]
        #[optional]
        #[method_id(@__retain_semantics Other preferredLayoutAttributesFittingAttributes:)]
        unsafe fn preferredLayoutAttributesFittingAttributes(
            &self,
            layout_attributes: &NSCollectionViewLayoutAttributes,
        ) -> Id<NSCollectionViewLayoutAttributes>;
    }

    unsafe impl ProtocolType for dyn NSCollectionViewElement {}
);

extern_protocol!(
    /**
      Section header views can conform to this protocol, to enable a CollectionView to find the section collapse toggle button (when present).
    */
    pub unsafe trait NSCollectionViewSectionHeaderView: NSCollectionViewElement {
        #[cfg(feature = "AppKit_NSButton")]
        /**
          If your header contains a button that's set up to toggle section collapse, wire this outlet to it.  This enables CollectionView to automatically show and hide the button, based on whether the section's items all fit.
        */
        #[optional]
        #[method_id(@__retain_semantics Other sectionCollapseButton)]
        unsafe fn sectionCollapseButton(&self) -> Option<Id<NSButton>>;

        #[cfg(feature = "AppKit_NSButton")]
        /**
          If your header contains a button that's set up to toggle section collapse, wire this outlet to it.  This enables CollectionView to automatically show and hide the button, based on whether the section's items all fit.
        */
        #[optional]
        #[method(setSectionCollapseButton:)]
        unsafe fn setSectionCollapseButton(&self, section_collapse_button: Option<&NSButton>);
    }

    unsafe impl ProtocolType for dyn NSCollectionViewSectionHeaderView {}
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSCollectionViewItem")]
    /**
      An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
    */
    pub struct NSCollectionViewItem;

    #[cfg(feature = "AppKit_NSCollectionViewItem")]
    unsafe impl ClassType for NSCollectionViewItem {
        #[inherits(NSResponder, NSObject)]
        type Super = NSViewController;
    }
);

#[cfg(feature = "AppKit_NSCollectionViewItem")]
/**
  An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/
unsafe impl NSCoding for NSCollectionViewItem {}

#[cfg(feature = "AppKit_NSCollectionViewItem")]
/**
  An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/
unsafe impl NSCollectionViewElement for NSCollectionViewItem {}

#[cfg(feature = "AppKit_NSCollectionViewItem")]
/**
  An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/
unsafe impl NSEditor for NSCollectionViewItem {}

#[cfg(feature = "AppKit_NSCollectionViewItem")]
/**
  An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/
unsafe impl NSObjectProtocol for NSCollectionViewItem {}

#[cfg(feature = "AppKit_NSCollectionViewItem")]
/**
  An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/
unsafe impl NSSeguePerforming for NSCollectionViewItem {}

#[cfg(feature = "AppKit_NSCollectionViewItem")]
/**
  An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/
unsafe impl NSUserInterfaceItemIdentification for NSCollectionViewItem {}

extern_methods!(
    /**
      An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
    */
    #[cfg(feature = "AppKit_NSCollectionViewItem")]
    unsafe impl NSCollectionViewItem {
        #[cfg(feature = "AppKit_NSCollectionView")]
        /**
          Non-retained backlink to the containing CollectionView.
        */
        #[method_id(@__retain_semantics Other collectionView)]
        pub unsafe fn collectionView(&self) -> Option<Id<NSCollectionView>>;

        /**
          Whether the item is part of its collectionView's current selection.
        */
        #[method(isSelected)]
        pub unsafe fn isSelected(&self) -> bool;

        /**
          Whether the item is part of its collectionView's current selection.
        */
        #[method(setSelected:)]
        pub unsafe fn setSelected(&self, selected: bool);

        /**
          Whether the item should be shown as highlighted for proposed selection, deselection, as a drop target, or not highlighted.
        */
        #[method(highlightState)]
        pub unsafe fn highlightState(&self) -> NSCollectionViewItemHighlightState;

        /**
          Whether the item should be shown as highlighted for proposed selection, deselection, as a drop target, or not highlighted.
        */
        #[method(setHighlightState:)]
        pub unsafe fn setHighlightState(&self, highlight_state: NSCollectionViewItemHighlightState);

        #[cfg(feature = "AppKit_NSImageView")]
        /**
          Convenience outlet to the item's primary NSImageView (if any).
        */
        #[method_id(@__retain_semantics Other imageView)]
        pub unsafe fn imageView(&self) -> Option<Id<NSImageView>>;

        #[cfg(feature = "AppKit_NSImageView")]
        /**
          Convenience outlet to the item's primary NSImageView (if any).
        */
        #[method(setImageView:)]
        pub unsafe fn setImageView(&self, image_view: Option<&NSImageView>);

        #[cfg(feature = "AppKit_NSTextField")]
        /**
          Convenience outlet to the item's primary NSTextField (if any).
        */
        #[method_id(@__retain_semantics Other textField)]
        pub unsafe fn textField(&self) -> Option<Id<NSTextField>>;

        #[cfg(feature = "AppKit_NSTextField")]
        /**
          Convenience outlet to the item's primary NSTextField (if any).
        */
        #[method(setTextField:)]
        pub unsafe fn setTextField(&self, text_field: Option<&NSTextField>);

        #[cfg(all(
            feature = "AppKit_NSDraggingImageComponent",
            feature = "Foundation_NSArray"
        ))]
        /**
          Multi-image drag and drop support. The default implementation will return an array of up to two NSDraggingImageComponent instances -- one for the imageView and another for the textField (if not nil). This methods can be subclassed and overridden to provide a custom set of NSDraggingImageComponents to create the drag image. Note: the component frames are relative to a coordinate system that has its origin at the bottom left, so you need to take into account the flippedness of your view when computing the component frames.
        */
        #[method_id(@__retain_semantics Other draggingImageComponents)]
        pub unsafe fn draggingImageComponents(&self) -> Id<NSArray<NSDraggingImageComponent>>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSCollectionView")]
    /**
      An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
    */
    pub struct NSCollectionView;

    #[cfg(feature = "AppKit_NSCollectionView")]
    unsafe impl ClassType for NSCollectionView {
        #[inherits(NSResponder, NSObject)]
        type Super = NSView;
    }
);

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSAccessibility for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSAccessibilityElementProtocol for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSAnimatablePropertyContainer for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSAppearanceCustomization for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSCoding for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSDraggingDestination for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSDraggingSource for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSObjectProtocol for NSCollectionView {}

#[cfg(feature = "AppKit_NSCollectionView")]
/**
  An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
unsafe impl NSUserInterfaceItemIdentification for NSCollectionView {}

extern_methods!(
    /**
      An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
    */
    #[cfg(feature = "AppKit_NSCollectionView")]
    unsafe impl NSCollectionView {
        /**
          A non-retained data source object, that the CollectionView will consult to obtain information about the model objects to be represented and the number of sections to divide them among, and to make (recycle or instantiate) items and supplementary views.  See the NSCollectionViewDataSource protocol, declared below, for the methods this delegate should implement.

        Defaults to nil, which makes the CollectionView look to its "content" property or NSContentBinding for model object information.  The "content" property should only be used with the default "Grid" collectionViewLayout and legacy -newItemForRepresentedObject: / itemPrototype mechanisms for instantiating items.

        To get the new capabilities and behaviors, and use the new NSCollectionView APIs added in OS X 10.11, you must specify a dataSource.  Setting dataSource != nil causes the CollectionView to empty its "content" array, and attempting to set "content" to a non-empty array while dataSource != nil is considered a programming error that will cause an exception to be raised.
        */
        #[method_id(@__retain_semantics Other dataSource)]
        pub unsafe fn dataSource(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSCollectionViewDataSource>>>;

        /**
          A non-retained data source object, that the CollectionView will consult to obtain information about the model objects to be represented and the number of sections to divide them among, and to make (recycle or instantiate) items and supplementary views.  See the NSCollectionViewDataSource protocol, declared below, for the methods this delegate should implement.

        Defaults to nil, which makes the CollectionView look to its "content" property or NSContentBinding for model object information.  The "content" property should only be used with the default "Grid" collectionViewLayout and legacy -newItemForRepresentedObject: / itemPrototype mechanisms for instantiating items.

        To get the new capabilities and behaviors, and use the new NSCollectionView APIs added in OS X 10.11, you must specify a dataSource.  Setting dataSource != nil causes the CollectionView to empty its "content" array, and attempting to set "content" to a non-empty array while dataSource != nil is considered a programming error that will cause an exception to be raised.
        */
        #[method(setDataSource:)]
        pub unsafe fn setDataSource(
            &self,
            data_source: Option<&ProtocolObject<dyn NSCollectionViewDataSource>>,
        );

        /**
          An optional assistant to the CollectionView's 'dataSource' (potentially the same object), that receives notifications conducive to managing item data pre-fetching.
        */
        #[method_id(@__retain_semantics Other prefetchDataSource)]
        pub unsafe fn prefetchDataSource(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSCollectionViewPrefetching>>>;

        /**
          An optional assistant to the CollectionView's 'dataSource' (potentially the same object), that receives notifications conducive to managing item data pre-fetching.
        */
        #[method(setPrefetchDataSource:)]
        pub unsafe fn setPrefetchDataSource(
            &self,
            prefetch_data_source: Option<&ProtocolObject<dyn NSCollectionViewPrefetching>>,
        );

        #[cfg(feature = "Foundation_NSArray")]
        /**
          The array of model objects that will be shown as "items" in this CollectionView.  The objects may be of any type(s).  If you prefer not to give the CollectionView a "dataSource", you can set its "content" property explicitly, or bind the CollectionView's NSContentBinding to an NSArrayController's arrangedObjects property, to provide the CollectionView with its model objects.  A CollectionView whose content is provided in this way cannot have more than one section.

        Each corresponding "item" instantiated by the CollectionView will have its representedObject property wired to the corresponding model object from this "content" array.  Attempts to set "content" to nil are ignored on OS X 10.10 and earlier.  On OS X 10.11 and later, setting "content" to nil raises an exception.  (Set "content" to an empty NSArray instead, if you want to empty the CollectionView.)
        */
        #[method_id(@__retain_semantics Other content)]
        pub unsafe fn content(&self) -> Id<NSArray<Object>>;

        #[cfg(feature = "Foundation_NSArray")]
        /**
          The array of model objects that will be shown as "items" in this CollectionView.  The objects may be of any type(s).  If you prefer not to give the CollectionView a "dataSource", you can set its "content" property explicitly, or bind the CollectionView's NSContentBinding to an NSArrayController's arrangedObjects property, to provide the CollectionView with its model objects.  A CollectionView whose content is provided in this way cannot have more than one section.

        Each corresponding "item" instantiated by the CollectionView will have its representedObject property wired to the corresponding model object from this "content" array.  Attempts to set "content" to nil are ignored on OS X 10.10 and earlier.  On OS X 10.11 and later, setting "content" to nil raises an exception.  (Set "content" to an empty NSArray instead, if you want to empty the CollectionView.)
        */
        #[method(setContent:)]
        pub unsafe fn setContent(&self, content: &NSArray<Object>);

        #[method(reloadData)]
        pub unsafe fn reloadData(&self);

        /**
          An optional, non-retained delegate object, that will have the opportunity to influence the CollectionView's drag-and-drop, selection, highlighting, and layout transitioning behaviors.  See the NSCollectionViewDelegate protocol, declared below, for the methods this delegate may implement.  Defaults to nil, which leaves the CollectionView to determine its own behaviors.
        */
        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSCollectionViewDelegate>>>;

        /**
          An optional, non-retained delegate object, that will have the opportunity to influence the CollectionView's drag-and-drop, selection, highlighting, and layout transitioning behaviors.  See the NSCollectionViewDelegate protocol, declared below, for the methods this delegate may implement.  Defaults to nil, which leaves the CollectionView to determine its own behaviors.
        */
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSCollectionViewDelegate>>,
        );

        /**
          An optional background view that's positioned underneath all of the CollectionView's content.  Defaults to nil.  The backgroundView's scrolling behavior and frame are determined by the "backgroundViewScrollsWithContent" property, as described below.  If "backgroundColors" are also specified for the CollectionView, backgroundColor[0] is drawn anywhere the backgroundView's content allows it to show through.
        */
        #[method_id(@__retain_semantics Other backgroundView)]
        pub unsafe fn backgroundView(&self) -> Option<Id<NSView>>;

        /**
          An optional background view that's positioned underneath all of the CollectionView's content.  Defaults to nil.  The backgroundView's scrolling behavior and frame are determined by the "backgroundViewScrollsWithContent" property, as described below.  If "backgroundColors" are also specified for the CollectionView, backgroundColor[0] is drawn anywhere the backgroundView's content allows it to show through.
        */
        #[method(setBackgroundView:)]
        pub unsafe fn setBackgroundView(&self, background_view: Option<&NSView>);

        /**
          When YES, the CollectionView's backgroundView (if any) will match the CollectionView's frame and scroll with the CollectionView's items and other content.  When NO (the default, compatible with the behavior on OS X 10.11), the backgroundView is made to fill the CollectionView's visible area, and remains stationary when the CollectionView's content is scrolled.  Archived with the CollectionView's other persistent properties.
        */
        #[method(backgroundViewScrollsWithContent)]
        pub unsafe fn backgroundViewScrollsWithContent(&self) -> bool;

        /**
          When YES, the CollectionView's backgroundView (if any) will match the CollectionView's frame and scroll with the CollectionView's items and other content.  When NO (the default, compatible with the behavior on OS X 10.11), the backgroundView is made to fill the CollectionView's visible area, and remains stationary when the CollectionView's content is scrolled.  Archived with the CollectionView's other persistent properties.
        */
        #[method(setBackgroundViewScrollsWithContent:)]
        pub unsafe fn setBackgroundViewScrollsWithContent(
            &self,
            background_view_scrolls_with_content: bool,
        );

        #[cfg(feature = "AppKit_NSCollectionViewLayout")]
        /**
          The layout object that determines how the NSCollectionView's items will be sized and positioned.  Defaults to an instance of NSCollectionViewGridLayout whose maxNumberOfRows, maxNumberOfColumns, minItemSize, maxItemSize, and backgroundColors properties mirror the NSCollectionView's.  Replace this object, or change the values of its parameters, to change the layout.  collectionViewLayout may be set to nil for an NSCollectionView that is not using the dataSource-based API.

        To get an animated transition to the new layout, use [[collectionView animator] setCollectionViewLayout:].  You can use NSAnimationContext's completionHandler provisions to notify you when the transition is complete.
        */
        #[method_id(@__retain_semantics Other collectionViewLayout)]
        pub unsafe fn collectionViewLayout(&self) -> Option<Id<NSCollectionViewLayout>>;

        #[cfg(feature = "AppKit_NSCollectionViewLayout")]
        /**
          The layout object that determines how the NSCollectionView's items will be sized and positioned.  Defaults to an instance of NSCollectionViewGridLayout whose maxNumberOfRows, maxNumberOfColumns, minItemSize, maxItemSize, and backgroundColors properties mirror the NSCollectionView's.  Replace this object, or change the values of its parameters, to change the layout.  collectionViewLayout may be set to nil for an NSCollectionView that is not using the dataSource-based API.

        To get an animated transition to the new layout, use [[collectionView animator] setCollectionViewLayout:].  You can use NSAnimationContext's completionHandler provisions to notify you when the transition is complete.
        */
        #[method(setCollectionViewLayout:)]
        pub unsafe fn setCollectionViewLayout(
            &self,
            collection_view_layout: Option<&NSCollectionViewLayout>,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionViewLayoutAttributes",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method_id(@__retain_semantics Other layoutAttributesForItemAtIndexPath:)]
        pub unsafe fn layoutAttributesForItemAtIndexPath(
            &self,
            index_path: &NSIndexPath,
        ) -> Option<Id<NSCollectionViewLayoutAttributes>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionViewLayoutAttributes",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method_id(@__retain_semantics Other layoutAttributesForSupplementaryElementOfKind:atIndexPath:)]
        pub unsafe fn layoutAttributesForSupplementaryElementOfKind_atIndexPath(
            &self,
            kind: &NSCollectionViewSupplementaryElementKind,
            index_path: &NSIndexPath,
        ) -> Option<Id<NSCollectionViewLayoutAttributes>>;

        #[method(frameForItemAtIndex:)]
        pub unsafe fn frameForItemAtIndex(&self, index: NSUInteger) -> NSRect;

        #[method(frameForItemAtIndex:withNumberOfItems:)]
        pub unsafe fn frameForItemAtIndex_withNumberOfItems(
            &self,
            index: NSUInteger,
            number_of_items: NSUInteger,
        ) -> NSRect;

        #[cfg(all(feature = "AppKit_NSColor", feature = "Foundation_NSArray"))]
        /**
          The first background color in the array is used as the background of the entire collection view. Passing nil resets the background colors back to the default.
        */
        #[method_id(@__retain_semantics Other backgroundColors)]
        pub unsafe fn backgroundColors(&self) -> Id<NSArray<NSColor>>;

        #[cfg(all(feature = "AppKit_NSColor", feature = "Foundation_NSArray"))]
        /**
          The first background color in the array is used as the background of the entire collection view. Passing nil resets the background colors back to the default.
        */
        #[method(setBackgroundColors:)]
        pub unsafe fn setBackgroundColors(&self, background_colors: Option<&NSArray<NSColor>>);

        /**
          The number of sections displayed by the collection view.
        */
        #[method(numberOfSections)]
        pub unsafe fn numberOfSections(&self) -> NSInteger;

        #[method(numberOfItemsInSection:)]
        pub unsafe fn numberOfItemsInSection(&self, section: NSInteger) -> NSInteger;

        /**
          Whether the CollectionView is its window's current firstResponder.  This bindable property is useful for determining appropriate appearance for selected items.
        */
        #[method(isFirstResponder)]
        pub unsafe fn isFirstResponder(&self) -> bool;

        /**
          Whether the user can select items in the CollectionView.  Defaults to NO.  Changing this from YES to NO clears the CollectionView's current selection (if any), causing selectionIndexes to become an empty index set.
        */
        #[method(isSelectable)]
        pub unsafe fn isSelectable(&self) -> bool;

        /**
          Whether the user can select items in the CollectionView.  Defaults to NO.  Changing this from YES to NO clears the CollectionView's current selection (if any), causing selectionIndexes to become an empty index set.
        */
        #[method(setSelectable:)]
        pub unsafe fn setSelectable(&self, selectable: bool);

        /**
          Whether the CollectionView allows its selection to become empty.  Defaults to YES.  When this is set to NO and "selectable" is YES, the CollectionView will attempt to always leave at least one item selected, when the CollectionView has at least one item.
        */
        #[method(allowsEmptySelection)]
        pub unsafe fn allowsEmptySelection(&self) -> bool;

        /**
          Whether the CollectionView allows its selection to become empty.  Defaults to YES.  When this is set to NO and "selectable" is YES, the CollectionView will attempt to always leave at least one item selected, when the CollectionView has at least one item.
        */
        #[method(setAllowsEmptySelection:)]
        pub unsafe fn setAllowsEmptySelection(&self, allows_empty_selection: bool);

        /**
          Whether the user can simultaneously select multiple items in the CollectionView.  Defaults to NO, which means only one item at a time (or none) may be selected.  Changing this from YES to NO causes the CollectionView's selection to be reduced to the selected item with the lowest index in the section with the lowest index, if more than one item was selected.
        */
        #[method(allowsMultipleSelection)]
        pub unsafe fn allowsMultipleSelection(&self) -> bool;

        /**
          Whether the user can simultaneously select multiple items in the CollectionView.  Defaults to NO, which means only one item at a time (or none) may be selected.  Changing this from YES to NO causes the CollectionView's selection to be reduced to the selected item with the lowest index in the section with the lowest index, if more than one item was selected.
        */
        #[method(setAllowsMultipleSelection:)]
        pub unsafe fn setAllowsMultipleSelection(&self, allows_multiple_selection: bool);

        #[cfg(feature = "Foundation_NSIndexSet")]
        /**
          (Soft-Deprecated)  The indexes of the items that are currently "selected", indicating that user operations should target the "content" objects having these indexes.  Getting or setting this property raises an exception on 10.11 and later, if the CollectionView has more than one section.  Use "selectionIndexPaths" instead.
        */
        #[method_id(@__retain_semantics Other selectionIndexes)]
        pub unsafe fn selectionIndexes(&self) -> Id<NSIndexSet>;

        #[cfg(feature = "Foundation_NSIndexSet")]
        /**
          (Soft-Deprecated)  The indexes of the items that are currently "selected", indicating that user operations should target the "content" objects having these indexes.  Getting or setting this property raises an exception on 10.11 and later, if the CollectionView has more than one section.  Use "selectionIndexPaths" instead.
        */
        #[method(setSelectionIndexes:)]
        pub unsafe fn setSelectionIndexes(&self, selection_indexes: &NSIndexSet);

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        /**
          A set of of NSIndexPath values, that identify the currently selected items by (section,indexInSection).  When using the new NSCollectionView APIs on 10.11 and later, use this property instead of "selectionIndexes".  You can change the set of selected items by setting this property.  To request an animated transition of affected items between their selected and deselected appearances, you can set this property via the CollectionView's "animator" proxy: [[collectionView animator] setSelectionIndexPaths:newIndexPaths].  CollectionView will raise an exception if any of the given indexPaths is out-of-bounds.  This property is Key-Value Observable.
        */
        #[method_id(@__retain_semantics Other selectionIndexPaths)]
        pub unsafe fn selectionIndexPaths(&self) -> Id<NSSet<NSIndexPath>>;

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        /**
          A set of of NSIndexPath values, that identify the currently selected items by (section,indexInSection).  When using the new NSCollectionView APIs on 10.11 and later, use this property instead of "selectionIndexes".  You can change the set of selected items by setting this property.  To request an animated transition of affected items between their selected and deselected appearances, you can set this property via the CollectionView's "animator" proxy: [[collectionView animator] setSelectionIndexPaths:newIndexPaths].  CollectionView will raise an exception if any of the given indexPaths is out-of-bounds.  This property is Key-Value Observable.
        */
        #[method(setSelectionIndexPaths:)]
        pub unsafe fn setSelectionIndexPaths(&self, selection_index_paths: &NSSet<NSIndexPath>);

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method(selectItemsAtIndexPaths:scrollPosition:)]
        pub unsafe fn selectItemsAtIndexPaths_scrollPosition(
            &self,
            index_paths: &NSSet<NSIndexPath>,
            scroll_position: NSCollectionViewScrollPosition,
        );

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method(deselectItemsAtIndexPaths:)]
        pub unsafe fn deselectItemsAtIndexPaths(&self, index_paths: &NSSet<NSIndexPath>);

        #[method(selectAll:)]
        pub unsafe fn selectAll(&self, sender: Option<&Object>);

        #[method(deselectAll:)]
        pub unsafe fn deselectAll(&self, sender: Option<&Object>);

        #[method(registerClass:forItemWithIdentifier:)]
        pub unsafe fn registerClass_forItemWithIdentifier(
            &self,
            item_class: Option<&Class>,
            identifier: &NSUserInterfaceItemIdentifier,
        );

        #[cfg(feature = "AppKit_NSNib")]
        #[method(registerNib:forItemWithIdentifier:)]
        pub unsafe fn registerNib_forItemWithIdentifier(
            &self,
            nib: Option<&NSNib>,
            identifier: &NSUserInterfaceItemIdentifier,
        );

        #[method(registerClass:forSupplementaryViewOfKind:withIdentifier:)]
        pub unsafe fn registerClass_forSupplementaryViewOfKind_withIdentifier(
            &self,
            view_class: Option<&Class>,
            kind: &NSCollectionViewSupplementaryElementKind,
            identifier: &NSUserInterfaceItemIdentifier,
        );

        #[cfg(feature = "AppKit_NSNib")]
        #[method(registerNib:forSupplementaryViewOfKind:withIdentifier:)]
        pub unsafe fn registerNib_forSupplementaryViewOfKind_withIdentifier(
            &self,
            nib: Option<&NSNib>,
            kind: &NSCollectionViewSupplementaryElementKind,
            identifier: &NSUserInterfaceItemIdentifier,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method_id(@__retain_semantics Other makeItemWithIdentifier:forIndexPath:)]
        pub unsafe fn makeItemWithIdentifier_forIndexPath(
            &self,
            identifier: &NSUserInterfaceItemIdentifier,
            index_path: &NSIndexPath,
        ) -> Id<NSCollectionViewItem>;

        #[cfg(feature = "Foundation_NSIndexPath")]
        #[method_id(@__retain_semantics Other makeSupplementaryViewOfKind:withIdentifier:forIndexPath:)]
        pub unsafe fn makeSupplementaryViewOfKind_withIdentifier_forIndexPath(
            &self,
            element_kind: &NSCollectionViewSupplementaryElementKind,
            identifier: &NSUserInterfaceItemIdentifier,
            index_path: &NSIndexPath,
        ) -> Id<NSView>;

        #[cfg(feature = "AppKit_NSCollectionViewItem")]
        #[method_id(@__retain_semantics Other itemAtIndex:)]
        pub unsafe fn itemAtIndex(&self, index: NSUInteger) -> Option<Id<NSCollectionViewItem>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method_id(@__retain_semantics Other itemAtIndexPath:)]
        pub unsafe fn itemAtIndexPath(
            &self,
            index_path: &NSIndexPath,
        ) -> Option<Id<NSCollectionViewItem>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Other visibleItems)]
        pub unsafe fn visibleItems(&self) -> Id<NSArray<NSCollectionViewItem>>;

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method_id(@__retain_semantics Other indexPathsForVisibleItems)]
        pub unsafe fn indexPathsForVisibleItems(&self) -> Id<NSSet<NSIndexPath>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method_id(@__retain_semantics Other indexPathForItem:)]
        pub unsafe fn indexPathForItem(
            &self,
            item: &NSCollectionViewItem,
        ) -> Option<Id<NSIndexPath>>;

        #[cfg(feature = "Foundation_NSIndexPath")]
        #[method_id(@__retain_semantics Other indexPathForItemAtPoint:)]
        pub unsafe fn indexPathForItemAtPoint(&self, point: NSPoint) -> Option<Id<NSIndexPath>>;

        #[cfg(feature = "Foundation_NSIndexPath")]
        #[method_id(@__retain_semantics Other supplementaryViewForElementKind:atIndexPath:)]
        pub unsafe fn supplementaryViewForElementKind_atIndexPath(
            &self,
            element_kind: &NSCollectionViewSupplementaryElementKind,
            index_path: &NSIndexPath,
        ) -> Option<Id<NSView>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other visibleSupplementaryViewsOfKind:)]
        pub unsafe fn visibleSupplementaryViewsOfKind(
            &self,
            element_kind: &NSCollectionViewSupplementaryElementKind,
        ) -> Id<NSArray<NSView>>;

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method_id(@__retain_semantics Other indexPathsForVisibleSupplementaryElementsOfKind:)]
        pub unsafe fn indexPathsForVisibleSupplementaryElementsOfKind(
            &self,
            element_kind: &NSCollectionViewSupplementaryElementKind,
        ) -> Id<NSSet<NSIndexPath>>;

        #[cfg(feature = "Foundation_NSIndexSet")]
        #[method(insertSections:)]
        pub unsafe fn insertSections(&self, sections: &NSIndexSet);

        #[cfg(feature = "Foundation_NSIndexSet")]
        #[method(deleteSections:)]
        pub unsafe fn deleteSections(&self, sections: &NSIndexSet);

        #[cfg(feature = "Foundation_NSIndexSet")]
        #[method(reloadSections:)]
        pub unsafe fn reloadSections(&self, sections: &NSIndexSet);

        #[method(moveSection:toSection:)]
        pub unsafe fn moveSection_toSection(&self, section: NSInteger, new_section: NSInteger);

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method(insertItemsAtIndexPaths:)]
        pub unsafe fn insertItemsAtIndexPaths(&self, index_paths: &NSSet<NSIndexPath>);

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method(deleteItemsAtIndexPaths:)]
        pub unsafe fn deleteItemsAtIndexPaths(&self, index_paths: &NSSet<NSIndexPath>);

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method(reloadItemsAtIndexPaths:)]
        pub unsafe fn reloadItemsAtIndexPaths(&self, index_paths: &NSSet<NSIndexPath>);

        #[cfg(feature = "Foundation_NSIndexPath")]
        #[method(moveItemAtIndexPath:toIndexPath:)]
        pub unsafe fn moveItemAtIndexPath_toIndexPath(
            &self,
            index_path: &NSIndexPath,
            new_index_path: &NSIndexPath,
        );

        #[method(performBatchUpdates:completionHandler:)]
        pub unsafe fn performBatchUpdates_completionHandler(
            &self,
            updates: Option<&Block<(), ()>>,
            completion_handler: Option<&Block<(Bool,), ()>>,
        );

        #[method(toggleSectionCollapse:)]
        pub unsafe fn toggleSectionCollapse(&self, sender: &Object);

        #[cfg(all(feature = "Foundation_NSIndexPath", feature = "Foundation_NSSet"))]
        #[method(scrollToItemsAtIndexPaths:scrollPosition:)]
        pub unsafe fn scrollToItemsAtIndexPaths_scrollPosition(
            &self,
            index_paths: &NSSet<NSIndexPath>,
            scroll_position: NSCollectionViewScrollPosition,
        );

        #[method(setDraggingSourceOperationMask:forLocal:)]
        pub unsafe fn setDraggingSourceOperationMask_forLocal(
            &self,
            drag_operation_mask: NSDragOperation,
            local_destination: bool,
        );

        #[cfg(all(
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSImage",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[method_id(@__retain_semantics Other draggingImageForItemsAtIndexPaths:withEvent:offset:)]
        pub unsafe fn draggingImageForItemsAtIndexPaths_withEvent_offset(
            &self,
            index_paths: &NSSet<NSIndexPath>,
            event: &NSEvent,
            drag_image_offset: NSPointPointer,
        ) -> Id<NSImage>;

        #[cfg(all(
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSImage",
            feature = "Foundation_NSIndexSet"
        ))]
        #[method_id(@__retain_semantics Other draggingImageForItemsAtIndexes:withEvent:offset:)]
        pub unsafe fn draggingImageForItemsAtIndexes_withEvent_offset(
            &self,
            indexes: &NSIndexSet,
            event: &NSEvent,
            drag_image_offset: NSPointPointer,
        ) -> Id<NSImage>;
    }
);

extern_protocol!(
    pub unsafe trait NSCollectionViewDataSource: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSCollectionView")]
        #[method(collectionView:numberOfItemsInSection:)]
        unsafe fn collectionView_numberOfItemsInSection(
            &self,
            collection_view: &NSCollectionView,
            section: NSInteger,
        ) -> NSInteger;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method_id(@__retain_semantics Other collectionView:itemForRepresentedObjectAtIndexPath:)]
        unsafe fn collectionView_itemForRepresentedObjectAtIndexPath(
            &self,
            collection_view: &NSCollectionView,
            index_path: &NSIndexPath,
        ) -> Id<NSCollectionViewItem>;

        #[cfg(feature = "AppKit_NSCollectionView")]
        #[optional]
        #[method(numberOfSectionsInCollectionView:)]
        unsafe fn numberOfSectionsInCollectionView(
            &self,
            collection_view: &NSCollectionView,
        ) -> NSInteger;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSView",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:viewForSupplementaryElementOfKind:atIndexPath:)]
        unsafe fn collectionView_viewForSupplementaryElementOfKind_atIndexPath(
            &self,
            collection_view: &NSCollectionView,
            kind: &NSCollectionViewSupplementaryElementKind,
            index_path: &NSIndexPath,
        ) -> Id<NSView>;
    }

    unsafe impl ProtocolType for dyn NSCollectionViewDataSource {}
);

extern_protocol!(
    pub unsafe trait NSCollectionViewPrefetching: NSObjectProtocol {
        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSIndexPath"
        ))]
        #[method(collectionView:prefetchItemsAtIndexPaths:)]
        unsafe fn collectionView_prefetchItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSArray<NSIndexPath>,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:cancelPrefetchingForItemsAtIndexPaths:)]
        unsafe fn collectionView_cancelPrefetchingForItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSArray<NSIndexPath>,
        );
    }

    unsafe impl ProtocolType for dyn NSCollectionViewPrefetching {}
);

extern_protocol!(
    pub unsafe trait NSCollectionViewDelegate: NSObjectProtocol {
        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSEvent",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method(collectionView:canDragItemsAtIndexPaths:withEvent:)]
        unsafe fn collectionView_canDragItemsAtIndexPaths_withEvent(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
            event: &NSEvent,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSEvent",
            feature = "Foundation_NSIndexSet"
        ))]
        #[optional]
        #[method(collectionView:canDragItemsAtIndexes:withEvent:)]
        unsafe fn collectionView_canDragItemsAtIndexes_withEvent(
            &self,
            collection_view: &NSCollectionView,
            indexes: &NSIndexSet,
            event: &NSEvent,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSPasteboard",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[deprecated = "Use -collectionView:pasteboardWriterForItemAtIndexPath: instead"]
        #[optional]
        #[method(collectionView:writeItemsAtIndexPaths:toPasteboard:)]
        unsafe fn collectionView_writeItemsAtIndexPaths_toPasteboard(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
            pasteboard: &NSPasteboard,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSPasteboard",
            feature = "Foundation_NSIndexSet"
        ))]
        #[deprecated = "Use -collectionView:pasteboardWriterForItemAtIndexPath: instead"]
        #[optional]
        #[method(collectionView:writeItemsAtIndexes:toPasteboard:)]
        unsafe fn collectionView_writeItemsAtIndexes_toPasteboard(
            &self,
            collection_view: &NSCollectionView,
            indexes: &NSIndexSet,
            pasteboard: &NSPasteboard,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[deprecated = "Use NSFilePromiseReceiver objects instead"]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:namesOfPromisedFilesDroppedAtDestination:forDraggedItemsAtIndexPaths:)]
        unsafe fn collectionView_namesOfPromisedFilesDroppedAtDestination_forDraggedItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            drop_url: &NSURL,
            index_paths: &NSSet<NSIndexPath>,
        ) -> Id<NSArray<NSString>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSIndexSet",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[deprecated = "Use NSFilePromiseReceiver objects instead"]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:namesOfPromisedFilesDroppedAtDestination:forDraggedItemsAtIndexes:)]
        unsafe fn collectionView_namesOfPromisedFilesDroppedAtDestination_forDraggedItemsAtIndexes(
            &self,
            collection_view: &NSCollectionView,
            drop_url: &NSURL,
            indexes: &NSIndexSet,
        ) -> Id<NSArray<NSString>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSImage",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:draggingImageForItemsAtIndexPaths:withEvent:offset:)]
        unsafe fn collectionView_draggingImageForItemsAtIndexPaths_withEvent_offset(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
            event: &NSEvent,
            drag_image_offset: NSPointPointer,
        ) -> Id<NSImage>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSEvent",
            feature = "AppKit_NSImage",
            feature = "Foundation_NSIndexSet"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:draggingImageForItemsAtIndexes:withEvent:offset:)]
        unsafe fn collectionView_draggingImageForItemsAtIndexes_withEvent_offset(
            &self,
            collection_view: &NSCollectionView,
            indexes: &NSIndexSet,
            event: &NSEvent,
            drag_image_offset: NSPointPointer,
        ) -> Id<NSImage>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:validateDrop:proposedIndexPath:dropOperation:)]
        unsafe fn collectionView_validateDrop_proposedIndexPath_dropOperation(
            &self,
            collection_view: &NSCollectionView,
            dragging_info: &ProtocolObject<dyn NSDraggingInfo>,
            proposed_drop_index_path: &mut Id<NSIndexPath>,
            proposed_drop_operation: NonNull<NSCollectionViewDropOperation>,
        ) -> NSDragOperation;

        #[cfg(feature = "AppKit_NSCollectionView")]
        #[optional]
        #[method(collectionView:validateDrop:proposedIndex:dropOperation:)]
        unsafe fn collectionView_validateDrop_proposedIndex_dropOperation(
            &self,
            collection_view: &NSCollectionView,
            dragging_info: &ProtocolObject<dyn NSDraggingInfo>,
            proposed_drop_index: NonNull<NSInteger>,
            proposed_drop_operation: NonNull<NSCollectionViewDropOperation>,
        ) -> NSDragOperation;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:acceptDrop:indexPath:dropOperation:)]
        unsafe fn collectionView_acceptDrop_indexPath_dropOperation(
            &self,
            collection_view: &NSCollectionView,
            dragging_info: &ProtocolObject<dyn NSDraggingInfo>,
            index_path: &NSIndexPath,
            drop_operation: NSCollectionViewDropOperation,
        ) -> bool;

        #[cfg(feature = "AppKit_NSCollectionView")]
        #[optional]
        #[method(collectionView:acceptDrop:index:dropOperation:)]
        unsafe fn collectionView_acceptDrop_index_dropOperation(
            &self,
            collection_view: &NSCollectionView,
            dragging_info: &ProtocolObject<dyn NSDraggingInfo>,
            index: NSInteger,
            drop_operation: NSCollectionViewDropOperation,
        ) -> bool;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:pasteboardWriterForItemAtIndexPath:)]
        unsafe fn collectionView_pasteboardWriterForItemAtIndexPath(
            &self,
            collection_view: &NSCollectionView,
            index_path: &NSIndexPath,
        ) -> Option<Id<ProtocolObject<dyn NSPasteboardWriting>>>;

        #[cfg(feature = "AppKit_NSCollectionView")]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:pasteboardWriterForItemAtIndex:)]
        unsafe fn collectionView_pasteboardWriterForItemAtIndex(
            &self,
            collection_view: &NSCollectionView,
            index: NSUInteger,
        ) -> Option<Id<ProtocolObject<dyn NSPasteboardWriting>>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSDraggingSession",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method(collectionView:draggingSession:willBeginAtPoint:forItemsAtIndexPaths:)]
        unsafe fn collectionView_draggingSession_willBeginAtPoint_forItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            session: &NSDraggingSession,
            screen_point: NSPoint,
            index_paths: &NSSet<NSIndexPath>,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSDraggingSession",
            feature = "Foundation_NSIndexSet"
        ))]
        #[optional]
        #[method(collectionView:draggingSession:willBeginAtPoint:forItemsAtIndexes:)]
        unsafe fn collectionView_draggingSession_willBeginAtPoint_forItemsAtIndexes(
            &self,
            collection_view: &NSCollectionView,
            session: &NSDraggingSession,
            screen_point: NSPoint,
            indexes: &NSIndexSet,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSDraggingSession"
        ))]
        #[optional]
        #[method(collectionView:draggingSession:endedAtPoint:dragOperation:)]
        unsafe fn collectionView_draggingSession_endedAtPoint_dragOperation(
            &self,
            collection_view: &NSCollectionView,
            session: &NSDraggingSession,
            screen_point: NSPoint,
            operation: NSDragOperation,
        );

        #[cfg(feature = "AppKit_NSCollectionView")]
        #[optional]
        #[method(collectionView:updateDraggingItemsForDrag:)]
        unsafe fn collectionView_updateDraggingItemsForDrag(
            &self,
            collection_view: &NSCollectionView,
            dragging_info: &ProtocolObject<dyn NSDraggingInfo>,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:shouldChangeItemsAtIndexPaths:toHighlightState:)]
        unsafe fn collectionView_shouldChangeItemsAtIndexPaths_toHighlightState(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
            highlight_state: NSCollectionViewItemHighlightState,
        ) -> Id<NSSet<NSIndexPath>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method(collectionView:didChangeItemsAtIndexPaths:toHighlightState:)]
        unsafe fn collectionView_didChangeItemsAtIndexPaths_toHighlightState(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
            highlight_state: NSCollectionViewItemHighlightState,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:shouldSelectItemsAtIndexPaths:)]
        unsafe fn collectionView_shouldSelectItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
        ) -> Id<NSSet<NSIndexPath>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:shouldDeselectItemsAtIndexPaths:)]
        unsafe fn collectionView_shouldDeselectItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
        ) -> Id<NSSet<NSIndexPath>>;

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method(collectionView:didSelectItemsAtIndexPaths:)]
        unsafe fn collectionView_didSelectItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "Foundation_NSIndexPath",
            feature = "Foundation_NSSet"
        ))]
        #[optional]
        #[method(collectionView:didDeselectItemsAtIndexPaths:)]
        unsafe fn collectionView_didDeselectItemsAtIndexPaths(
            &self,
            collection_view: &NSCollectionView,
            index_paths: &NSSet<NSIndexPath>,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:willDisplayItem:forRepresentedObjectAtIndexPath:)]
        unsafe fn collectionView_willDisplayItem_forRepresentedObjectAtIndexPath(
            &self,
            collection_view: &NSCollectionView,
            item: &NSCollectionViewItem,
            index_path: &NSIndexPath,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSView",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:willDisplaySupplementaryView:forElementKind:atIndexPath:)]
        unsafe fn collectionView_willDisplaySupplementaryView_forElementKind_atIndexPath(
            &self,
            collection_view: &NSCollectionView,
            view: &NSView,
            element_kind: &NSCollectionViewSupplementaryElementKind,
            index_path: &NSIndexPath,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSCollectionViewItem",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:didEndDisplayingItem:forRepresentedObjectAtIndexPath:)]
        unsafe fn collectionView_didEndDisplayingItem_forRepresentedObjectAtIndexPath(
            &self,
            collection_view: &NSCollectionView,
            item: &NSCollectionViewItem,
            index_path: &NSIndexPath,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSView",
            feature = "Foundation_NSIndexPath"
        ))]
        #[optional]
        #[method(collectionView:didEndDisplayingSupplementaryView:forElementOfKind:atIndexPath:)]
        unsafe fn collectionView_didEndDisplayingSupplementaryView_forElementOfKind_atIndexPath(
            &self,
            collection_view: &NSCollectionView,
            view: &NSView,
            element_kind: &NSCollectionViewSupplementaryElementKind,
            index_path: &NSIndexPath,
        );

        #[cfg(all(
            feature = "AppKit_NSCollectionView",
            feature = "AppKit_NSCollectionViewLayout",
            feature = "AppKit_NSCollectionViewTransitionLayout"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other collectionView:transitionLayoutForOldLayout:newLayout:)]
        unsafe fn collectionView_transitionLayoutForOldLayout_newLayout(
            &self,
            collection_view: &NSCollectionView,
            from_layout: &NSCollectionViewLayout,
            to_layout: &NSCollectionViewLayout,
        ) -> Id<NSCollectionViewTransitionLayout>;
    }

    unsafe impl ProtocolType for dyn NSCollectionViewDelegate {}
);

extern_methods!(
    /// NSCollectionViewAdditions
    #[cfg(feature = "Foundation_NSIndexPath")]
    unsafe impl NSIndexPath {
        #[method_id(@__retain_semantics Other indexPathForItem:inSection:)]
        pub unsafe fn indexPathForItem_inSection(
            item: NSInteger,
            section: NSInteger,
        ) -> Id<NSIndexPath>;

        #[method(item)]
        pub unsafe fn item(&self) -> NSInteger;

        #[method(section)]
        pub unsafe fn section(&self) -> NSInteger;
    }
);

extern_methods!(
    /// NSCollectionViewAdditions
    #[cfg(feature = "Foundation_NSSet")]
    unsafe impl NSSet {
        #[cfg(feature = "Foundation_NSIndexPath")]
        #[method_id(@__retain_semantics Other setWithCollectionViewIndexPath:)]
        pub unsafe fn setWithCollectionViewIndexPath(index_path: &NSIndexPath) -> Id<Self>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSIndexPath"))]
        #[method_id(@__retain_semantics Other setWithCollectionViewIndexPaths:)]
        pub unsafe fn setWithCollectionViewIndexPaths(
            index_paths: &NSArray<NSIndexPath>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSIndexPath")]
        #[method(enumerateIndexPathsWithOptions:usingBlock:)]
        pub unsafe fn enumerateIndexPathsWithOptions_usingBlock(
            &self,
            opts: NSEnumerationOptions,
            block: &Block<(NonNull<NSIndexPath>, NonNull<Bool>), ()>,
        );
    }
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "AppKit_NSCollectionView")]
    unsafe impl NSCollectionView {
        #[cfg(feature = "AppKit_NSCollectionViewItem")]
        #[deprecated = "Use -[NSCollectionViewDataSource collectionView:itemForRepresentedObjectAtIndexPath:] instead"]
        #[method_id(@__retain_semantics New newItemForRepresentedObject:)]
        pub unsafe fn newItemForRepresentedObject(
            &self,
            object: &Object,
        ) -> Id<NSCollectionViewItem>;

        #[cfg(feature = "AppKit_NSCollectionViewItem")]
        /**
          A prototype NSCollectionViewItem that a dataSource-less NSCollectionView should clone to produce new items.  When not using a dataSource, you must either specify an itemPrototype, or override -newItemForRepresentedObject:, for the CollectionView to be able to create and display items.

        It is considered a programming error to send this message to an NSCollectionView that has a dataSource; an exception will be raised.
        */
        #[deprecated = "Use -registerNib:forItemWithIdentifier: or -registerClass:forItemWithIdentifier: instead."]
        #[method_id(@__retain_semantics Other itemPrototype)]
        pub unsafe fn itemPrototype(&self) -> Option<Id<NSCollectionViewItem>>;

        #[cfg(feature = "AppKit_NSCollectionViewItem")]
        /**
          A prototype NSCollectionViewItem that a dataSource-less NSCollectionView should clone to produce new items.  When not using a dataSource, you must either specify an itemPrototype, or override -newItemForRepresentedObject:, for the CollectionView to be able to create and display items.

        It is considered a programming error to send this message to an NSCollectionView that has a dataSource; an exception will be raised.
        */
        #[deprecated = "Use -registerNib:forItemWithIdentifier: or -registerClass:forItemWithIdentifier: instead."]
        #[method(setItemPrototype:)]
        pub unsafe fn setItemPrototype(&self, item_prototype: Option<&NSCollectionViewItem>);

        /**
          default: 0, which means no limit
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its maximumNumberOfRows instead"]
        #[method(maxNumberOfRows)]
        pub unsafe fn maxNumberOfRows(&self) -> NSUInteger;

        /**
          default: 0, which means no limit
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its maximumNumberOfRows instead"]
        #[method(setMaxNumberOfRows:)]
        pub unsafe fn setMaxNumberOfRows(&self, max_number_of_rows: NSUInteger);

        /**
          default: 0, which means no limit
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its maximumNumberOfColumns instead"]
        #[method(maxNumberOfColumns)]
        pub unsafe fn maxNumberOfColumns(&self) -> NSUInteger;

        /**
          default: 0, which means no limit
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its maximumNumberOfColumns instead"]
        #[method(setMaxNumberOfColumns:)]
        pub unsafe fn setMaxNumberOfColumns(&self, max_number_of_columns: NSUInteger);

        /**
          default: (0; 0)
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its minimumItemSize instead"]
        #[method(minItemSize)]
        pub unsafe fn minItemSize(&self) -> NSSize;

        /**
          default: (0; 0)
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its minimumItemSize instead"]
        #[method(setMinItemSize:)]
        pub unsafe fn setMinItemSize(&self, min_item_size: NSSize);

        /**
          default: (0; 0), which means no limit
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its maximumItemSize instead"]
        #[method(maxItemSize)]
        pub unsafe fn maxItemSize(&self) -> NSSize;

        /**
          default: (0; 0), which means no limit
        */
        #[deprecated = "Use NSCollectionViewGridLayout as the receiver's collectionViewLayout, setting its maximumItemSize instead"]
        #[method(setMaxItemSize:)]
        pub unsafe fn setMaxItemSize(&self, max_item_size: NSSize);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSViewController`
    /**
      An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
    */
    #[cfg(feature = "AppKit_NSCollectionViewItem")]
    unsafe impl NSCollectionViewItem {
        #[cfg(feature = "Foundation_NSBundle")]
        #[method_id(@__retain_semantics Init initWithNibName:bundle:)]
        pub unsafe fn initWithNibName_bundle(
            this: Option<Allocated<Self>>,
            nib_name_or_nil: Option<&NSNibName>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Id<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSView`
    /**
      An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
    */
    #[cfg(feature = "AppKit_NSCollectionView")]
    unsafe impl NSCollectionView {
        #[method_id(@__retain_semantics Init initWithFrame:)]
        pub unsafe fn initWithFrame(this: Option<Allocated<Self>>, frame_rect: NSRect) -> Id<Self>;
    }
);
