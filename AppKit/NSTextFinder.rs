//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSTextFinderAction {
        NSTextFinderActionShowFindInterface = 1,
        NSTextFinderActionNextMatch = 2,
        NSTextFinderActionPreviousMatch = 3,
        NSTextFinderActionReplaceAll = 4,
        NSTextFinderActionReplace = 5,
        NSTextFinderActionReplaceAndFind = 6,
        NSTextFinderActionSetSearchString = 7,
        NSTextFinderActionReplaceAllInSelection = 8,
        NSTextFinderActionSelectAll = 9,
        NSTextFinderActionSelectAllInSelection = 10,
        NSTextFinderActionHideFindInterface = 11,
        NSTextFinderActionShowReplaceInterface = 12,
        NSTextFinderActionHideReplaceInterface = 13,
    }
);

typed_enum!(
    pub type NSPasteboardTypeTextFinderOptionKey = NSString;
);

extern_static!(NSTextFinderCaseInsensitiveKey: &'static NSPasteboardTypeTextFinderOptionKey);

extern_static!(NSTextFinderMatchingTypeKey: &'static NSPasteboardTypeTextFinderOptionKey);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSTextFinderMatchingType {
        NSTextFinderMatchingTypeContains = 0,
        NSTextFinderMatchingTypeStartsWith = 1,
        NSTextFinderMatchingTypeFullWord = 2,
        NSTextFinderMatchingTypeEndsWith = 3,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSTextFinder")]
    pub struct NSTextFinder;

    #[cfg(feature = "AppKit_NSTextFinder")]
    unsafe impl ClassType for NSTextFinder {
        type Super = NSObject;
    }
);

#[cfg(feature = "AppKit_NSTextFinder")]
unsafe impl NSCoding for NSTextFinder {}

#[cfg(feature = "AppKit_NSTextFinder")]
unsafe impl NSObjectProtocol for NSTextFinder {}

extern_methods!(
    #[cfg(feature = "AppKit_NSTextFinder")]
    unsafe impl NSTextFinder {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(this: Option<Allocated<Self>>, coder: &NSCoder) -> Id<Self>;

        /**
          A text finder must be associated with an object which implements the NSTextFinderClient protocol for it to function. The client is responsible for providing the string to be searched, the location for the find bar, and methods which control feedback to the user about the search results.
        */
        #[method_id(@__retain_semantics Other client)]
        pub unsafe fn client(&self) -> Option<Id<ProtocolObject<dyn NSTextFinderClient>>>;

        /**
          A text finder must be associated with an object which implements the NSTextFinderClient protocol for it to function. The client is responsible for providing the string to be searched, the location for the find bar, and methods which control feedback to the user about the search results.
        */
        #[method(setClient:)]
        pub unsafe fn setClient(&self, client: Option<&ProtocolObject<dyn NSTextFinderClient>>);

        #[method(performAction:)]
        pub unsafe fn performAction(&self, op: NSTextFinderAction);

        #[method(validateAction:)]
        pub unsafe fn validateAction(&self, op: NSTextFinderAction) -> bool;

        /**
          This property must be set to support the find bar. When the find bar is requested to be shown, NSTextFinder will call -showFindBarView: on the container, passing the view for the find bar, which it should display somewhere that is easily associated with the content being searched. NSScrollView already implements NSTextFinderBarContainer and is an excellent place to display the find bar, in most circumstances. The container may freely modify the find bar view's width and origin, but not its height. If this property is not set, then the find bar cannot be shown.
        */
        #[method_id(@__retain_semantics Other findBarContainer)]
        pub unsafe fn findBarContainer(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSTextFinderBarContainer>>>;

        /**
          This property must be set to support the find bar. When the find bar is requested to be shown, NSTextFinder will call -showFindBarView: on the container, passing the view for the find bar, which it should display somewhere that is easily associated with the content being searched. NSScrollView already implements NSTextFinderBarContainer and is an excellent place to display the find bar, in most circumstances. The container may freely modify the find bar view's width and origin, but not its height. If this property is not set, then the find bar cannot be shown.
        */
        #[method(setFindBarContainer:)]
        pub unsafe fn setFindBarContainer(
            &self,
            find_bar_container: Option<&ProtocolObject<dyn NSTextFinderBarContainer>>,
        );

        #[method(cancelFindIndicator)]
        pub unsafe fn cancelFindIndicator(&self);

        /**
          If your client's document is not scrolled by NSScrollView, then you should set this property to YES when scrolling occurs to cause the find indicator to be updated appropriately.
        */
        #[method(findIndicatorNeedsUpdate)]
        pub unsafe fn findIndicatorNeedsUpdate(&self) -> bool;

        /**
          If your client's document is not scrolled by NSScrollView, then you should set this property to YES when scrolling occurs to cause the find indicator to be updated appropriately.
        */
        #[method(setFindIndicatorNeedsUpdate:)]
        pub unsafe fn setFindIndicatorNeedsUpdate(&self, find_indicator_needs_update: bool);

        /**
          An NSTextFinder uses this property's value to determine if it should perform regular or incremental searches. If YES, then the find bar will do incremental searches. If it returns NO, then the find bar will behave regularly. The default value is NO.
        */
        #[method(isIncrementalSearchingEnabled)]
        pub unsafe fn isIncrementalSearchingEnabled(&self) -> bool;

        /**
          An NSTextFinder uses this property's value to determine if it should perform regular or incremental searches. If YES, then the find bar will do incremental searches. If it returns NO, then the find bar will behave regularly. The default value is NO.
        */
        #[method(setIncrementalSearchingEnabled:)]
        pub unsafe fn setIncrementalSearchingEnabled(&self, incremental_searching_enabled: bool);

        /**
          NSTextFinder uses this property's value to determine what kind of incremental search feedback should be presented. If YES, then when an incremental search begins, the findBarContainer's contentView will be dimmed, except for the locations of the incremental matches. If NO, then the incremental matches will not be highlighted automatically, but you can use incrementalMatchRanges to highlight the matches yourself. The default value is YES.
        */
        #[method(incrementalSearchingShouldDimContentView)]
        pub unsafe fn incrementalSearchingShouldDimContentView(&self) -> bool;

        /**
          NSTextFinder uses this property's value to determine what kind of incremental search feedback should be presented. If YES, then when an incremental search begins, the findBarContainer's contentView will be dimmed, except for the locations of the incremental matches. If NO, then the incremental matches will not be highlighted automatically, but you can use incrementalMatchRanges to highlight the matches yourself. The default value is YES.
        */
        #[method(setIncrementalSearchingShouldDimContentView:)]
        pub unsafe fn setIncrementalSearchingShouldDimContentView(
            &self,
            incremental_searching_should_dim_content_view: bool,
        );

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSValue"))]
        /**
          This array is updated periodically on the main queue as the incremental search operation on a background queue finds matches. You can use this property when incrementalSearchingShouldDimContentView is NO to know where to draw highlights for incremental matches. This array is KVO compliant and can be observed to know when to update your highlights. When NSKeyValueObservingOptionNew and NSKeyValueObservingOptionOld are used, the KVO change dictionary provides the ranges (and their indexes) that are added or removed so you can invalidate the minimal region needed to bring your highlights into sync with the NSTextFinder's results. If no incremental search is active, or there are no matches found, this array will be empty. If an incremental search is currently in progress, but not yet complete, this will return all the ranges found so far.
        */
        #[method_id(@__retain_semantics Other incrementalMatchRanges)]
        pub unsafe fn incrementalMatchRanges(&self) -> Id<NSArray<NSValue>>;

        #[method(drawIncrementalMatchHighlightInRect:)]
        pub unsafe fn drawIncrementalMatchHighlightInRect(rect: NSRect);

        #[method(noteClientStringWillChange)]
        pub unsafe fn noteClientStringWillChange(&self);
    }
);

extern_protocol!(
    pub unsafe trait NSTextFinderClient: NSObjectProtocol {
        /**
          NSTextFinder uses the following properties to validate individual actions. If these properties are not implemented, NSTextFinder will act as if they returned YES.
        */
        #[optional]
        #[method(isSelectable)]
        unsafe fn isSelectable(&self) -> bool;

        #[optional]
        #[method(allowsMultipleSelection)]
        unsafe fn allowsMultipleSelection(&self) -> bool;

        #[optional]
        #[method(isEditable)]
        unsafe fn isEditable(&self) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        /**
          If the client contains a single string, then the client can implement this property to return that string to be searched.
        */
        #[optional]
        #[method_id(@__retain_semantics Other string)]
        unsafe fn string(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[optional]
        #[method_id(@__retain_semantics Other stringAtIndex:effectiveRange:endsWithSearchBoundary:)]
        unsafe fn stringAtIndex_effectiveRange_endsWithSearchBoundary(
            &self,
            character_index: NSUInteger,
            out_range: NSRangePointer,
            out_flag: NonNull<Bool>,
        ) -> Id<NSString>;

        #[optional]
        #[method(stringLength)]
        unsafe fn stringLength(&self) -> NSUInteger;

        /**
          This property is required for the NextMatch, PreviousMatch, Replace, ReplaceAndFind, and SetSearchString actions. The client just needs to return its first selected range, or {index, 0} to indicate the location of the insertion point if there is no selection.
        */
        #[optional]
        #[method(firstSelectedRange)]
        unsafe fn firstSelectedRange(&self) -> NSRange;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSValue"))]
        /**
          This property is required for the ReplaceAllInSelection, SelectAll, and SelectAllInSelection actions. The NSArray should contain NSRanges wrapped by NSValues.
        */
        #[optional]
        #[method_id(@__retain_semantics Other selectedRanges)]
        unsafe fn selectedRanges(&self) -> Id<NSArray<NSValue>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSValue"))]
        /**
          This property is required for the ReplaceAllInSelection, SelectAll, and SelectAllInSelection actions. The NSArray should contain NSRanges wrapped by NSValues.
        */
        #[optional]
        #[method(setSelectedRanges:)]
        unsafe fn setSelectedRanges(&self, selected_ranges: &NSArray<NSValue>);

        #[optional]
        #[method(scrollRangeToVisible:)]
        unsafe fn scrollRangeToVisible(&self, range: NSRange);

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString",
            feature = "Foundation_NSValue"
        ))]
        #[optional]
        #[method(shouldReplaceCharactersInRanges:withStrings:)]
        unsafe fn shouldReplaceCharactersInRanges_withStrings(
            &self,
            ranges: &NSArray<NSValue>,
            strings: &NSArray<NSString>,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[optional]
        #[method(replaceCharactersInRange:withString:)]
        unsafe fn replaceCharactersInRange_withString(&self, range: NSRange, string: &NSString);

        #[optional]
        #[method(didReplaceCharacters)]
        unsafe fn didReplaceCharacters(&self);

        #[cfg(feature = "AppKit_NSView")]
        #[optional]
        #[method_id(@__retain_semantics Other contentViewAtIndex:effectiveCharacterRange:)]
        unsafe fn contentViewAtIndex_effectiveCharacterRange(
            &self,
            index: NSUInteger,
            out_range: NSRangePointer,
        ) -> Id<NSView>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSValue"))]
        #[optional]
        #[method_id(@__retain_semantics Other rectsForCharacterRange:)]
        unsafe fn rectsForCharacterRange(&self, range: NSRange) -> Option<Id<NSArray<NSValue>>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSValue"))]
        /**
          NSTextFinder uses this property's value to determine which ranges it should search to show all of the incremental matches that are currently visible. If this property is not implemented, then the incremental matches cannot be shown.
        */
        #[optional]
        #[method_id(@__retain_semantics Other visibleCharacterRanges)]
        unsafe fn visibleCharacterRanges(&self) -> Id<NSArray<NSValue>>;

        #[cfg(feature = "AppKit_NSView")]
        #[optional]
        #[method(drawCharactersInRange:forContentView:)]
        unsafe fn drawCharactersInRange_forContentView(&self, range: NSRange, view: &NSView);
    }

    unsafe impl ProtocolType for dyn NSTextFinderClient {}
);

extern_protocol!(
    pub unsafe trait NSTextFinderBarContainer: NSObjectProtocol {
        #[cfg(feature = "AppKit_NSView")]
        /**
          This property is used by NSTextFinder to assign a find bar to a container. The container may freely modify the view's width, but should not modify its height. This property is managed by NSTextFinder. You should not set this property.
        */
        #[method_id(@__retain_semantics Other findBarView)]
        unsafe fn findBarView(&self) -> Option<Id<NSView>>;

        #[cfg(feature = "AppKit_NSView")]
        /**
          This property is used by NSTextFinder to assign a find bar to a container. The container may freely modify the view's width, but should not modify its height. This property is managed by NSTextFinder. You should not set this property.
        */
        #[method(setFindBarView:)]
        unsafe fn setFindBarView(&self, find_bar_view: Option<&NSView>);

        /**
          This property controls whether the receiver should display its find bar or not. When this property is YES and the findBarView property is set, then the find bar should be displayed by the container. Otherwise, the find bar should not be displayed. The default value should be NO.
        */
        #[method(isFindBarVisible)]
        unsafe fn isFindBarVisible(&self) -> bool;

        /**
          This property controls whether the receiver should display its find bar or not. When this property is YES and the findBarView property is set, then the find bar should be displayed by the container. Otherwise, the find bar should not be displayed. The default value should be NO.
        */
        #[method(setFindBarVisible:)]
        unsafe fn setFindBarVisible(&self, find_bar_visible: bool);

        #[method(findBarViewDidChangeHeight)]
        unsafe fn findBarViewDidChangeHeight(&self);

        #[cfg(feature = "AppKit_NSView")]
        #[optional]
        #[method_id(@__retain_semantics Other contentView)]
        unsafe fn contentView(&self) -> Option<Id<NSView>>;
    }

    unsafe impl ProtocolType for dyn NSTextFinderBarContainer {}
);
