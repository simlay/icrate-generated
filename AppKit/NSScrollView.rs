//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSScrollElasticity {
        NSScrollElasticityAutomatic = 0,
        NSScrollElasticityNone = 1,
        NSScrollElasticityAllowed = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSScrollView")]
    pub struct NSScrollView;

    #[cfg(feature = "AppKit_NSScrollView")]
    unsafe impl ClassType for NSScrollView {
        #[inherits(NSResponder, NSObject)]
        type Super = NSView;
    }
);

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSAccessibility for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSAccessibilityElementProtocol for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSAnimatablePropertyContainer for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSAppearanceCustomization for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSCoding for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSDraggingDestination for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSObjectProtocol for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSTextFinderBarContainer for NSScrollView {}

#[cfg(feature = "AppKit_NSScrollView")]
unsafe impl NSUserInterfaceItemIdentification for NSScrollView {}

extern_methods!(
    #[cfg(feature = "AppKit_NSScrollView")]
    unsafe impl NSScrollView {
        #[method_id(@__retain_semantics Init initWithFrame:)]
        pub unsafe fn initWithFrame(this: Option<Allocated<Self>>, frame_rect: NSRect) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Option<Allocated<Self>>,
            coder: &NSCoder,
        ) -> Option<Id<Self>>;

        #[method(frameSizeForContentSize:horizontalScrollerClass:verticalScrollerClass:borderType:controlSize:scrollerStyle:)]
        pub unsafe fn frameSizeForContentSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(
            c_size: NSSize,
            horizontal_scroller_class: Option<&Class>,
            vertical_scroller_class: Option<&Class>,
            r#type: NSBorderType,
            control_size: NSControlSize,
            scroller_style: NSScrollerStyle,
        ) -> NSSize;

        #[method(contentSizeForFrameSize:horizontalScrollerClass:verticalScrollerClass:borderType:controlSize:scrollerStyle:)]
        pub unsafe fn contentSizeForFrameSize_horizontalScrollerClass_verticalScrollerClass_borderType_controlSize_scrollerStyle(
            f_size: NSSize,
            horizontal_scroller_class: Option<&Class>,
            vertical_scroller_class: Option<&Class>,
            r#type: NSBorderType,
            control_size: NSControlSize,
            scroller_style: NSScrollerStyle,
        ) -> NSSize;

        #[deprecated = "Use +frameSizeForContentSize:horizontalScrollerClass:verticalScrollerClass:borderType:controlSize:scrollerStyle: instead"]
        #[method(frameSizeForContentSize:hasHorizontalScroller:hasVerticalScroller:borderType:)]
        pub unsafe fn frameSizeForContentSize_hasHorizontalScroller_hasVerticalScroller_borderType(
            c_size: NSSize,
            h_flag: bool,
            v_flag: bool,
            r#type: NSBorderType,
        ) -> NSSize;

        #[deprecated = "+contentSizeForFrameSize:horizontalScrollerClass:verticalScrollerClass:borderType:controlSize:scrollerStyle: instead"]
        #[method(contentSizeForFrameSize:hasHorizontalScroller:hasVerticalScroller:borderType:)]
        pub unsafe fn contentSizeForFrameSize_hasHorizontalScroller_hasVerticalScroller_borderType(
            f_size: NSSize,
            h_flag: bool,
            v_flag: bool,
            r#type: NSBorderType,
        ) -> NSSize;

        #[method(documentVisibleRect)]
        pub unsafe fn documentVisibleRect(&self) -> NSRect;

        #[method(contentSize)]
        pub unsafe fn contentSize(&self) -> NSSize;

        #[method_id(@__retain_semantics Other documentView)]
        pub unsafe fn documentView(&self) -> Option<Id<NSView>>;

        #[method(setDocumentView:)]
        pub unsafe fn setDocumentView(&self, document_view: Option<&NSView>);

        #[cfg(feature = "AppKit_NSClipView")]
        #[method_id(@__retain_semantics Other contentView)]
        pub unsafe fn contentView(&self) -> Id<NSClipView>;

        #[cfg(feature = "AppKit_NSClipView")]
        #[method(setContentView:)]
        pub unsafe fn setContentView(&self, content_view: &NSClipView);

        #[cfg(feature = "AppKit_NSCursor")]
        #[method_id(@__retain_semantics Other documentCursor)]
        pub unsafe fn documentCursor(&self) -> Option<Id<NSCursor>>;

        #[cfg(feature = "AppKit_NSCursor")]
        #[method(setDocumentCursor:)]
        pub unsafe fn setDocumentCursor(&self, document_cursor: Option<&NSCursor>);

        #[method(borderType)]
        pub unsafe fn borderType(&self) -> NSBorderType;

        #[method(setBorderType:)]
        pub unsafe fn setBorderType(&self, border_type: NSBorderType);

        #[cfg(feature = "AppKit_NSColor")]
        #[method_id(@__retain_semantics Other backgroundColor)]
        pub unsafe fn backgroundColor(&self) -> Id<NSColor>;

        #[cfg(feature = "AppKit_NSColor")]
        #[method(setBackgroundColor:)]
        pub unsafe fn setBackgroundColor(&self, background_color: &NSColor);

        #[method(drawsBackground)]
        pub unsafe fn drawsBackground(&self) -> bool;

        #[method(setDrawsBackground:)]
        pub unsafe fn setDrawsBackground(&self, draws_background: bool);

        #[method(hasVerticalScroller)]
        pub unsafe fn hasVerticalScroller(&self) -> bool;

        #[method(setHasVerticalScroller:)]
        pub unsafe fn setHasVerticalScroller(&self, has_vertical_scroller: bool);

        #[method(hasHorizontalScroller)]
        pub unsafe fn hasHorizontalScroller(&self) -> bool;

        #[method(setHasHorizontalScroller:)]
        pub unsafe fn setHasHorizontalScroller(&self, has_horizontal_scroller: bool);

        #[cfg(feature = "AppKit_NSScroller")]
        #[method_id(@__retain_semantics Other verticalScroller)]
        pub unsafe fn verticalScroller(&self) -> Option<Id<NSScroller>>;

        #[cfg(feature = "AppKit_NSScroller")]
        #[method(setVerticalScroller:)]
        pub unsafe fn setVerticalScroller(&self, vertical_scroller: Option<&NSScroller>);

        #[cfg(feature = "AppKit_NSScroller")]
        #[method_id(@__retain_semantics Other horizontalScroller)]
        pub unsafe fn horizontalScroller(&self) -> Option<Id<NSScroller>>;

        #[cfg(feature = "AppKit_NSScroller")]
        #[method(setHorizontalScroller:)]
        pub unsafe fn setHorizontalScroller(&self, horizontal_scroller: Option<&NSScroller>);

        #[method(autohidesScrollers)]
        pub unsafe fn autohidesScrollers(&self) -> bool;

        #[method(setAutohidesScrollers:)]
        pub unsafe fn setAutohidesScrollers(&self, autohides_scrollers: bool);

        #[method(horizontalLineScroll)]
        pub unsafe fn horizontalLineScroll(&self) -> CGFloat;

        #[method(setHorizontalLineScroll:)]
        pub unsafe fn setHorizontalLineScroll(&self, horizontal_line_scroll: CGFloat);

        #[method(verticalLineScroll)]
        pub unsafe fn verticalLineScroll(&self) -> CGFloat;

        #[method(setVerticalLineScroll:)]
        pub unsafe fn setVerticalLineScroll(&self, vertical_line_scroll: CGFloat);

        #[method(lineScroll)]
        pub unsafe fn lineScroll(&self) -> CGFloat;

        #[method(setLineScroll:)]
        pub unsafe fn setLineScroll(&self, line_scroll: CGFloat);

        #[method(horizontalPageScroll)]
        pub unsafe fn horizontalPageScroll(&self) -> CGFloat;

        #[method(setHorizontalPageScroll:)]
        pub unsafe fn setHorizontalPageScroll(&self, horizontal_page_scroll: CGFloat);

        #[method(verticalPageScroll)]
        pub unsafe fn verticalPageScroll(&self) -> CGFloat;

        #[method(setVerticalPageScroll:)]
        pub unsafe fn setVerticalPageScroll(&self, vertical_page_scroll: CGFloat);

        #[method(pageScroll)]
        pub unsafe fn pageScroll(&self) -> CGFloat;

        #[method(setPageScroll:)]
        pub unsafe fn setPageScroll(&self, page_scroll: CGFloat);

        #[method(scrollsDynamically)]
        pub unsafe fn scrollsDynamically(&self) -> bool;

        #[method(setScrollsDynamically:)]
        pub unsafe fn setScrollsDynamically(&self, scrolls_dynamically: bool);

        #[method(tile)]
        pub unsafe fn tile(&self);

        #[cfg(feature = "AppKit_NSClipView")]
        #[method(reflectScrolledClipView:)]
        pub unsafe fn reflectScrolledClipView(&self, c_view: &NSClipView);

        #[cfg(feature = "AppKit_NSEvent")]
        #[method(scrollWheel:)]
        pub unsafe fn scrollWheel(&self, event: &NSEvent);

        /**
          An NSScrollView's scrollerStyle determines the style of scrollers that it will use.  AppKit sets this property automatically at runtime, based on the user's "Show scroll bars" setting and (if relevant) the set of connected pointing devices and their configured scroll capabilities, as determined by [NSScroller preferredScrollerStyle].  Setting an NSScrollView's scrollerStyle sets the scrollerStyle of its horizontalScroller and verticalScroller to match the new value.  If the NSScrollView subsequently creates or is assigned a new horizontalScroller or verticalScroller, they will at that time be assigned the same scrollerStyle that was given to the NSScrollView.
        */
        #[method(scrollerStyle)]
        pub unsafe fn scrollerStyle(&self) -> NSScrollerStyle;

        /**
          An NSScrollView's scrollerStyle determines the style of scrollers that it will use.  AppKit sets this property automatically at runtime, based on the user's "Show scroll bars" setting and (if relevant) the set of connected pointing devices and their configured scroll capabilities, as determined by [NSScroller preferredScrollerStyle].  Setting an NSScrollView's scrollerStyle sets the scrollerStyle of its horizontalScroller and verticalScroller to match the new value.  If the NSScrollView subsequently creates or is assigned a new horizontalScroller or verticalScroller, they will at that time be assigned the same scrollerStyle that was given to the NSScrollView.
        */
        #[method(setScrollerStyle:)]
        pub unsafe fn setScrollerStyle(&self, scroller_style: NSScrollerStyle);

        /**
          Applicable only to ScrolViews that use Overlay scrollers.  Setting an NSScrollView's scrollerKnobStyle sets the knobStyle of its horizontalScroller and verticalScroller to match the new value.  If the NSScrollView subsequently creates or is assigned a new horizontalScroller or verticalScroller, they will at that time be assigned the same knobStyle that was given to the NSScrollView.
        */
        #[method(scrollerKnobStyle)]
        pub unsafe fn scrollerKnobStyle(&self) -> NSScrollerKnobStyle;

        /**
          Applicable only to ScrolViews that use Overlay scrollers.  Setting an NSScrollView's scrollerKnobStyle sets the knobStyle of its horizontalScroller and verticalScroller to match the new value.  If the NSScrollView subsequently creates or is assigned a new horizontalScroller or verticalScroller, they will at that time be assigned the same knobStyle that was given to the NSScrollView.
        */
        #[method(setScrollerKnobStyle:)]
        pub unsafe fn setScrollerKnobStyle(&self, scroller_knob_style: NSScrollerKnobStyle);

        #[method(flashScrollers)]
        pub unsafe fn flashScrollers(&self);

        /**
          NSScrollView can scroll its contents past its bounds to achieve an elastic effect. When set to NSScrollElasticityAutomatic, scrolling the horizontal axis beyond its document bounds only occurs if the document width is greater than the view width or, the vertical scroller is hidden and the horizontal scroller is visible. The default value is NSScrollElasticityAutomatic.
        */
        #[method(horizontalScrollElasticity)]
        pub unsafe fn horizontalScrollElasticity(&self) -> NSScrollElasticity;

        /**
          NSScrollView can scroll its contents past its bounds to achieve an elastic effect. When set to NSScrollElasticityAutomatic, scrolling the horizontal axis beyond its document bounds only occurs if the document width is greater than the view width or, the vertical scroller is hidden and the horizontal scroller is visible. The default value is NSScrollElasticityAutomatic.
        */
        #[method(setHorizontalScrollElasticity:)]
        pub unsafe fn setHorizontalScrollElasticity(
            &self,
            horizontal_scroll_elasticity: NSScrollElasticity,
        );

        /**
          NSScrollView can scroll its contents past its bounds to achieve an elastic effect. When set to NSScrollElasticityAuto, scrolling the vertical axis beyond its docment bounds occurs if any of the following are true: visible vertical scroller, content height greater than view height, horizontal scroller hidden
        */
        #[method(verticalScrollElasticity)]
        pub unsafe fn verticalScrollElasticity(&self) -> NSScrollElasticity;

        /**
          NSScrollView can scroll its contents past its bounds to achieve an elastic effect. When set to NSScrollElasticityAuto, scrolling the vertical axis beyond its docment bounds occurs if any of the following are true: visible vertical scroller, content height greater than view height, horizontal scroller hidden
        */
        #[method(setVerticalScrollElasticity:)]
        pub unsafe fn setVerticalScrollElasticity(
            &self,
            vertical_scroll_elasticity: NSScrollElasticity,
        );

        /**
          Some content is scrollable in both the horizontal and vertical axes, but is predominantly scrolled one axis at a time. Other content (such as a drawing canvas) should scroll freely in both axes. Traditionally this is not an issue with scroll wheels since they can only scroll in one direction at a time. With scroll balls and touch surfaces, it becomes more difficult to determine the user's intention. This property helps NSScrollView determine the user's intention by specifying the type of scrolling content. When set to YES, NSScrollView will only scroll in the predominate direction the user is scrolling. The default value is YES for apps build on 10.7; NO otherwise.
        */
        #[method(usesPredominantAxisScrolling)]
        pub unsafe fn usesPredominantAxisScrolling(&self) -> bool;

        /**
          Some content is scrollable in both the horizontal and vertical axes, but is predominantly scrolled one axis at a time. Other content (such as a drawing canvas) should scroll freely in both axes. Traditionally this is not an issue with scroll wheels since they can only scroll in one direction at a time. With scroll balls and touch surfaces, it becomes more difficult to determine the user's intention. This property helps NSScrollView determine the user's intention by specifying the type of scrolling content. When set to YES, NSScrollView will only scroll in the predominate direction the user is scrolling. The default value is YES for apps build on 10.7; NO otherwise.
        */
        #[method(setUsesPredominantAxisScrolling:)]
        pub unsafe fn setUsesPredominantAxisScrolling(&self, uses_predominant_axis_scrolling: bool);

        /**
          Allow the user to magnify the scrollview. Note: this does not prevent the developer from manually adjusting the magnification value. If magnification exceeds either the maximum or minimum limits for magnification, and allowsMagnification is YES, the scroll view temporarily animates the content magnification just past those limits before returning to them. The default value is NO.
        */
        #[method(allowsMagnification)]
        pub unsafe fn allowsMagnification(&self) -> bool;

        /**
          Allow the user to magnify the scrollview. Note: this does not prevent the developer from manually adjusting the magnification value. If magnification exceeds either the maximum or minimum limits for magnification, and allowsMagnification is YES, the scroll view temporarily animates the content magnification just past those limits before returning to them. The default value is NO.
        */
        #[method(setAllowsMagnification:)]
        pub unsafe fn setAllowsMagnification(&self, allows_magnification: bool);

        /**
          This value determines how much the content is currently scaled. To animate the magnification, use the object's animator. The default value is 1.0
        */
        #[method(magnification)]
        pub unsafe fn magnification(&self) -> CGFloat;

        /**
          This value determines how much the content is currently scaled. To animate the magnification, use the object's animator. The default value is 1.0
        */
        #[method(setMagnification:)]
        pub unsafe fn setMagnification(&self, magnification: CGFloat);

        /**
          This value determines how large the content can be magnified. It must be greater than or equal to the minimum magnification. The default value is 4.0.
        */
        #[method(maxMagnification)]
        pub unsafe fn maxMagnification(&self) -> CGFloat;

        /**
          This value determines how large the content can be magnified. It must be greater than or equal to the minimum magnification. The default value is 4.0.
        */
        #[method(setMaxMagnification:)]
        pub unsafe fn setMaxMagnification(&self, max_magnification: CGFloat);

        /**
          This value determines how small the content can be magnified. The default value is 0.25.
        */
        #[method(minMagnification)]
        pub unsafe fn minMagnification(&self) -> CGFloat;

        /**
          This value determines how small the content can be magnified. The default value is 0.25.
        */
        #[method(setMinMagnification:)]
        pub unsafe fn setMinMagnification(&self, min_magnification: CGFloat);

        #[method(magnifyToFitRect:)]
        pub unsafe fn magnifyToFitRect(&self, rect: NSRect);

        #[method(setMagnification:centeredAtPoint:)]
        pub unsafe fn setMagnification_centeredAtPoint(
            &self,
            magnification: CGFloat,
            point: NSPoint,
        );

        #[method(addFloatingSubview:forAxis:)]
        pub unsafe fn addFloatingSubview_forAxis(&self, view: &NSView, axis: NSEventGestureAxis);

        /**
           Automatically sets the scroll view's contentInsets property to account for any overlapping title bar. Defaults to YES.
        */
        #[method(automaticallyAdjustsContentInsets)]
        pub unsafe fn automaticallyAdjustsContentInsets(&self) -> bool;

        /**
           Automatically sets the scroll view's contentInsets property to account for any overlapping title bar. Defaults to YES.
        */
        #[method(setAutomaticallyAdjustsContentInsets:)]
        pub unsafe fn setAutomaticallyAdjustsContentInsets(
            &self,
            automatically_adjusts_content_insets: bool,
        );

        /**
          The distance that the sub views are inset from the enclosing scroll view during tiling. When contentInset equal to NSEdgeInsetsZero, traditional tiling is performed. That is, the rulers, headers, etc... are tiled with the contentView frame filling the remaining space. When contentInset is not equal to NSEdgeInsetsZero, the rulers, header, etc... are inset as specified. The contentView is is placed underneath these sibling views and is only inset by scroll view border and non-overlay scrollers.
        */
        #[method(contentInsets)]
        pub unsafe fn contentInsets(&self) -> NSEdgeInsets;

        /**
          The distance that the sub views are inset from the enclosing scroll view during tiling. When contentInset equal to NSEdgeInsetsZero, traditional tiling is performed. That is, the rulers, headers, etc... are tiled with the contentView frame filling the remaining space. When contentInset is not equal to NSEdgeInsetsZero, the rulers, header, etc... are inset as specified. The contentView is is placed underneath these sibling views and is only inset by scroll view border and non-overlay scrollers.
        */
        #[method(setContentInsets:)]
        pub unsafe fn setContentInsets(&self, content_insets: NSEdgeInsets);

        /**
          The distance the scrollers are inset from the edge of the scroll view.
        */
        #[method(scrollerInsets)]
        pub unsafe fn scrollerInsets(&self) -> NSEdgeInsets;

        /**
          The distance the scrollers are inset from the edge of the scroll view.
        */
        #[method(setScrollerInsets:)]
        pub unsafe fn setScrollerInsets(&self, scroller_insets: NSEdgeInsets);
    }
);

extern_static!(NSScrollViewWillStartLiveMagnifyNotification: &'static NSNotificationName);

extern_static!(NSScrollViewDidEndLiveMagnifyNotification: &'static NSNotificationName);

extern_static!(NSScrollViewWillStartLiveScrollNotification: &'static NSNotificationName);

extern_static!(NSScrollViewDidLiveScrollNotification: &'static NSNotificationName);

extern_static!(NSScrollViewDidEndLiveScrollNotification: &'static NSNotificationName);

extern_methods!(
    /// NSRulerSupport
    #[cfg(feature = "AppKit_NSScrollView")]
    unsafe impl NSScrollView {
        #[method(rulerViewClass)]
        pub unsafe fn rulerViewClass() -> Option<&'static Class>;

        #[method(setRulerViewClass:)]
        pub unsafe fn setRulerViewClass(ruler_view_class: Option<&Class>);

        #[method(rulersVisible)]
        pub unsafe fn rulersVisible(&self) -> bool;

        #[method(setRulersVisible:)]
        pub unsafe fn setRulersVisible(&self, rulers_visible: bool);

        #[method(hasHorizontalRuler)]
        pub unsafe fn hasHorizontalRuler(&self) -> bool;

        #[method(setHasHorizontalRuler:)]
        pub unsafe fn setHasHorizontalRuler(&self, has_horizontal_ruler: bool);

        #[method(hasVerticalRuler)]
        pub unsafe fn hasVerticalRuler(&self) -> bool;

        #[method(setHasVerticalRuler:)]
        pub unsafe fn setHasVerticalRuler(&self, has_vertical_ruler: bool);

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method_id(@__retain_semantics Other horizontalRulerView)]
        pub unsafe fn horizontalRulerView(&self) -> Option<Id<NSRulerView>>;

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method(setHorizontalRulerView:)]
        pub unsafe fn setHorizontalRulerView(&self, horizontal_ruler_view: Option<&NSRulerView>);

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method_id(@__retain_semantics Other verticalRulerView)]
        pub unsafe fn verticalRulerView(&self) -> Option<Id<NSRulerView>>;

        #[cfg(feature = "AppKit_NSRulerView")]
        #[method(setVerticalRulerView:)]
        pub unsafe fn setVerticalRulerView(&self, vertical_ruler_view: Option<&NSRulerView>);
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSScrollViewFindBarPosition {
        NSScrollViewFindBarPositionAboveHorizontalRuler = 0,
        NSScrollViewFindBarPositionAboveContent = 1,
        NSScrollViewFindBarPositionBelowContent = 2,
    }
);

extern_methods!(
    /// NSFindBarSupport
    #[cfg(feature = "AppKit_NSScrollView")]
    unsafe impl NSScrollView {
        #[method(findBarPosition)]
        pub unsafe fn findBarPosition(&self) -> NSScrollViewFindBarPosition;

        #[method(setFindBarPosition:)]
        pub unsafe fn setFindBarPosition(&self, find_bar_position: NSScrollViewFindBarPosition);
    }
);
