//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreData::*;
use crate::Foundation::*;

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSWorkspaceIconCreationOptions {
        NSExcludeQuickDrawElementsIconCreationOption = 1 << 1,
        NSExclude10_4ElementsIconCreationOption = 1 << 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSWorkspace")]
    pub struct NSWorkspace;

    #[cfg(feature = "AppKit_NSWorkspace")]
    unsafe impl ClassType for NSWorkspace {
        type Super = NSObject;
    }
);

#[cfg(feature = "AppKit_NSWorkspace")]
unsafe impl NSObjectProtocol for NSWorkspace {}

extern_methods!(
    #[cfg(feature = "AppKit_NSWorkspace")]
    unsafe impl NSWorkspace {
        /**
          Get the shared instance of NSWorkspace.  This method will create an instance of NSWorkspace if it has not been created yet.  You should not attempt to instantiate instances of NSWorkspace yourself, and you should not attempt to subclass NSWorkspace.
        */
        #[method_id(@__retain_semantics Other sharedWorkspace)]
        pub unsafe fn sharedWorkspace() -> Id<NSWorkspace>;

        #[cfg(feature = "Foundation_NSNotificationCenter")]
        /**
          Returns the NSNotificationCenter for this NSWorkspace.  All notifications in this header file must be registered on this notification center.  If you register on other notification centers, you will not receive the notifications.
        */
        #[method_id(@__retain_semantics Other notificationCenter)]
        pub unsafe fn notificationCenter(&self) -> Id<NSNotificationCenter>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method(openURL:)]
        pub unsafe fn openURL(&self, url: &NSURL) -> bool;

        #[cfg(all(
            feature = "AppKit_NSRunningApplication",
            feature = "AppKit_NSWorkspaceOpenConfiguration",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(openURL:configuration:completionHandler:)]
        pub unsafe fn openURL_configuration_completionHandler(
            &self,
            url: &NSURL,
            configuration: &NSWorkspaceOpenConfiguration,
            completion_handler: Option<&Block<(*mut NSRunningApplication, *mut NSError), ()>>,
        );

        #[cfg(all(
            feature = "AppKit_NSRunningApplication",
            feature = "AppKit_NSWorkspaceOpenConfiguration",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(openURLs:withApplicationAtURL:configuration:completionHandler:)]
        pub unsafe fn openURLs_withApplicationAtURL_configuration_completionHandler(
            &self,
            urls: &NSArray<NSURL>,
            application_url: &NSURL,
            configuration: &NSWorkspaceOpenConfiguration,
            completion_handler: Option<&Block<(*mut NSRunningApplication, *mut NSError), ()>>,
        );

        #[cfg(all(
            feature = "AppKit_NSRunningApplication",
            feature = "AppKit_NSWorkspaceOpenConfiguration",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(openApplicationAtURL:configuration:completionHandler:)]
        pub unsafe fn openApplicationAtURL_configuration_completionHandler(
            &self,
            application_url: &NSURL,
            configuration: &NSWorkspaceOpenConfiguration,
            completion_handler: Option<&Block<(*mut NSRunningApplication, *mut NSError), ()>>,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method(selectFile:inFileViewerRootedAtPath:)]
        pub unsafe fn selectFile_inFileViewerRootedAtPath(
            &self,
            full_path: Option<&NSString>,
            root_full_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURL"))]
        #[method(activateFileViewerSelectingURLs:)]
        pub unsafe fn activateFileViewerSelectingURLs(&self, file_ur_ls: &NSArray<NSURL>);

        #[cfg(feature = "Foundation_NSString")]
        #[method(showSearchResultsForQueryString:)]
        pub unsafe fn showSearchResultsForQueryString(&self, query_string: &NSString) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method(noteFileSystemChanged:)]
        pub unsafe fn noteFileSystemChanged_(&self, path: &NSString);

        #[cfg(feature = "Foundation_NSString")]
        #[method(isFilePackageAtPath:)]
        pub unsafe fn isFilePackageAtPath(&self, full_path: &NSString) -> bool;

        #[cfg(all(feature = "AppKit_NSImage", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other iconForFile:)]
        pub unsafe fn iconForFile(&self, full_path: &NSString) -> Id<NSImage>;

        #[cfg(all(
            feature = "AppKit_NSImage",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other iconForFiles:)]
        pub unsafe fn iconForFiles(&self, full_paths: &NSArray<NSString>) -> Option<Id<NSImage>>;

        #[cfg(all(feature = "AppKit_NSImage", feature = "Foundation_NSString"))]
        #[method(setIcon:forFile:options:)]
        pub unsafe fn setIcon_forFile_options(
            &self,
            image: Option<&NSImage>,
            full_path: &NSString,
            options: NSWorkspaceIconCreationOptions,
        ) -> bool;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        /**
          Get the array of file labels as NSStrings.  The file label index for a particular file is available as a property on the URL.  You may listen for NSWorkspaceDidChangeFileLabelsNotification to be notified when these change.
        */
        #[method_id(@__retain_semantics Other fileLabels)]
        pub unsafe fn fileLabels(&self) -> Id<NSArray<NSString>>;

        #[cfg(all(feature = "AppKit_NSColor", feature = "Foundation_NSArray"))]
        /**
          Get the corresponding array of file label colors.  This array has the same number of elements as fileLabels, and the color at a given index corresponds to the label at the same index . You may listen for NSWorkspaceDidChangeFileLabelsNotification to be notified when these change.
        */
        #[method_id(@__retain_semantics Other fileLabelColors)]
        pub unsafe fn fileLabelColors(&self) -> Id<NSArray<NSColor>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(recycleURLs:completionHandler:)]
        pub unsafe fn recycleURLs_completionHandler(
            &self,
            ur_ls: &NSArray<NSURL>,
            handler: Option<&Block<(NonNull<NSDictionary<NSURL, NSURL>>, *mut NSError), ()>>,
        );

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(duplicateURLs:completionHandler:)]
        pub unsafe fn duplicateURLs_completionHandler(
            &self,
            ur_ls: &NSArray<NSURL>,
            handler: Option<&Block<(NonNull<NSDictionary<NSURL, NSURL>>, *mut NSError), ()>>,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method(getFileSystemInfoForPath:isRemovable:isWritable:isUnmountable:description:type:)]
        pub unsafe fn getFileSystemInfoForPath_isRemovable_isWritable_isUnmountable_description_type(
            &self,
            full_path: &NSString,
            removable_flag: *mut Bool,
            writable_flag: *mut Bool,
            unmountable_flag: *mut Bool,
            description: Option<&mut Option<Id<NSString>>>,
            file_system_type: Option<&mut Option<Id<NSString>>>,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method(unmountAndEjectDeviceAtPath:)]
        pub unsafe fn unmountAndEjectDeviceAtPath(&self, path: &NSString) -> bool;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(unmountAndEjectDeviceAtURL:error:_)]
        pub unsafe fn unmountAndEjectDeviceAtURL_error(
            &self,
            url: &NSURL,
        ) -> Result<(), Id<NSError>>;

        #[method(extendPowerOffBy:)]
        pub unsafe fn extendPowerOffBy(&self, requested: NSInteger) -> NSInteger;

        #[method(hideOtherApplications)]
        pub unsafe fn hideOtherApplications(&self);

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForApplicationWithBundleIdentifier:)]
        pub unsafe fn URLForApplicationWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        ) -> Option<Id<NSURL>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other URLsForApplicationsWithBundleIdentifier:)]
        pub unsafe fn URLsForApplicationsWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        ) -> Id<NSArray<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other URLForApplicationToOpenURL:)]
        pub unsafe fn URLForApplicationToOpenURL(&self, url: &NSURL) -> Option<Id<NSURL>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLsForApplicationsToOpenURL:)]
        pub unsafe fn URLsForApplicationsToOpenURL(&self, url: &NSURL) -> Id<NSArray<NSURL>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(setDefaultApplicationAtURL:toOpenContentTypeOfFileAtURL:completionHandler:)]
        pub unsafe fn setDefaultApplicationAtURL_toOpenContentTypeOfFileAtURL_completionHandler(
            &self,
            application_url: &NSURL,
            url: &NSURL,
            completion_handler: Option<&Block<(*mut NSError,), ()>>,
        );

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method(setDefaultApplicationAtURL:toOpenURLsWithScheme:completionHandler:)]
        pub unsafe fn setDefaultApplicationAtURL_toOpenURLsWithScheme_completionHandler(
            &self,
            application_url: &NSURL,
            url_scheme: &NSString,
            completion_handler: Option<&Block<(*mut NSError,), ()>>,
        );

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(setDefaultApplicationAtURL:toOpenFileAtURL:completionHandler:)]
        pub unsafe fn setDefaultApplicationAtURL_toOpenFileAtURL_completionHandler(
            &self,
            application_url: &NSURL,
            url: &NSURL,
            completion_handler: Option<&Block<(*mut NSError,), ()>>,
        );

        #[cfg(feature = "AppKit_NSRunningApplication")]
        /**
          Gets the frontmost application, which is the application that will receive key events.  This is observable through KVO.
        */
        #[method_id(@__retain_semantics Other frontmostApplication)]
        pub unsafe fn frontmostApplication(&self) -> Option<Id<NSRunningApplication>>;

        #[cfg(feature = "AppKit_NSRunningApplication")]
        /**
          Gets the menu bar owning application, which is the application that currently owns and draws the menu bar. This is observable through KVO.
        */
        #[method_id(@__retain_semantics Other menuBarOwningApplication)]
        pub unsafe fn menuBarOwningApplication(&self) -> Option<Id<NSRunningApplication>>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSWorkspaceOpenConfiguration")]
    pub struct NSWorkspaceOpenConfiguration;

    #[cfg(feature = "AppKit_NSWorkspaceOpenConfiguration")]
    unsafe impl ClassType for NSWorkspaceOpenConfiguration {
        type Super = NSObject;
    }
);

#[cfg(feature = "AppKit_NSWorkspaceOpenConfiguration")]
unsafe impl NSObjectProtocol for NSWorkspaceOpenConfiguration {}

extern_methods!(
    #[cfg(feature = "AppKit_NSWorkspaceOpenConfiguration")]
    unsafe impl NSWorkspaceOpenConfiguration {
        #[method_id(@__retain_semantics Other configuration)]
        pub unsafe fn configuration() -> Id<Self>;

        /**
          Display user interface elements if needed, including errors and authentication. Defaults to YES.
        The completion handler will not be invoked until the user dismisses any such UI.
        Gatekeeper UI is not affected and will always be presented if needed.
        */
        #[method(promptsUserIfNeeded)]
        pub unsafe fn promptsUserIfNeeded(&self) -> bool;

        /**
          Display user interface elements if needed, including errors and authentication. Defaults to YES.
        The completion handler will not be invoked until the user dismisses any such UI.
        Gatekeeper UI is not affected and will always be presented if needed.
        */
        #[method(setPromptsUserIfNeeded:)]
        pub unsafe fn setPromptsUserIfNeeded(&self, prompts_user_if_needed: bool);

        /**
          Add the application instance or documents to the Recent Items menu. Defaults to YES.
        */
        #[method(addsToRecentItems)]
        pub unsafe fn addsToRecentItems(&self) -> bool;

        /**
          Add the application instance or documents to the Recent Items menu. Defaults to YES.
        */
        #[method(setAddsToRecentItems:)]
        pub unsafe fn setAddsToRecentItems(&self, adds_to_recent_items: bool);

        /**
          Bring the application instance to the foreground. Defaults to YES.
        */
        #[method(activates)]
        pub unsafe fn activates(&self) -> bool;

        /**
          Bring the application instance to the foreground. Defaults to YES.
        */
        #[method(setActivates:)]
        pub unsafe fn setActivates(&self, activates: bool);

        /**
          Hide the application instance. Defaults to NO.
        */
        #[method(hides)]
        pub unsafe fn hides(&self) -> bool;

        /**
          Hide the application instance. Defaults to NO.
        */
        #[method(setHides:)]
        pub unsafe fn setHides(&self, hides: bool);

        /**
          Hide other application instances. Defaults to NO.
        */
        #[method(hidesOthers)]
        pub unsafe fn hidesOthers(&self) -> bool;

        /**
          Hide other application instances. Defaults to NO.
        */
        #[method(setHidesOthers:)]
        pub unsafe fn setHidesOthers(&self, hides_others: bool);

        /**
          Print documents and URLs instead of opening them. Defaults to NO.
        */
        #[method(isForPrinting)]
        pub unsafe fn isForPrinting(&self) -> bool;

        /**
          Print documents and URLs instead of opening them. Defaults to NO.
        */
        #[method(setForPrinting:)]
        pub unsafe fn setForPrinting(&self, for_printing: bool);

        /**
          Ignore any running instance of the application and launch a new one. Defaults to NO (i.e. prefers to reuse a running instance). When createsNewApplicationInstance is YES, the value of allowsRunningApplicationSubstitution is not consulted.
        */
        #[method(createsNewApplicationInstance)]
        pub unsafe fn createsNewApplicationInstance(&self) -> bool;

        /**
          Ignore any running instance of the application and launch a new one. Defaults to NO (i.e. prefers to reuse a running instance). When createsNewApplicationInstance is YES, the value of allowsRunningApplicationSubstitution is not consulted.
        */
        #[method(setCreatesNewApplicationInstance:)]
        pub unsafe fn setCreatesNewApplicationInstance(
            &self,
            creates_new_application_instance: bool,
        );

        /**
          If an instance of an application is already running, but the running instance is at a different URL (and is capable of opening the provided URLs), use the running application. Defaults to YES. Set this to NO if you are letting the user select between specific versions of an application or letting them choose a particular installation.
        */
        #[method(allowsRunningApplicationSubstitution)]
        pub unsafe fn allowsRunningApplicationSubstitution(&self) -> bool;

        /**
          If an instance of an application is already running, but the running instance is at a different URL (and is capable of opening the provided URLs), use the running application. Defaults to YES. Set this to NO if you are letting the user select between specific versions of an application or letting them choose a particular installation.
        */
        #[method(setAllowsRunningApplicationSubstitution:)]
        pub unsafe fn setAllowsRunningApplicationSubstitution(
            &self,
            allows_running_application_substitution: bool,
        );

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        /**
          Command-line arguments to pass to a new application instance. Defaults to @[].
        Only applies when a new application instance is created.
        The path to the application instance is always automatically inserted as the first argument.
        If the calling process is sandboxed, the value of this property is ignored.
        */
        #[method_id(@__retain_semantics Other arguments)]
        pub unsafe fn arguments(&self) -> Id<NSArray<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        /**
          Command-line arguments to pass to a new application instance. Defaults to @[].
        Only applies when a new application instance is created.
        The path to the application instance is always automatically inserted as the first argument.
        If the calling process is sandboxed, the value of this property is ignored.
        */
        #[method(setArguments:)]
        pub unsafe fn setArguments(&self, arguments: &NSArray<NSString>);

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        /**
          Environment variables to set in a new application instance. Defaults to @{}.
        Only applies when a new application instance is created.
        Additional environment variables may be included by the system.
        */
        #[method_id(@__retain_semantics Other environment)]
        pub unsafe fn environment(&self) -> Id<NSDictionary<NSString, NSString>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        /**
          Environment variables to set in a new application instance. Defaults to @{}.
        Only applies when a new application instance is created.
        Additional environment variables may be included by the system.
        */
        #[method(setEnvironment:)]
        pub unsafe fn setEnvironment(&self, environment: &NSDictionary<NSString, NSString>);

        #[cfg(feature = "Foundation_NSAppleEventDescriptor")]
        /**
          The first NSAppleEventDescriptor to send to the new app. If an instance of the app is already running, this is sent to that app. Defaults to nil. When nil, a default apple event will be sent, if required.
        */
        #[method_id(@__retain_semantics Other appleEvent)]
        pub unsafe fn appleEvent(&self) -> Option<Id<NSAppleEventDescriptor>>;

        #[cfg(feature = "Foundation_NSAppleEventDescriptor")]
        /**
          The first NSAppleEventDescriptor to send to the new app. If an instance of the app is already running, this is sent to that app. Defaults to nil. When nil, a default apple event will be sent, if required.
        */
        #[method(setAppleEvent:)]
        pub unsafe fn setAppleEvent(&self, apple_event: Option<&NSAppleEventDescriptor>);

        /**
          Only open the provided URL if it is a valid universal link with an application configured to open it. If there is no application configured, or the user disabled using it to open the link, then the open will fail with an error. Defaults to NO.
        */
        #[method(requiresUniversalLinks)]
        pub unsafe fn requiresUniversalLinks(&self) -> bool;

        /**
          Only open the provided URL if it is a valid universal link with an application configured to open it. If there is no application configured, or the user disabled using it to open the link, then the open will fail with an error. Defaults to NO.
        */
        #[method(setRequiresUniversalLinks:)]
        pub unsafe fn setRequiresUniversalLinks(&self, requires_universal_links: bool);
    }
);

typed_enum!(
    pub type NSWorkspaceDesktopImageOptionKey = NSString;
);

extern_static!(NSWorkspaceDesktopImageScalingKey: &'static NSWorkspaceDesktopImageOptionKey);

extern_static!(NSWorkspaceDesktopImageAllowClippingKey: &'static NSWorkspaceDesktopImageOptionKey);

extern_static!(NSWorkspaceDesktopImageFillColorKey: &'static NSWorkspaceDesktopImageOptionKey);

extern_methods!(
    /**
      Desktop images
    */
    /// NSDesktopImages
    #[cfg(feature = "AppKit_NSWorkspace")]
    unsafe impl NSWorkspace {
        #[cfg(all(
            feature = "AppKit_NSScreen",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(setDesktopImageURL:forScreen:options:error:_)]
        pub unsafe fn setDesktopImageURL_forScreen_options_error(
            &self,
            url: &NSURL,
            screen: &NSScreen,
            options: &NSDictionary<NSWorkspaceDesktopImageOptionKey, Object>,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(feature = "AppKit_NSScreen", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other desktopImageURLForScreen:)]
        pub unsafe fn desktopImageURLForScreen(&self, screen: &NSScreen) -> Option<Id<NSURL>>;

        #[cfg(all(feature = "AppKit_NSScreen", feature = "Foundation_NSDictionary"))]
        #[method_id(@__retain_semantics Other desktopImageOptionsForScreen:)]
        pub unsafe fn desktopImageOptionsForScreen(
            &self,
            screen: &NSScreen,
        ) -> Option<Id<NSDictionary<NSWorkspaceDesktopImageOptionKey, Object>>>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSWorkspaceAuthorizationType {
        NSWorkspaceAuthorizationTypeCreateSymbolicLink = 0,
        NSWorkspaceAuthorizationTypeSetAttributes = 1,
        NSWorkspaceAuthorizationTypeReplaceFile = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AppKit_NSWorkspaceAuthorization")]
    pub struct NSWorkspaceAuthorization;

    #[cfg(feature = "AppKit_NSWorkspaceAuthorization")]
    unsafe impl ClassType for NSWorkspaceAuthorization {
        type Super = NSObject;
    }
);

#[cfg(feature = "AppKit_NSWorkspaceAuthorization")]
unsafe impl NSObjectProtocol for NSWorkspaceAuthorization {}

extern_methods!(
    #[cfg(feature = "AppKit_NSWorkspaceAuthorization")]
    unsafe impl NSWorkspaceAuthorization {}
);

extern_methods!(
    /// NSWorkspaceAuthorization
    #[cfg(feature = "AppKit_NSWorkspace")]
    unsafe impl NSWorkspace {
        #[cfg(all(
            feature = "AppKit_NSWorkspaceAuthorization",
            feature = "Foundation_NSError"
        ))]
        #[method(requestAuthorizationOfType:completionHandler:)]
        pub unsafe fn requestAuthorizationOfType_completionHandler(
            &self,
            r#type: NSWorkspaceAuthorizationType,
            completion_handler: &Block<(*mut NSWorkspaceAuthorization, *mut NSError), ()>,
        );
    }
);

extern_methods!(
    /// NSWorkspaceAuthorization
    #[cfg(feature = "Foundation_NSFileManager")]
    unsafe impl NSFileManager {
        #[cfg(feature = "AppKit_NSWorkspaceAuthorization")]
        #[method_id(@__retain_semantics Other fileManagerWithAuthorization:)]
        pub unsafe fn fileManagerWithAuthorization(
            authorization: &NSWorkspaceAuthorization,
        ) -> Id<Self>;
    }
);

extern_static!(NSWorkspaceApplicationKey: &'static NSString);

extern_static!(NSWorkspaceWillLaunchApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidLaunchApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidTerminateApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidHideApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidUnhideApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidActivateApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidDeactivateApplicationNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceVolumeLocalizedNameKey: &'static NSString);

extern_static!(NSWorkspaceVolumeURLKey: &'static NSString);

extern_static!(NSWorkspaceVolumeOldLocalizedNameKey: &'static NSString);

extern_static!(NSWorkspaceVolumeOldURLKey: &'static NSString);

extern_static!(NSWorkspaceDidMountNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidUnmountNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceWillUnmountNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidRenameVolumeNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceWillPowerOffNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceWillSleepNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidWakeNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceScreensDidSleepNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceScreensDidWakeNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceSessionDidBecomeActiveNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceSessionDidResignActiveNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceDidChangeFileLabelsNotification: &'static NSNotificationName);

extern_static!(NSWorkspaceActiveSpaceDidChangeNotification: &'static NSNotificationName);

typed_enum!(
    pub type NSWorkspaceFileOperationName = NSString;
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSWorkspaceLaunchOptions {
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setForPrinting:YES] instead."]
        NSWorkspaceLaunchAndPrint = 0x00000002,
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setPromptsUserIfNeeded:YES] instead."]
        NSWorkspaceLaunchWithErrorPresentation = 0x00000040,
        #[deprecated = "This option does nothing."]
        NSWorkspaceLaunchInhibitingBackgroundOnly = 0x00000080,
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setAddsToRecentItems:YES] instead."]
        NSWorkspaceLaunchWithoutAddingToRecents = 0x00000100,
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setActivates:NO] instead."]
        NSWorkspaceLaunchWithoutActivation = 0x00000200,
        #[deprecated = "When using NSWorkspaceOpenConfiguration, all launches are asynchronous."]
        NSWorkspaceLaunchAsync = 0x00010000,
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setCreatesNewApplicationInstance:YES] instead."]
        NSWorkspaceLaunchNewInstance = 0x00080000,
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setHides:YES] instead."]
        NSWorkspaceLaunchAndHide = 0x00100000,
        #[deprecated = "Use -[NSWorkspaceOpenConfiguration setHidesOthers:YES] instead."]
        NSWorkspaceLaunchAndHideOthers = 0x00200000,
        #[deprecated = "Use NSWorkspaceOpenConfiguration instead."]
        NSWorkspaceLaunchDefault = NSWorkspaceLaunchAsync,
        #[deprecated = "The Classic environment is no longer supported."]
        NSWorkspaceLaunchAllowingClassicStartup = 0x00020000,
        #[deprecated = "The Classic environment is no longer supported."]
        NSWorkspaceLaunchPreferringClassic = 0x00040000,
    }
);

typed_enum!(
    pub type NSWorkspaceLaunchConfigurationKey = NSString;
);

extern_static!(
    NSWorkspaceLaunchConfigurationAppleEvent: &'static NSWorkspaceLaunchConfigurationKey
);

extern_static!(NSWorkspaceLaunchConfigurationArguments: &'static NSWorkspaceLaunchConfigurationKey);

extern_static!(
    NSWorkspaceLaunchConfigurationEnvironment: &'static NSWorkspaceLaunchConfigurationKey
);

extern_static!(
    NSWorkspaceLaunchConfigurationArchitecture: &'static NSWorkspaceLaunchConfigurationKey
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "AppKit_NSWorkspace")]
    unsafe impl NSWorkspace {
        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace openURL:] instead."]
        #[method(openFile:)]
        pub unsafe fn openFile(&self, full_path: &NSString) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[method(openFile:withApplication:)]
        pub unsafe fn openFile_withApplication(
            &self,
            full_path: &NSString,
            app_name: Option<&NSString>,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[method(openFile:withApplication:andDeactivate:)]
        pub unsafe fn openFile_withApplication_andDeactivate(
            &self,
            full_path: &NSString,
            app_name: Option<&NSString>,
            flag: bool,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[method(launchApplication:)]
        pub unsafe fn launchApplication(&self, app_name: &NSString) -> bool;

        #[cfg(all(
            feature = "AppKit_NSRunningApplication",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[method_id(@__retain_semantics Other launchApplicationAtURL:options:configuration:error:_)]
        pub unsafe fn launchApplicationAtURL_options_configuration_error(
            &self,
            url: &NSURL,
            options: NSWorkspaceLaunchOptions,
            configuration: &NSDictionary<NSWorkspaceLaunchConfigurationKey, Object>,
        ) -> Result<Id<NSRunningApplication>, Id<NSError>>;

        #[cfg(all(
            feature = "AppKit_NSRunningApplication",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[deprecated = "Use -[NSWorkspace openURL:configuration:completionHandler:] instead."]
        #[method_id(@__retain_semantics Other openURL:options:configuration:error:_)]
        pub unsafe fn openURL_options_configuration_error(
            &self,
            url: &NSURL,
            options: NSWorkspaceLaunchOptions,
            configuration: &NSDictionary<NSWorkspaceLaunchConfigurationKey, Object>,
        ) -> Result<Id<NSRunningApplication>, Id<NSError>>;

        #[cfg(all(
            feature = "AppKit_NSRunningApplication",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[method_id(@__retain_semantics Other openURLs:withApplicationAtURL:options:configuration:error:_)]
        pub unsafe fn openURLs_withApplicationAtURL_options_configuration_error(
            &self,
            urls: &NSArray<NSURL>,
            application_url: &NSURL,
            options: NSWorkspaceLaunchOptions,
            configuration: &NSDictionary<NSWorkspaceLaunchConfigurationKey, Object>,
        ) -> Result<Id<NSRunningApplication>, Id<NSError>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[method(launchApplication:showIcon:autolaunch:)]
        pub unsafe fn launchApplication_showIcon_autolaunch(
            &self,
            app_name: &NSString,
            show_icon: bool,
            autolaunch: bool,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace URLForApplicationWithBundleIdentifier:] instead."]
        #[method_id(@__retain_semantics Other fullPathForApplication:)]
        pub unsafe fn fullPathForApplication(&self, app_name: &NSString) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace URLForApplicationWithBundleIdentifier:] instead."]
        #[method_id(@__retain_semantics Other absolutePathForAppBundleWithIdentifier:)]
        pub unsafe fn absolutePathForAppBundleWithIdentifier(
            &self,
            bundle_identifier: &NSString,
        ) -> Option<Id<NSString>>;

        #[cfg(all(
            feature = "Foundation_NSAppleEventDescriptor",
            feature = "Foundation_NSNumber",
            feature = "Foundation_NSString"
        ))]
        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[method(launchAppWithBundleIdentifier:options:additionalEventParamDescriptor:launchIdentifier:)]
        pub unsafe fn launchAppWithBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifier(
            &self,
            bundle_identifier: &NSString,
            options: NSWorkspaceLaunchOptions,
            descriptor: Option<&NSAppleEventDescriptor>,
            identifier: Option<&mut Option<Id<NSNumber>>>,
        ) -> bool;

        #[cfg(all(
            feature = "Foundation_NSAppleEventDescriptor",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSNumber",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[method(openURLs:withAppBundleIdentifier:options:additionalEventParamDescriptor:launchIdentifiers:)]
        pub unsafe fn openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers(
            &self,
            urls: &NSArray<NSURL>,
            bundle_identifier: Option<&NSString>,
            options: NSWorkspaceLaunchOptions,
            descriptor: Option<&NSAppleEventDescriptor>,
            identifiers: Option<&mut Option<Id<NSArray<NSNumber>>>>,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated]
        #[method(openTempFile:)]
        pub unsafe fn openTempFile(&self, full_path: &NSString) -> bool;

        #[deprecated]
        #[method(findApplications)]
        pub unsafe fn findApplications(&self);

        #[deprecated]
        #[method(noteUserDefaultsChanged)]
        pub unsafe fn noteUserDefaultsChanged(&self);

        #[cfg(feature = "AppKit_NSImage")]
        #[deprecated]
        #[method(slideImage:from:to:)]
        pub unsafe fn slideImage_from_to(
            &self,
            image: &NSImage,
            from_point: NSPoint,
            to_point: NSPoint,
        );

        #[deprecated]
        #[method(checkForRemovableMedia)]
        pub unsafe fn checkForRemovableMedia(&self);

        #[deprecated]
        #[method(noteFileSystemChanged)]
        pub unsafe fn noteFileSystemChanged(&self);

        #[deprecated]
        #[method(fileSystemChanged)]
        pub unsafe fn fileSystemChanged(&self) -> bool;

        #[deprecated]
        #[method(userDefaultsChanged)]
        pub unsafe fn userDefaultsChanged(&self) -> bool;

        #[cfg(feature = "Foundation_NSArray")]
        #[deprecated]
        #[method_id(@__retain_semantics Other mountNewRemovableMedia)]
        pub unsafe fn mountNewRemovableMedia(&self) -> Option<Id<NSArray>>;

        #[cfg(feature = "Foundation_NSDictionary")]
        #[deprecated = "Use -[NSWorkspace frontmostApplication] instead."]
        #[method_id(@__retain_semantics Other activeApplication)]
        pub unsafe fn activeApplication(&self) -> Option<Id<NSDictionary>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[deprecated = "Use -[NSFileManager mountedVolumeURLsIncludingResourceValuesForKeys:options:] instead."]
        #[method_id(@__retain_semantics Other mountedLocalVolumePaths)]
        pub unsafe fn mountedLocalVolumePaths(&self) -> Option<Id<NSArray>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[deprecated = "Use -[NSFileManager mountedVolumeURLsIncludingResourceValuesForKeys:options:] instead."]
        #[method_id(@__retain_semantics Other mountedRemovableMedia)]
        pub unsafe fn mountedRemovableMedia(&self) -> Option<Id<NSArray>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[deprecated = "Use -[NSWorkspace runningApplications] instead."]
        #[method_id(@__retain_semantics Other launchedApplications)]
        pub unsafe fn launchedApplications(&self) -> Option<Id<NSArray>>;

        #[cfg(all(
            feature = "AppKit_NSImage",
            feature = "AppKit_NSView",
            feature = "Foundation_NSString"
        ))]
        #[deprecated = "Use -[NSWorkspace openURL:] instead."]
        #[method(openFile:fromImage:at:inView:)]
        pub unsafe fn openFile_fromImage_at_inView(
            &self,
            full_path: &NSString,
            image: Option<&NSImage>,
            point: NSPoint,
            view: Option<&NSView>,
        ) -> bool;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[deprecated]
        #[method(performFileOperation:source:destination:files:tag:)]
        pub unsafe fn performFileOperation_source_destination_files_tag(
            &self,
            operation: &NSWorkspaceFileOperationName,
            source: &NSString,
            destination: &NSString,
            files: &NSArray,
            tag: *mut NSInteger,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[NSWorkspace URLForApplicationToOpenURL:] to get the URL of an application that will open a given item, or -[NSURL getResourceValue:forKey:error:] with NSURLContentTypeKey to get the type of the given item."]
        #[method(getInfoForFile:application:type:)]
        pub unsafe fn getInfoForFile_application_type(
            &self,
            full_path: &NSString,
            app_name: Option<&mut Option<Id<NSString>>>,
            r#type: Option<&mut Option<Id<NSString>>>,
        ) -> bool;

        #[cfg(all(feature = "AppKit_NSImage", feature = "Foundation_NSString"))]
        #[deprecated = "Use -[NSWorkspace iconForContentType:] instead."]
        #[method_id(@__retain_semantics Other iconForFileType:)]
        pub unsafe fn iconForFileType(&self, file_type: &NSString) -> Id<NSImage>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSString"))]
        #[deprecated = "Use -[NSURL getResourceValue:forKey:error:] with NSURLContentTypeKey instead."]
        #[method_id(@__retain_semantics Other typeOfFile:error:_)]
        pub unsafe fn typeOfFile_error(
            &self,
            absolute_file_path: &NSString,
        ) -> Result<Id<NSString>, Id<NSError>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use UTType.localizedDescription instead."]
        #[method_id(@__retain_semantics Other localizedDescriptionForType:)]
        pub unsafe fn localizedDescriptionForType(
            &self,
            type_name: &NSString,
        ) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use UTType.preferredFilenameExtension instead."]
        #[method_id(@__retain_semantics Other preferredFilenameExtensionForType:)]
        pub unsafe fn preferredFilenameExtensionForType(
            &self,
            type_name: &NSString,
        ) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use +[UTType typesWithTag:tagClass:conformingToType:] to get a list of candidate types, then check if the input type conforms to any of them."]
        #[method(filenameExtension:isValidForType:)]
        pub unsafe fn filenameExtension_isValidForType(
            &self,
            filename_extension: &NSString,
            type_name: &NSString,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use -[UTType conformsToType:] instead."]
        #[method(type:conformsToType:)]
        pub unsafe fn type_conformsToType(
            &self,
            first_type_name: &NSString,
            second_type_name: &NSString,
        ) -> bool;
    }
);

extern_static!(NSWorkspaceMoveOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceCopyOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceLinkOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceCompressOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceDecompressOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceEncryptOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceDecryptOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceDestroyOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceRecycleOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceDuplicateOperation: &'static NSWorkspaceFileOperationName);

extern_static!(NSWorkspaceDidPerformFileOperationNotification: &'static NSNotificationName);

extern_static!(NSPlainFileType: &'static NSString);

extern_static!(NSDirectoryFileType: &'static NSString);

extern_static!(NSApplicationFileType: &'static NSString);

extern_static!(NSFilesystemFileType: &'static NSString);

extern_static!(NSShellCommandFileType: &'static NSString);
