//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreAnimation::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CoreAnimation_CATransformLayer")]
    /**
      "Transform" layers are used to create true 3D layer hierarchies.

     Unlike normal layers, transform layers do not project (i.e. flatten)
     their sublayers into the plane at Z=0. However due to this neither
     do they support many features of the 2D compositing model:

     - only their sublayers are rendered (i.e. no background, contents,
       border)

     - filters, backgroundFilters, compositingFilter, mask, masksToBounds
       and shadow related properties are ignored (they all assume 2D
       image processing of the projected layer)

     - opacity is applied to each sublayer individually, i.e. the transform
       layer does not form a compositing group.

     Also, the -hitTest: method should never be called on transform
     layers (they do not have a 2D coordinate space into which to map the
     supplied point.) CALayer will pass over transform layers directly to
     their sublayers, applying the effects of the transform layer's
     geometry when hit-testing each sublayer.
    */
    pub struct CATransformLayer;

    #[cfg(feature = "CoreAnimation_CATransformLayer")]
    unsafe impl ClassType for CATransformLayer {
        #[inherits(NSObject)]
        type Super = CALayer;
    }
);

#[cfg(feature = "CoreAnimation_CATransformLayer")]
/**
  "Transform" layers are used to create true 3D layer hierarchies.

 Unlike normal layers, transform layers do not project (i.e. flatten)
 their sublayers into the plane at Z=0. However due to this neither
 do they support many features of the 2D compositing model:

 - only their sublayers are rendered (i.e. no background, contents,
   border)

 - filters, backgroundFilters, compositingFilter, mask, masksToBounds
   and shadow related properties are ignored (they all assume 2D
   image processing of the projected layer)

 - opacity is applied to each sublayer individually, i.e. the transform
   layer does not form a compositing group.

 Also, the -hitTest: method should never be called on transform
 layers (they do not have a 2D coordinate space into which to map the
 supplied point.) CALayer will pass over transform layers directly to
 their sublayers, applying the effects of the transform layer's
 geometry when hit-testing each sublayer.
*/
unsafe impl CAMediaTiming for CATransformLayer {}

#[cfg(feature = "CoreAnimation_CATransformLayer")]
/**
  "Transform" layers are used to create true 3D layer hierarchies.

 Unlike normal layers, transform layers do not project (i.e. flatten)
 their sublayers into the plane at Z=0. However due to this neither
 do they support many features of the 2D compositing model:

 - only their sublayers are rendered (i.e. no background, contents,
   border)

 - filters, backgroundFilters, compositingFilter, mask, masksToBounds
   and shadow related properties are ignored (they all assume 2D
   image processing of the projected layer)

 - opacity is applied to each sublayer individually, i.e. the transform
   layer does not form a compositing group.

 Also, the -hitTest: method should never be called on transform
 layers (they do not have a 2D coordinate space into which to map the
 supplied point.) CALayer will pass over transform layers directly to
 their sublayers, applying the effects of the transform layer's
 geometry when hit-testing each sublayer.
*/
unsafe impl NSCoding for CATransformLayer {}

#[cfg(feature = "CoreAnimation_CATransformLayer")]
/**
  "Transform" layers are used to create true 3D layer hierarchies.

 Unlike normal layers, transform layers do not project (i.e. flatten)
 their sublayers into the plane at Z=0. However due to this neither
 do they support many features of the 2D compositing model:

 - only their sublayers are rendered (i.e. no background, contents,
   border)

 - filters, backgroundFilters, compositingFilter, mask, masksToBounds
   and shadow related properties are ignored (they all assume 2D
   image processing of the projected layer)

 - opacity is applied to each sublayer individually, i.e. the transform
   layer does not form a compositing group.

 Also, the -hitTest: method should never be called on transform
 layers (they do not have a 2D coordinate space into which to map the
 supplied point.) CALayer will pass over transform layers directly to
 their sublayers, applying the effects of the transform layer's
 geometry when hit-testing each sublayer.
*/
unsafe impl NSObjectProtocol for CATransformLayer {}

#[cfg(feature = "CoreAnimation_CATransformLayer")]
/**
  "Transform" layers are used to create true 3D layer hierarchies.

 Unlike normal layers, transform layers do not project (i.e. flatten)
 their sublayers into the plane at Z=0. However due to this neither
 do they support many features of the 2D compositing model:

 - only their sublayers are rendered (i.e. no background, contents,
   border)

 - filters, backgroundFilters, compositingFilter, mask, masksToBounds
   and shadow related properties are ignored (they all assume 2D
   image processing of the projected layer)

 - opacity is applied to each sublayer individually, i.e. the transform
   layer does not form a compositing group.

 Also, the -hitTest: method should never be called on transform
 layers (they do not have a 2D coordinate space into which to map the
 supplied point.) CALayer will pass over transform layers directly to
 their sublayers, applying the effects of the transform layer's
 geometry when hit-testing each sublayer.
*/
unsafe impl NSSecureCoding for CATransformLayer {}

extern_methods!(
    /**
      "Transform" layers are used to create true 3D layer hierarchies.

     Unlike normal layers, transform layers do not project (i.e. flatten)
     their sublayers into the plane at Z=0. However due to this neither
     do they support many features of the 2D compositing model:

     - only their sublayers are rendered (i.e. no background, contents,
       border)

     - filters, backgroundFilters, compositingFilter, mask, masksToBounds
       and shadow related properties are ignored (they all assume 2D
       image processing of the projected layer)

     - opacity is applied to each sublayer individually, i.e. the transform
       layer does not form a compositing group.

     Also, the -hitTest: method should never be called on transform
     layers (they do not have a 2D coordinate space into which to map the
     supplied point.) CALayer will pass over transform layers directly to
     their sublayers, applying the effects of the transform layer's
     geometry when hit-testing each sublayer.
    */
    #[cfg(feature = "CoreAnimation_CATransformLayer")]
    unsafe impl CATransformLayer {}
);

extern_methods!(
    /// Methods declared on superclass `CALayer`
    /**
      "Transform" layers are used to create true 3D layer hierarchies.

     Unlike normal layers, transform layers do not project (i.e. flatten)
     their sublayers into the plane at Z=0. However due to this neither
     do they support many features of the 2D compositing model:

     - only their sublayers are rendered (i.e. no background, contents,
       border)

     - filters, backgroundFilters, compositingFilter, mask, masksToBounds
       and shadow related properties are ignored (they all assume 2D
       image processing of the projected layer)

     - opacity is applied to each sublayer individually, i.e. the transform
       layer does not form a compositing group.

     Also, the -hitTest: method should never be called on transform
     layers (they do not have a 2D coordinate space into which to map the
     supplied point.) CALayer will pass over transform layers directly to
     their sublayers, applying the effects of the transform layer's
     geometry when hit-testing each sublayer.
    */
    #[cfg(feature = "CoreAnimation_CATransformLayer")]
    unsafe impl CATransformLayer {
        #[method_id(@__retain_semantics Other layer)]
        pub unsafe fn layer() -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithLayer:)]
        pub unsafe fn initWithLayer(this: Option<Allocated<Self>>, layer: &Object) -> Id<Self>;
    }
);
