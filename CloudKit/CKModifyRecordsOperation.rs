//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CloudKit::*;
use crate::CoreLocation::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    /**
      @enum CKRecordSavePolicy

      @constant CKRecordSaveIfServerRecordUnchanged
      @discussion Locally-edited keys are sent to the server.
      If the record on the server has been modified, fail the write and return an error. A CKShare's participants array is always treated as @c CKRecordSaveIfServerRecordUnchanged, regardless of the @c savePolicy of the operation that modifies the share.

      @constant CKRecordSaveChangedKeys
      @discussion Locally-edited keys are written to the server.
      Any previously committed change to the server, for example by other devices, will be overwritten by the locally changed value.
      This policy does not compare the record change tag and therefore will never return @c CKErrorServerRecordChanged

      @constant CKRecordSaveAllKeys
      @discussion All local keys are written to the server.
      Any previously committed change to the server, for example by other devices, will be overwritten by the local value.
      Keys present only on the server remain unchanged.
      There are two common ways in which a server record will contain keys not present locally:
      1 - Since you've fetched this record, another client has added a new key to the record.
      2 - The presence of @c desiredKeys on the fetch / query that returned this record meant that only a portion of the record's keys were downloaded.
      This policy does not compare the record change tag and therefore will never return @c CKErrorServerRecordChanged.
    */
    pub enum CKRecordSavePolicy {
        CKRecordSaveIfServerRecordUnchanged = 0,
        CKRecordSaveChangedKeys = 1,
        CKRecordSaveAllKeys = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CloudKit_CKModifyRecordsOperation")]
    pub struct CKModifyRecordsOperation;

    #[cfg(feature = "CloudKit_CKModifyRecordsOperation")]
    unsafe impl ClassType for CKModifyRecordsOperation {
        #[inherits(CKOperation, NSOperation, NSObject)]
        type Super = CKDatabaseOperation;
    }
);

#[cfg(feature = "CloudKit_CKModifyRecordsOperation")]
unsafe impl NSObjectProtocol for CKModifyRecordsOperation {}

extern_methods!(
    #[cfg(feature = "CloudKit_CKModifyRecordsOperation")]
    unsafe impl CKModifyRecordsOperation {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(all(
            feature = "CloudKit_CKRecord",
            feature = "CloudKit_CKRecordID",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Init initWithRecordsToSave:recordIDsToDelete:)]
        pub unsafe fn initWithRecordsToSave_recordIDsToDelete(
            this: Option<Allocated<Self>>,
            records: Option<&NSArray<CKRecord>>,
            record_i_ds: Option<&NSArray<CKRecordID>>,
        ) -> Id<Self>;

        #[cfg(all(feature = "CloudKit_CKRecord", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other recordsToSave)]
        pub unsafe fn recordsToSave(&self) -> Option<Id<NSArray<CKRecord>>>;

        #[cfg(all(feature = "CloudKit_CKRecord", feature = "Foundation_NSArray"))]
        #[method(setRecordsToSave:)]
        pub unsafe fn setRecordsToSave(&self, records_to_save: Option<&NSArray<CKRecord>>);

        #[cfg(all(feature = "CloudKit_CKRecordID", feature = "Foundation_NSArray"))]
        #[method_id(@__retain_semantics Other recordIDsToDelete)]
        pub unsafe fn recordIDsToDelete(&self) -> Option<Id<NSArray<CKRecordID>>>;

        #[cfg(all(feature = "CloudKit_CKRecordID", feature = "Foundation_NSArray"))]
        #[method(setRecordIDsToDelete:)]
        pub unsafe fn setRecordIDsToDelete(
            &self,
            record_i_ds_to_delete: Option<&NSArray<CKRecordID>>,
        );

        /**
          The default value is @c CKRecordSaveIfServerRecordUnchanged.
        */
        #[method(savePolicy)]
        pub unsafe fn savePolicy(&self) -> CKRecordSavePolicy;

        /**
          The default value is @c CKRecordSaveIfServerRecordUnchanged.
        */
        #[method(setSavePolicy:)]
        pub unsafe fn setSavePolicy(&self, save_policy: CKRecordSavePolicy);

        #[cfg(feature = "Foundation_NSData")]
        /**
          @discussion This property is kept by the server to identify the last known request from this client.
          Multiple requests from the client with the same change token will be ignored by the server.
        */
        #[method_id(@__retain_semantics Other clientChangeTokenData)]
        pub unsafe fn clientChangeTokenData(&self) -> Option<Id<NSData>>;

        #[cfg(feature = "Foundation_NSData")]
        /**
          @discussion This property is kept by the server to identify the last known request from this client.
          Multiple requests from the client with the same change token will be ignored by the server.
        */
        #[method(setClientChangeTokenData:)]
        pub unsafe fn setClientChangeTokenData(&self, client_change_token_data: Option<&NSData>);

        /**
          @abstract  Determines whether the batch should fail atomically or not.

          @discussion YES by default.
          Server-side write atomicity is only enforced on zones that have @c CKRecordZoneCapabilityAtomic.
          If @c isAtomic is YES, client-side checks are enforced regardless of the zone's capabilities.  (For example, if a record is malformed, and cannot be sent to the server, the client will forcibly fail all other records-to-be-modified in that zone)
        */
        #[method(atomic)]
        pub unsafe fn atomic(&self) -> bool;

        /**
          @abstract  Determines whether the batch should fail atomically or not.

          @discussion YES by default.
          Server-side write atomicity is only enforced on zones that have @c CKRecordZoneCapabilityAtomic.
          If @c isAtomic is YES, client-side checks are enforced regardless of the zone's capabilities.  (For example, if a record is malformed, and cannot be sent to the server, the client will forcibly fail all other records-to-be-modified in that zone)
        */
        #[method(setAtomic:)]
        pub unsafe fn setAtomic(&self, atomic: bool);

        #[cfg(feature = "CloudKit_CKRecord")]
        /**
          @abstract Indicates the progress for each record.

          @discussion This method is called at least once with a progress of 1.0 for every record. Intermediate progress is only reported for records that contain assets.
          It is possible for progress to regress when a retry is automatically triggered.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(perRecordProgressBlock)]
        pub unsafe fn perRecordProgressBlock(
            &self,
        ) -> *mut Block<(NonNull<CKRecord>, c_double), ()>;

        #[cfg(feature = "CloudKit_CKRecord")]
        /**
          @abstract Indicates the progress for each record.

          @discussion This method is called at least once with a progress of 1.0 for every record. Intermediate progress is only reported for records that contain assets.
          It is possible for progress to regress when a retry is automatically triggered.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(setPerRecordProgressBlock:)]
        pub unsafe fn setPerRecordProgressBlock(
            &self,
            per_record_progress_block: Option<&Block<(NonNull<CKRecord>, c_double), ()>>,
        );

        #[cfg(all(feature = "CloudKit_CKRecord", feature = "Foundation_NSError"))]
        /**
          @abstract Called on success or failure for each record.

          @discussion Will not be invoked if @c perRecordSaveBlock is set.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[deprecated]
        #[method(perRecordCompletionBlock)]
        pub unsafe fn perRecordCompletionBlock(
            &self,
        ) -> *mut Block<(NonNull<CKRecord>, *mut NSError), ()>;

        #[cfg(all(feature = "CloudKit_CKRecord", feature = "Foundation_NSError"))]
        /**
          @abstract Called on success or failure for each record.

          @discussion Will not be invoked if @c perRecordSaveBlock is set.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[deprecated]
        #[method(setPerRecordCompletionBlock:)]
        pub unsafe fn setPerRecordCompletionBlock(
            &self,
            per_record_completion_block: Option<&Block<(NonNull<CKRecord>, *mut NSError), ()>>,
        );

        #[cfg(all(
            feature = "CloudKit_CKRecord",
            feature = "CloudKit_CKRecordID",
            feature = "Foundation_NSError"
        ))]
        /**
          @abstract Called on success or failure of a record save

          @discussion Following a successful record save, this callback will be invoked with a nonnull @c record, and a nil @c error.
          Following a save failure due to a per-item error (@c CKErrorServerRecordChanged, for example), this callback will be invoked with a nil @c record, and a nonnull @c error
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(perRecordSaveBlock)]
        pub unsafe fn perRecordSaveBlock(
            &self,
        ) -> *mut Block<(NonNull<CKRecordID>, *mut CKRecord, *mut NSError), ()>;

        #[cfg(all(
            feature = "CloudKit_CKRecord",
            feature = "CloudKit_CKRecordID",
            feature = "Foundation_NSError"
        ))]
        /**
          @abstract Called on success or failure of a record save

          @discussion Following a successful record save, this callback will be invoked with a nonnull @c record, and a nil @c error.
          Following a save failure due to a per-item error (@c CKErrorServerRecordChanged, for example), this callback will be invoked with a nil @c record, and a nonnull @c error
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(setPerRecordSaveBlock:)]
        pub unsafe fn setPerRecordSaveBlock(
            &self,
            per_record_save_block: Option<
                &Block<(NonNull<CKRecordID>, *mut CKRecord, *mut NSError), ()>,
            >,
        );

        #[cfg(all(feature = "CloudKit_CKRecordID", feature = "Foundation_NSError"))]
        /**
          @abstract Called on success or failure of a record deletion

          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(perRecordDeleteBlock)]
        pub unsafe fn perRecordDeleteBlock(
            &self,
        ) -> *mut Block<(NonNull<CKRecordID>, *mut NSError), ()>;

        #[cfg(all(feature = "CloudKit_CKRecordID", feature = "Foundation_NSError"))]
        /**
          @abstract Called on success or failure of a record deletion

          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(setPerRecordDeleteBlock:)]
        pub unsafe fn setPerRecordDeleteBlock(
            &self,
            per_record_delete_block: Option<&Block<(NonNull<CKRecordID>, *mut NSError), ()>>,
        );

        #[cfg(all(
            feature = "CloudKit_CKRecord",
            feature = "CloudKit_CKRecordID",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError"
        ))]
        /**
          @abstract This block is called when the operation completes.

          @discussion The @code -[NSOperation completionBlock] @endcode will also be called if both are set.
          If the error is @c CKErrorPartialFailure, the error's userInfo dictionary contains a dictionary of recordIDs to errors keyed off of @c CKPartialErrorsByItemIDKey.
          @c savedRecords, @c deletedRecordIDs and any @c CKPartialErrorsByItemIDKey errors are repeats of the data sent back in previous @c perRecordSaveBlock and @c perRecordDeleteBlock invocations
          This call happens as soon as the server has seen all record changes, and may be invoked while the server is processing the side effects of those changes.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(modifyRecordsCompletionBlock)]
        pub unsafe fn modifyRecordsCompletionBlock(
            &self,
        ) -> *mut Block<
            (
                *mut NSArray<CKRecord>,
                *mut NSArray<CKRecordID>,
                *mut NSError,
            ),
            (),
        >;

        #[cfg(all(
            feature = "CloudKit_CKRecord",
            feature = "CloudKit_CKRecordID",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError"
        ))]
        /**
          @abstract This block is called when the operation completes.

          @discussion The @code -[NSOperation completionBlock] @endcode will also be called if both are set.
          If the error is @c CKErrorPartialFailure, the error's userInfo dictionary contains a dictionary of recordIDs to errors keyed off of @c CKPartialErrorsByItemIDKey.
          @c savedRecords, @c deletedRecordIDs and any @c CKPartialErrorsByItemIDKey errors are repeats of the data sent back in previous @c perRecordSaveBlock and @c perRecordDeleteBlock invocations
          This call happens as soon as the server has seen all record changes, and may be invoked while the server is processing the side effects of those changes.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(setModifyRecordsCompletionBlock:)]
        pub unsafe fn setModifyRecordsCompletionBlock(
            &self,
            modify_records_completion_block: Option<
                &Block<
                    (
                        *mut NSArray<CKRecord>,
                        *mut NSArray<CKRecordID>,
                        *mut NSError,
                    ),
                    (),
                >,
            >,
        );
    }
);
