//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CloudKit::*;
use crate::CoreLocation::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    /**
      @enum CKOperationGroupTransferSize
      @abstract Valid values for expectedSendSize and expectedReceiveSize
      @constant CKOperationGroupTransferSizeUnknown Default value when you're completely unsure of your working set size.
      @constant CKOperationGroupTransferSizeKilobytes Less than 1MB
      @constant CKOperationGroupTransferSizeMegabytes 1-10MB
      @constant CKOperationGroupTransferSizeTensOfMegabytes 10-100MB
      @constant CKOperationGroupTransferSizeHundredsOfMegabytes 100MB-1GB
      @constant CKOperationGroupTransferSizeGigabytes 1-10GB
      @constant CKOperationGroupTransferSizeTensOfGigabytes 10-100GB
      @constant CKOperationGroupTransferSizeHundredsOfGigabytes More than 100GB
    */
    pub enum CKOperationGroupTransferSize {
        CKOperationGroupTransferSizeUnknown = 0,
        CKOperationGroupTransferSizeKilobytes = 1,
        CKOperationGroupTransferSizeMegabytes = 2,
        CKOperationGroupTransferSizeTensOfMegabytes = 3,
        CKOperationGroupTransferSizeHundredsOfMegabytes = 4,
        CKOperationGroupTransferSizeGigabytes = 5,
        CKOperationGroupTransferSizeTensOfGigabytes = 6,
        CKOperationGroupTransferSizeHundredsOfGigabytes = 7,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CloudKit_CKOperationGroup")]
    /**
      @class CKOperationGroup

      @abstract A mechanism for your app to group several operations at the granularity of a user action.

      @discussion For example, when building a Calendar application, these things might warrant being their own operation groups:
      - an initial fetch of data from the server, consisting of many queries, fetchChanges, and fetch operations
      - doing an incremental fetch of data in response to a push notification
      - saving several records due to a user saving a calendar event

      You associate @c CKOperationGroup s with@c  CKOperation s by setting the @c CKOperation.group property.  Create a new @c CKOperationGroup instance for each distinct user action.
    */
    pub struct CKOperationGroup;

    #[cfg(feature = "CloudKit_CKOperationGroup")]
    unsafe impl ClassType for CKOperationGroup {
        type Super = NSObject;
    }
);

#[cfg(feature = "CloudKit_CKOperationGroup")]
/**
  @class CKOperationGroup

  @abstract A mechanism for your app to group several operations at the granularity of a user action.

  @discussion For example, when building a Calendar application, these things might warrant being their own operation groups:
  - an initial fetch of data from the server, consisting of many queries, fetchChanges, and fetch operations
  - doing an incremental fetch of data in response to a push notification
  - saving several records due to a user saving a calendar event

  You associate @c CKOperationGroup s with@c  CKOperation s by setting the @c CKOperation.group property.  Create a new @c CKOperationGroup instance for each distinct user action.
*/
unsafe impl NSCoding for CKOperationGroup {}

#[cfg(feature = "CloudKit_CKOperationGroup")]
/**
  @class CKOperationGroup

  @abstract A mechanism for your app to group several operations at the granularity of a user action.

  @discussion For example, when building a Calendar application, these things might warrant being their own operation groups:
  - an initial fetch of data from the server, consisting of many queries, fetchChanges, and fetch operations
  - doing an incremental fetch of data in response to a push notification
  - saving several records due to a user saving a calendar event

  You associate @c CKOperationGroup s with@c  CKOperation s by setting the @c CKOperation.group property.  Create a new @c CKOperationGroup instance for each distinct user action.
*/
unsafe impl NSObjectProtocol for CKOperationGroup {}

#[cfg(feature = "CloudKit_CKOperationGroup")]
/**
  @class CKOperationGroup

  @abstract A mechanism for your app to group several operations at the granularity of a user action.

  @discussion For example, when building a Calendar application, these things might warrant being their own operation groups:
  - an initial fetch of data from the server, consisting of many queries, fetchChanges, and fetch operations
  - doing an incremental fetch of data in response to a push notification
  - saving several records due to a user saving a calendar event

  You associate @c CKOperationGroup s with@c  CKOperation s by setting the @c CKOperation.group property.  Create a new @c CKOperationGroup instance for each distinct user action.
*/
unsafe impl NSSecureCoding for CKOperationGroup {}

extern_methods!(
    /**
      @class CKOperationGroup

      @abstract A mechanism for your app to group several operations at the granularity of a user action.

      @discussion For example, when building a Calendar application, these things might warrant being their own operation groups:
      - an initial fetch of data from the server, consisting of many queries, fetchChanges, and fetch operations
      - doing an incremental fetch of data in response to a push notification
      - saving several records due to a user saving a calendar event

      You associate @c CKOperationGroup s with@c  CKOperation s by setting the @c CKOperation.group property.  Create a new @c CKOperationGroup instance for each distinct user action.
    */
    #[cfg(feature = "CloudKit_CKOperationGroup")]
    unsafe impl CKOperationGroup {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(this: Option<Allocated<Self>>, a_decoder: &NSCoder)
            -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          @abstract This is an identifier unique to this @c CKOperationGroup

          @discussion This value is chosen by the system, and will be unique to this instance of a @c CKOperationGroup.  This identifier will be sent to Apple's servers, and can be used to identify any server-side logging associated with this operation group.
        */
        #[method_id(@__retain_semantics Other operationGroupID)]
        pub unsafe fn operationGroupID(&self) -> Id<NSString>;

        #[cfg(feature = "CloudKit_CKOperationConfiguration")]
        /**
          @abstract This is the default configuration applied to operations in this operation group.

          @discussion If an operation associated with this operation group has its own configuration, then any explicitly-set properties in that operation's configuration will override these default configuration values.  See the example in CKOperation.h
        */
        #[method_id(@__retain_semantics Other defaultConfiguration)]
        pub unsafe fn defaultConfiguration(&self) -> Id<CKOperationConfiguration>;

        #[cfg(feature = "CloudKit_CKOperationConfiguration")]
        /**
          @abstract This is the default configuration applied to operations in this operation group.

          @discussion If an operation associated with this operation group has its own configuration, then any explicitly-set properties in that operation's configuration will override these default configuration values.  See the example in CKOperation.h
        */
        #[method(setDefaultConfiguration:)]
        pub unsafe fn setDefaultConfiguration(
            &self,
            default_configuration: Option<&CKOperationConfiguration>,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
          @abstract Describes the user action attributed to the operation group.

          @discussion @c name should describe the type of work being done.  Some examples:
          "Initial Fetch"
          "Incremental Fetch"
          "Saving User-Entered Record"
          This string will be sent to Apple servers to provide aggregate reporting for @c CKOperationGroup s and therefore must not include personally identifying data.
        */
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          @abstract Describes the user action attributed to the operation group.

          @discussion @c name should describe the type of work being done.  Some examples:
          "Initial Fetch"
          "Incremental Fetch"
          "Saving User-Entered Record"
          This string will be sent to Apple servers to provide aggregate reporting for @c CKOperationGroup s and therefore must not include personally identifying data.
        */
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        /**
          @abstract Describes an application-specific "number of elements" associated with the operation group.

          @discussion @c quantity is intended to show the app-specific count of items contained within the operation group.  It is your job to assign meaning to this value.  For example, if an app created an operation group to save 3 calendar events the user had created, the app might want to set this to "3".  This value is not shown to your users, it's meant to aid your development and debugging.  This value will be reported in the CloudKit Dashboard's log entries for all operations associated with this operation group.
        */
        #[method(quantity)]
        pub unsafe fn quantity(&self) -> NSUInteger;

        /**
          @abstract Describes an application-specific "number of elements" associated with the operation group.

          @discussion @c quantity is intended to show the app-specific count of items contained within the operation group.  It is your job to assign meaning to this value.  For example, if an app created an operation group to save 3 calendar events the user had created, the app might want to set this to "3".  This value is not shown to your users, it's meant to aid your development and debugging.  This value will be reported in the CloudKit Dashboard's log entries for all operations associated with this operation group.
        */
        #[method(setQuantity:)]
        pub unsafe fn setQuantity(&self, quantity: NSUInteger);

        /**
          @abstract Estimated size of traffic being uploaded to the CloudKit Server

          @discussion Inform the system how much data you plan on transferring.  Obviously, these won't be exact.  Be as accurate as possible, but even an order-of-magnitude estimate is better than no value.  The system will consult these values when scheduling discretionary network requests (see the description of @c CKOperationConfiguration.qualityOfService).
          Overestimating your workload means that an operation group issuing discretionary network requests may be delayed until network conditions are good.
          Underestimating your workload may cause the system to oversaturate a constrained connection, leading to network failures.
          You may update after the @c CKOperationGroup is created.  If it is increased, then subsequent @c CKOperation s associated with this operation group may be delayed until network conditions are good.
          Defaults to @c CKOperationGroupTransferSizeUnknown
        */
        #[method(expectedSendSize)]
        pub unsafe fn expectedSendSize(&self) -> CKOperationGroupTransferSize;

        /**
          @abstract Estimated size of traffic being uploaded to the CloudKit Server

          @discussion Inform the system how much data you plan on transferring.  Obviously, these won't be exact.  Be as accurate as possible, but even an order-of-magnitude estimate is better than no value.  The system will consult these values when scheduling discretionary network requests (see the description of @c CKOperationConfiguration.qualityOfService).
          Overestimating your workload means that an operation group issuing discretionary network requests may be delayed until network conditions are good.
          Underestimating your workload may cause the system to oversaturate a constrained connection, leading to network failures.
          You may update after the @c CKOperationGroup is created.  If it is increased, then subsequent @c CKOperation s associated with this operation group may be delayed until network conditions are good.
          Defaults to @c CKOperationGroupTransferSizeUnknown
        */
        #[method(setExpectedSendSize:)]
        pub unsafe fn setExpectedSendSize(&self, expected_send_size: CKOperationGroupTransferSize);

        /**
          @abstract Estimated size of traffic being downloaded from the CloudKit Server

          @discussion Inform the system how much data you plan on transferring.  Obviously, these won't be exact.  Be as accurate as possible, but even an order-of-magnitude estimate is better than no value.  The system will consult these values when scheduling discretionary network requests (see the description of @c CKOperationConfiguration.qualityOfService).
          Overestimating your workload means that an operation group issuing discretionary network requests may be delayed until network conditions are good.
          Underestimating your workload may cause the system to oversaturate a constrained connection, leading to network failures.
          You may update after the @c CKOperationGroup is created.  If it is increased, then subsequent @c CKOperation s associated with this operation group may be delayed until network conditions are good.
          Defaults to @c CKOperationGroupTransferSizeUnknown
        */
        #[method(expectedReceiveSize)]
        pub unsafe fn expectedReceiveSize(&self) -> CKOperationGroupTransferSize;

        /**
          @abstract Estimated size of traffic being downloaded from the CloudKit Server

          @discussion Inform the system how much data you plan on transferring.  Obviously, these won't be exact.  Be as accurate as possible, but even an order-of-magnitude estimate is better than no value.  The system will consult these values when scheduling discretionary network requests (see the description of @c CKOperationConfiguration.qualityOfService).
          Overestimating your workload means that an operation group issuing discretionary network requests may be delayed until network conditions are good.
          Underestimating your workload may cause the system to oversaturate a constrained connection, leading to network failures.
          You may update after the @c CKOperationGroup is created.  If it is increased, then subsequent @c CKOperation s associated with this operation group may be delayed until network conditions are good.
          Defaults to @c CKOperationGroupTransferSizeUnknown
        */
        #[method(setExpectedReceiveSize:)]
        pub unsafe fn setExpectedReceiveSize(
            &self,
            expected_receive_size: CKOperationGroupTransferSize,
        );
    }
);
