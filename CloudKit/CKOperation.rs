//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CloudKit::*;
use crate::CoreLocation::*;
use crate::Foundation::*;

pub type CKOperationID = NSString;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CloudKit_CKOperation")]
    pub struct CKOperation;

    #[cfg(feature = "CloudKit_CKOperation")]
    unsafe impl ClassType for CKOperation {
        #[inherits(NSObject)]
        type Super = NSOperation;
    }
);

#[cfg(feature = "CloudKit_CKOperation")]
unsafe impl NSObjectProtocol for CKOperation {}

extern_methods!(
    #[cfg(feature = "CloudKit_CKOperation")]
    unsafe impl CKOperation {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(feature = "CloudKit_CKOperationConfiguration")]
        /**
          @abstract This defines per-operation configuration settings.

          @discussion See the CKOperationConfiguration class description for info on how this configuration composes with CKOperationGroup.defaultConfiguration
        */
        #[method_id(@__retain_semantics Other configuration)]
        pub unsafe fn configuration(&self) -> Id<CKOperationConfiguration>;

        #[cfg(feature = "CloudKit_CKOperationConfiguration")]
        /**
          @abstract This defines per-operation configuration settings.

          @discussion See the CKOperationConfiguration class description for info on how this configuration composes with CKOperationGroup.defaultConfiguration
        */
        #[method(setConfiguration:)]
        pub unsafe fn setConfiguration(&self, configuration: Option<&CKOperationConfiguration>);

        #[cfg(feature = "CloudKit_CKOperationGroup")]
        /**
          @abstract The group this operation is associated with
        */
        #[method_id(@__retain_semantics Other group)]
        pub unsafe fn group(&self) -> Option<Id<CKOperationGroup>>;

        #[cfg(feature = "CloudKit_CKOperationGroup")]
        /**
          @abstract The group this operation is associated with
        */
        #[method(setGroup:)]
        pub unsafe fn setGroup(&self, group: Option<&CKOperationGroup>);

        /**
          @abstract This is an identifier unique to this CKOperation.

          @discussion This value is chosen by the system, and will be unique to this instance of a CKOperation.  This identifier will be sent to Apple's servers, and can be used to identify any server-side logging associated with this operation.
        */
        #[method_id(@__retain_semantics Other operationID)]
        pub unsafe fn operationID(&self) -> Id<CKOperationID>;

        /**
          @abstract This callback is called after a long lived operation has begun running and is persisted.

          @discussion Once this callback is called the operation will continue running even if the current process exits.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(longLivedOperationWasPersistedBlock)]
        pub unsafe fn longLivedOperationWasPersistedBlock(&self) -> *mut Block<(), ()>;

        /**
          @abstract This callback is called after a long lived operation has begun running and is persisted.

          @discussion Once this callback is called the operation will continue running even if the current process exits.
          Each @c CKOperation instance has a private serial queue. This queue is used for all callback block invocations.
        */
        #[method(setLongLivedOperationWasPersistedBlock:)]
        pub unsafe fn setLongLivedOperationWasPersistedBlock(
            &self,
            long_lived_operation_was_persisted_block: Option<&Block<(), ()>>,
        );
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CloudKit_CKOperationConfiguration")]
    /**
      @class CKOperationConfiguration

      @discussion An operation configuration is a set of properties that describes how your operation should behave.  All properties have a default value.  When determining what properties to apply to an operation, we consult the operation's configuration property, as well as the operation->group->defaultConfiguration property.  We combine them following these rules:
      @code
       Group Default Configuration Value | Operation Configuration Value |        Value Applied To Operation
      -----------------------------------+-------------------------------+-----------------------------------------
                 default value           |         default value         |                  default value
                 default value           |         explicit value        |       operation.configuration explicit value
                 explicit value          |         default value         | operation.group.defaultConfiguration explicit value
                 explicit value          |         explicit value        |       operation.configuration explicit value
      @endcode
      For example:
      CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
      + CKOperation -> configuration -> allowsCellularAccess has default value of YES
      = disallow cellular access

      CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
      + CKOperation -> configuration -> allowsCellularAccess explicitly set to YES
      = allow cellular access
    */
    pub struct CKOperationConfiguration;

    #[cfg(feature = "CloudKit_CKOperationConfiguration")]
    unsafe impl ClassType for CKOperationConfiguration {
        type Super = NSObject;
    }
);

#[cfg(feature = "CloudKit_CKOperationConfiguration")]
/**
  @class CKOperationConfiguration

  @discussion An operation configuration is a set of properties that describes how your operation should behave.  All properties have a default value.  When determining what properties to apply to an operation, we consult the operation's configuration property, as well as the operation->group->defaultConfiguration property.  We combine them following these rules:
  @code
   Group Default Configuration Value | Operation Configuration Value |        Value Applied To Operation
  -----------------------------------+-------------------------------+-----------------------------------------
             default value           |         default value         |                  default value
             default value           |         explicit value        |       operation.configuration explicit value
             explicit value          |         default value         | operation.group.defaultConfiguration explicit value
             explicit value          |         explicit value        |       operation.configuration explicit value
  @endcode
  For example:
  CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
  + CKOperation -> configuration -> allowsCellularAccess has default value of YES
  = disallow cellular access

  CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
  + CKOperation -> configuration -> allowsCellularAccess explicitly set to YES
  = allow cellular access
*/
unsafe impl NSObjectProtocol for CKOperationConfiguration {}

extern_methods!(
    /**
      @class CKOperationConfiguration

      @discussion An operation configuration is a set of properties that describes how your operation should behave.  All properties have a default value.  When determining what properties to apply to an operation, we consult the operation's configuration property, as well as the operation->group->defaultConfiguration property.  We combine them following these rules:
      @code
       Group Default Configuration Value | Operation Configuration Value |        Value Applied To Operation
      -----------------------------------+-------------------------------+-----------------------------------------
                 default value           |         default value         |                  default value
                 default value           |         explicit value        |       operation.configuration explicit value
                 explicit value          |         default value         | operation.group.defaultConfiguration explicit value
                 explicit value          |         explicit value        |       operation.configuration explicit value
      @endcode
      For example:
      CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
      + CKOperation -> configuration -> allowsCellularAccess has default value of YES
      = disallow cellular access

      CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
      + CKOperation -> configuration -> allowsCellularAccess explicitly set to YES
      = allow cellular access
    */
    #[cfg(feature = "CloudKit_CKOperationConfiguration")]
    unsafe impl CKOperationConfiguration {
        #[cfg(feature = "CloudKit_CKContainer")]
        /**
          If no container is set, [CKContainer defaultContainer] is used
        */
        #[method_id(@__retain_semantics Other container)]
        pub unsafe fn container(&self) -> Option<Id<CKContainer>>;

        #[cfg(feature = "CloudKit_CKContainer")]
        /**
          If no container is set, [CKContainer defaultContainer] is used
        */
        #[method(setContainer:)]
        pub unsafe fn setContainer(&self, container: Option<&CKContainer>);

        /**
          @discussion CKOperations behave differently depending on how you set qualityOfService.

          @code
          Quality of Service | timeoutIntervalForResource | Network Error Behavior | Discretionary Behavior
          -------------------+----------------------------+------------------------+-----------------------
          UserInteractive    | -1 (no enforcement)        | fail                   | nonDiscretionary
          UserInitiated      | -1 (no enforcement)        | fail                   | nonDiscretionary
          Default            | 1 week                     | fail                   | discretionary when app backgrounded
          Utility            | 1 week                     | internally retried     | discretionary when app backgrounded
          Background         | 1 week                     | internally retried     | discretionary
          @endcode
         timeoutIntervalForResource
         - the timeout interval for any network resources retrieved by this operation
         - this can be overridden via CKOperationConfiguration's timeoutIntervalForResource property

         Network Error Behavior
         - when a network request in service of a CKOperation fails due to a networking error, the operation may fail with that error, or internally retry the network request.  Only a subset of networking errors are retried, and limiting factors such as timeoutIntervalForResource are still applicable.

         Discretionary Behavior
         - network requests in service of a CKOperation may be marked as discretionary
         - discretionary network requests are scheduled at the description of the system for optimal performance

         CKOperations have a default qualityOfService of Default.
        */
        #[method(qualityOfService)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        /**
          @discussion CKOperations behave differently depending on how you set qualityOfService.

          @code
          Quality of Service | timeoutIntervalForResource | Network Error Behavior | Discretionary Behavior
          -------------------+----------------------------+------------------------+-----------------------
          UserInteractive    | -1 (no enforcement)        | fail                   | nonDiscretionary
          UserInitiated      | -1 (no enforcement)        | fail                   | nonDiscretionary
          Default            | 1 week                     | fail                   | discretionary when app backgrounded
          Utility            | 1 week                     | internally retried     | discretionary when app backgrounded
          Background         | 1 week                     | internally retried     | discretionary
          @endcode
         timeoutIntervalForResource
         - the timeout interval for any network resources retrieved by this operation
         - this can be overridden via CKOperationConfiguration's timeoutIntervalForResource property

         Network Error Behavior
         - when a network request in service of a CKOperation fails due to a networking error, the operation may fail with that error, or internally retry the network request.  Only a subset of networking errors are retried, and limiting factors such as timeoutIntervalForResource are still applicable.

         Discretionary Behavior
         - network requests in service of a CKOperation may be marked as discretionary
         - discretionary network requests are scheduled at the description of the system for optimal performance

         CKOperations have a default qualityOfService of Default.
        */
        #[method(setQualityOfService:)]
        pub unsafe fn setQualityOfService(&self, quality_of_service: NSQualityOfService);

        /**
          Defaults to @c YES
        */
        #[method(allowsCellularAccess)]
        pub unsafe fn allowsCellularAccess(&self) -> bool;

        /**
          Defaults to @c YES
        */
        #[method(setAllowsCellularAccess:)]
        pub unsafe fn setAllowsCellularAccess(&self, allows_cellular_access: bool);

        /**
          @discussion Long lived operations will continue running even if your process exits. If your process remains alive for the lifetime of the long lived operation its behavior is the same as a regular operation.

          Long lived operations can be fetched and replayed from the container via the @c fetchAllLongLivedOperations: and @c fetchLongLivedOperationsWithIDs: APIs.

          Long lived operations persist until their -[NSOperation completionBlock] returns or until the operation is cancelled.
          Long lived operations may be garbage collected 24 hours after they finish running if no client has replayed them.

          The default value for longLived is NO. Changing the value of longLived on an already started operation or on an outstanding long lived operation fetched from CKContainer has no effect.
        */
        #[method(isLongLived)]
        pub unsafe fn isLongLived(&self) -> bool;

        /**
          @discussion Long lived operations will continue running even if your process exits. If your process remains alive for the lifetime of the long lived operation its behavior is the same as a regular operation.

          Long lived operations can be fetched and replayed from the container via the @c fetchAllLongLivedOperations: and @c fetchLongLivedOperationsWithIDs: APIs.

          Long lived operations persist until their -[NSOperation completionBlock] returns or until the operation is cancelled.
          Long lived operations may be garbage collected 24 hours after they finish running if no client has replayed them.

          The default value for longLived is NO. Changing the value of longLived on an already started operation or on an outstanding long lived operation fetched from CKContainer has no effect.
        */
        #[method(setLongLived:)]
        pub unsafe fn setLongLived(&self, long_lived: bool);

        /**
          @discussion If non-zero, overrides the timeout interval for any network requests issued by this operation.
          The default value is 60.

         @see NSURLSessionConfiguration.timeoutIntervalForRequest
        */
        #[method(timeoutIntervalForRequest)]
        pub unsafe fn timeoutIntervalForRequest(&self) -> NSTimeInterval;

        /**
          @discussion If non-zero, overrides the timeout interval for any network requests issued by this operation.
          The default value is 60.

         @see NSURLSessionConfiguration.timeoutIntervalForRequest
        */
        #[method(setTimeoutIntervalForRequest:)]
        pub unsafe fn setTimeoutIntervalForRequest(
            &self,
            timeout_interval_for_request: NSTimeInterval,
        );

        /**
          @discussion If set, overrides the timeout interval for any network resources retrieved by this operation.
          If not explicitly set, defaults to a value based on the operation's @c qualityOfService

         @see NSURLSessionConfiguration.timeoutIntervalForResource
        */
        #[method(timeoutIntervalForResource)]
        pub unsafe fn timeoutIntervalForResource(&self) -> NSTimeInterval;

        /**
          @discussion If set, overrides the timeout interval for any network resources retrieved by this operation.
          If not explicitly set, defaults to a value based on the operation's @c qualityOfService

         @see NSURLSessionConfiguration.timeoutIntervalForResource
        */
        #[method(setTimeoutIntervalForResource:)]
        pub unsafe fn setTimeoutIntervalForResource(
            &self,
            timeout_interval_for_resource: NSTimeInterval,
        );
    }
);

extern_methods!(
    /**
      These deprecated properties now read and write from the CKOperation's configuration
    */
    /// CKOperationDeprecated
    #[cfg(feature = "CloudKit_CKOperation")]
    unsafe impl CKOperation {
        #[cfg(feature = "CloudKit_CKContainer")]
        #[deprecated = "Use CKOperationConfiguration"]
        #[method_id(@__retain_semantics Other container)]
        pub unsafe fn container(&self) -> Option<Id<CKContainer>>;

        #[cfg(feature = "CloudKit_CKContainer")]
        #[deprecated = "Use CKOperationConfiguration"]
        #[method(setContainer:)]
        pub unsafe fn setContainer(&self, container: Option<&CKContainer>);

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(allowsCellularAccess)]
        pub unsafe fn allowsCellularAccess(&self) -> bool;

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(setAllowsCellularAccess:)]
        pub unsafe fn setAllowsCellularAccess(&self, allows_cellular_access: bool);

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(isLongLived)]
        pub unsafe fn isLongLived(&self) -> bool;

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(setLongLived:)]
        pub unsafe fn setLongLived(&self, long_lived: bool);

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(timeoutIntervalForRequest)]
        pub unsafe fn timeoutIntervalForRequest(&self) -> NSTimeInterval;

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(setTimeoutIntervalForRequest:)]
        pub unsafe fn setTimeoutIntervalForRequest(
            &self,
            timeout_interval_for_request: NSTimeInterval,
        );

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(timeoutIntervalForResource)]
        pub unsafe fn timeoutIntervalForResource(&self) -> NSTimeInterval;

        #[deprecated = "Use CKOperationConfiguration"]
        #[method(setTimeoutIntervalForResource:)]
        pub unsafe fn setTimeoutIntervalForResource(
            &self,
            timeout_interval_for_resource: NSTimeInterval,
        );
    }
);
