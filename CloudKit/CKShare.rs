//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CloudKit::*;
use crate::CoreLocation::*;
use crate::Foundation::*;

extern_static!(CKRecordTypeShare: &'static CKRecordType);

extern_static!(CKRecordNameZoneWideShare: &'static NSString);

extern_static!(CKShareTitleKey: &'static CKRecordFieldKey);

extern_static!(CKShareThumbnailImageDataKey: &'static CKRecordFieldKey);

extern_static!(CKShareTypeKey: &'static CKRecordFieldKey);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CloudKit_CKShare")]
    /**
      @class CKShare

      @discussion Like CKRecords, CKShares can store arbitrary key-value pairs.  They are modified and fetched in the same manner.
      A share, its root record, and its root record's children records will only appear in a participant's CKFetchRecordChangesOperation's results after the share has been accepted by that participant.
      Clients have access to the share (and optionally the root record) before accepting a share, via the CKShareMetadata object.  Note that in order to access a root record before accepting a share, you must run a CKFetchShareMetadataOperation requesting the root record.
      A CKShare will appear in a CKFetchRecordChangesOperation's results set whenever the participant list is updated.  For that reason, you shouldn't place heavy key-value pairs in it.
    */
    pub struct CKShare;

    #[cfg(feature = "CloudKit_CKShare")]
    unsafe impl ClassType for CKShare {
        #[inherits(NSObject)]
        type Super = CKRecord;
    }
);

#[cfg(feature = "CloudKit_CKShare")]
/**
  @class CKShare

  @discussion Like CKRecords, CKShares can store arbitrary key-value pairs.  They are modified and fetched in the same manner.
  A share, its root record, and its root record's children records will only appear in a participant's CKFetchRecordChangesOperation's results after the share has been accepted by that participant.
  Clients have access to the share (and optionally the root record) before accepting a share, via the CKShareMetadata object.  Note that in order to access a root record before accepting a share, you must run a CKFetchShareMetadataOperation requesting the root record.
  A CKShare will appear in a CKFetchRecordChangesOperation's results set whenever the participant list is updated.  For that reason, you shouldn't place heavy key-value pairs in it.
*/
unsafe impl NSCoding for CKShare {}

#[cfg(feature = "CloudKit_CKShare")]
/**
  @class CKShare

  @discussion Like CKRecords, CKShares can store arbitrary key-value pairs.  They are modified and fetched in the same manner.
  A share, its root record, and its root record's children records will only appear in a participant's CKFetchRecordChangesOperation's results after the share has been accepted by that participant.
  Clients have access to the share (and optionally the root record) before accepting a share, via the CKShareMetadata object.  Note that in order to access a root record before accepting a share, you must run a CKFetchShareMetadataOperation requesting the root record.
  A CKShare will appear in a CKFetchRecordChangesOperation's results set whenever the participant list is updated.  For that reason, you shouldn't place heavy key-value pairs in it.
*/
unsafe impl NSObjectProtocol for CKShare {}

#[cfg(feature = "CloudKit_CKShare")]
/**
  @class CKShare

  @discussion Like CKRecords, CKShares can store arbitrary key-value pairs.  They are modified and fetched in the same manner.
  A share, its root record, and its root record's children records will only appear in a participant's CKFetchRecordChangesOperation's results after the share has been accepted by that participant.
  Clients have access to the share (and optionally the root record) before accepting a share, via the CKShareMetadata object.  Note that in order to access a root record before accepting a share, you must run a CKFetchShareMetadataOperation requesting the root record.
  A CKShare will appear in a CKFetchRecordChangesOperation's results set whenever the participant list is updated.  For that reason, you shouldn't place heavy key-value pairs in it.
*/
unsafe impl NSSecureCoding for CKShare {}

extern_methods!(
    /**
      @class CKShare

      @discussion Like CKRecords, CKShares can store arbitrary key-value pairs.  They are modified and fetched in the same manner.
      A share, its root record, and its root record's children records will only appear in a participant's CKFetchRecordChangesOperation's results after the share has been accepted by that participant.
      Clients have access to the share (and optionally the root record) before accepting a share, via the CKShareMetadata object.  Note that in order to access a root record before accepting a share, you must run a CKFetchShareMetadataOperation requesting the root record.
      A CKShare will appear in a CKFetchRecordChangesOperation's results set whenever the participant list is updated.  For that reason, you shouldn't place heavy key-value pairs in it.
    */
    #[cfg(feature = "CloudKit_CKShare")]
    unsafe impl CKShare {
        #[method_id(@__retain_semantics Init initWithRootRecord:)]
        pub unsafe fn initWithRootRecord(
            this: Option<Allocated<Self>>,
            root_record: &CKRecord,
        ) -> Id<Self>;

        #[cfg(feature = "CloudKit_CKRecordID")]
        #[method_id(@__retain_semantics Init initWithRootRecord:shareID:)]
        pub unsafe fn initWithRootRecord_shareID(
            this: Option<Allocated<Self>>,
            root_record: &CKRecord,
            share_id: &CKRecordID,
        ) -> Id<Self>;

        #[cfg(feature = "CloudKit_CKRecordZoneID")]
        #[method_id(@__retain_semantics Init initWithRecordZoneID:)]
        pub unsafe fn initWithRecordZoneID(
            this: Option<Allocated<Self>>,
            record_zone_id: &CKRecordZoneID,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(this: Option<Allocated<Self>>, a_decoder: &NSCoder)
            -> Id<Self>;

        /**
          @abstract Defines what permission a user has when not explicitly added to the share.

          @discussion Shares with @c publicPermission more permissive than @c CKShareParticipantPermissionNone can be joined by any user with access to the share's shareURL.
          By default, public permission is @c CKShareParticipantPermissionNone.
          Changing the public permission to @c CKShareParticipantPermissionReadOnly or @c CKShareParticipantPermissionReadWrite will result in all pending participants being removed.  Already-accepted participants will remain on the share.
          Changing the public permission to @c CKShareParticipantPermissionNone will result in all participants being removed from the share.  You may subsequently choose to call @c addParticipant: before saving the share, those participants will be added to the share.
        */
        #[method(publicPermission)]
        pub unsafe fn publicPermission(&self) -> CKShareParticipantPermission;

        /**
          @abstract Defines what permission a user has when not explicitly added to the share.

          @discussion Shares with @c publicPermission more permissive than @c CKShareParticipantPermissionNone can be joined by any user with access to the share's shareURL.
          By default, public permission is @c CKShareParticipantPermissionNone.
          Changing the public permission to @c CKShareParticipantPermissionReadOnly or @c CKShareParticipantPermissionReadWrite will result in all pending participants being removed.  Already-accepted participants will remain on the share.
          Changing the public permission to @c CKShareParticipantPermissionNone will result in all participants being removed from the share.  You may subsequently choose to call @c addParticipant: before saving the share, those participants will be added to the share.
        */
        #[method(setPublicPermission:)]
        pub unsafe fn setPublicPermission(&self, public_permission: CKShareParticipantPermission);

        #[cfg(feature = "Foundation_NSURL")]
        /**
          @abstract A URL that can be used to invite participants to this share.

          @discussion Only available after share record has been saved to the server.  This url is stable, and is tied to the rootRecord.  That is, if you share a rootRecord, delete the share, and re-share the same rootRecord via a newly created share, that newly created share's url will be identical to the prior share's url
        */
        #[method_id(@__retain_semantics Other URL)]
        pub unsafe fn URL(&self) -> Option<Id<NSURL>>;

        #[cfg(all(
            feature = "CloudKit_CKShareParticipant",
            feature = "Foundation_NSArray"
        ))]
        /**
          @abstract All participants on the share that the current user has permissions to see.

          @discussion At the minimum that will include the owner and the current user.
        */
        #[method_id(@__retain_semantics Other participants)]
        pub unsafe fn participants(&self) -> Id<NSArray<CKShareParticipant>>;

        #[cfg(feature = "CloudKit_CKShareParticipant")]
        /**
          Convenience methods for fetching special users from the participant array
        */
        #[method_id(@__retain_semantics Other owner)]
        pub unsafe fn owner(&self) -> Id<CKShareParticipant>;

        #[cfg(feature = "CloudKit_CKShareParticipant")]
        #[method_id(@__retain_semantics Other currentUserParticipant)]
        pub unsafe fn currentUserParticipant(&self) -> Option<Id<CKShareParticipant>>;

        #[cfg(feature = "CloudKit_CKShareParticipant")]
        #[method(addParticipant:)]
        pub unsafe fn addParticipant(&self, participant: &CKShareParticipant);

        #[cfg(feature = "CloudKit_CKShareParticipant")]
        #[method(removeParticipant:)]
        pub unsafe fn removeParticipant(&self, participant: &CKShareParticipant);

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithRecordType:)]
        pub unsafe fn initWithRecordType(
            this: Option<Allocated<Self>>,
            record_type: &CKRecordType,
        ) -> Id<Self>;

        #[cfg(feature = "CloudKit_CKRecordID")]
        #[method_id(@__retain_semantics Init initWithRecordType:recordID:)]
        pub unsafe fn initWithRecordType_recordID(
            this: Option<Allocated<Self>>,
            record_type: &CKRecordType,
            record_id: &CKRecordID,
        ) -> Id<Self>;

        #[cfg(feature = "CloudKit_CKRecordZoneID")]
        #[method_id(@__retain_semantics Init initWithRecordType:zoneID:)]
        pub unsafe fn initWithRecordType_zoneID(
            this: Option<Allocated<Self>>,
            record_type: &CKRecordType,
            zone_id: &CKRecordZoneID,
        ) -> Id<Self>;
    }
);
