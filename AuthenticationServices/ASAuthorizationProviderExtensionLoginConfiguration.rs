//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AuthenticationServices::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionKerberosMapping")]
    pub struct ASAuthorizationProviderExtensionKerberosMapping;

    #[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionKerberosMapping")]
    unsafe impl ClassType for ASAuthorizationProviderExtensionKerberosMapping {
        type Super = NSObject;
    }
);

#[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionKerberosMapping")]
unsafe impl NSObjectProtocol for ASAuthorizationProviderExtensionKerberosMapping {}

extern_methods!(
    #[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionKerberosMapping")]
    unsafe impl ASAuthorizationProviderExtensionKerberosMapping {
        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The keypath in the response JSON that uses this set of mappings.
        @discussion If the response tokens from login contain this keypath, then the mapping in this class will be used to create a Kerberos ticket. The expected response is a JSON dictionary with the supplied key names.
        */
        #[method_id(@__retain_semantics Other ticketKeyPath)]
        pub unsafe fn ticketKeyPath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The keypath in the response JSON that uses this set of mappings.
        @discussion If the response tokens from login contain this keypath, then the mapping in this class will be used to create a Kerberos ticket. The expected response is a JSON dictionary with the supplied key names.
        */
        #[method(setTicketKeyPath:)]
        pub unsafe fn setTicketKeyPath(&self, ticket_key_path: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the base64 encoded kerberos AS-REP string.
        */
        #[method_id(@__retain_semantics Other messageBufferKeyName)]
        pub unsafe fn messageBufferKeyName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the base64 encoded kerberos AS-REP string.
        */
        #[method(setMessageBufferKeyName:)]
        pub unsafe fn setMessageBufferKeyName(&self, message_buffer_key_name: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos Realm string.
        */
        #[method_id(@__retain_semantics Other realmKeyName)]
        pub unsafe fn realmKeyName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos Realm string.
        */
        #[method(setRealmKeyName:)]
        pub unsafe fn setRealmKeyName(&self, realm_key_name: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos service name string.
        */
        #[method_id(@__retain_semantics Other serviceNameKeyName)]
        pub unsafe fn serviceNameKeyName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos service name string.
        */
        #[method(setServiceNameKeyName:)]
        pub unsafe fn setServiceNameKeyName(&self, service_name_key_name: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos client name string.
        */
        #[method_id(@__retain_semantics Other clientNameKeyName)]
        pub unsafe fn clientNameKeyName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos client name string.
        */
        #[method(setClientNameKeyName:)]
        pub unsafe fn setClientNameKeyName(&self, client_name_key_name: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos session key type number.
        @discussion The value for this key should be the correct encryption type per RFC3962, section 7 for the session key.
        */
        #[method_id(@__retain_semantics Other encryptionKeyTypeKeyName)]
        pub unsafe fn encryptionKeyTypeKeyName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos session key type number.
        @discussion The value for this key should be the correct encryption type per RFC3962, section 7 for the session key.
        */
        #[method(setEncryptionKeyTypeKeyName:)]
        pub unsafe fn setEncryptionKeyTypeKeyName(
            &self,
            encryption_key_type_key_name: Option<&NSString>,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos session key.
        */
        #[method_id(@__retain_semantics Other sessionKeyKeyName)]
        pub unsafe fn sessionKeyKeyName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The key name that contains the Kerberos session key.
        */
        #[method(setSessionKeyKeyName:)]
        pub unsafe fn setSessionKeyKeyName(&self, session_key_key_name: Option<&NSString>);
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionLoginConfiguration")]
    pub struct ASAuthorizationProviderExtensionLoginConfiguration;

    #[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionLoginConfiguration")]
    unsafe impl ClassType for ASAuthorizationProviderExtensionLoginConfiguration {
        type Super = NSObject;
    }
);

#[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionLoginConfiguration")]
unsafe impl NSObjectProtocol for ASAuthorizationProviderExtensionLoginConfiguration {}

extern_methods!(
    #[cfg(feature = "AuthenticationServices_ASAuthorizationProviderExtensionLoginConfiguration")]
    unsafe impl ASAuthorizationProviderExtensionLoginConfiguration {
        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Init initWithClientID:issuer:tokenEndpointURL:jwksEndpointURL:audience:)]
        pub unsafe fn initWithClientID_issuer_tokenEndpointURL_jwksEndpointURL_audience(
            this: Option<Allocated<Self>>,
            client_id: &NSString,
            issuer: &NSString,
            token_endpoint_url: &NSURL,
            jwks_endpoint_url: &NSURL,
            audience: Option<&NSString>,
        ) -> Id<Self>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method(configurationWithOpenIDConfigurationURL:clientID:issuer:completion:)]
        pub unsafe fn configurationWithOpenIDConfigurationURL_clientID_issuer_completion(
            open_id_configuration_url: &NSURL,
            client_id: &NSString,
            issuer: Option<&NSString>,
            completion: &Block<
                (
                    *mut ASAuthorizationProviderExtensionLoginConfiguration,
                    *mut NSError,
                ),
                (),
            >,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract Predicate string used to identify invalid credential errors.
        @discussion If there is an HTTP 400 or HTTP 401 error when authenticating, this predicate will be used on the response body JSON to determine if the error is due to an invalid password or something else.  If nil, then only an HTTP 401 will be used for an invalid credential.
        */
        #[method_id(@__retain_semantics Other invalidCredentialPredicate)]
        pub unsafe fn invalidCredentialPredicate(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract Predicate string used to identify invalid credential errors.
        @discussion If there is an HTTP 400 or HTTP 401 error when authenticating, this predicate will be used on the response body JSON to determine if the error is due to an invalid password or something else.  If nil, then only an HTTP 401 will be used for an invalid credential.
        */
        #[method(setInvalidCredentialPredicate:)]
        pub unsafe fn setInvalidCredentialPredicate(
            &self,
            invalid_credential_predicate: Option<&NSString>,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The display name for the account.  Used for notifications and login prompts.
        */
        #[method_id(@__retain_semantics Other accountDisplayName)]
        pub unsafe fn accountDisplayName(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The display name for the account.  Used for notifications and login prompts.
        */
        #[method(setAccountDisplayName:)]
        pub unsafe fn setAccountDisplayName(&self, account_display_name: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The login client_id.
        */
        #[method_id(@__retain_semantics Other clientID)]
        pub unsafe fn clientID(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The issuer for validation.
        */
        #[method_id(@__retain_semantics Other issuer)]
        pub unsafe fn issuer(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The audience for validation and requests.
        */
        #[method_id(@__retain_semantics Other audience)]
        pub unsafe fn audience(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The audience for validation and requests.
        */
        #[method(setAudience:)]
        pub unsafe fn setAudience(&self, audience: &NSString);

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @abstract Token Endpoint URL for login request.
        */
        #[method_id(@__retain_semantics Other tokenEndpointURL)]
        pub unsafe fn tokenEndpointURL(&self) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @abstract Token Endpoint URL for login request.
        */
        #[method(setTokenEndpointURL:)]
        pub unsafe fn setTokenEndpointURL(&self, token_endpoint_url: &NSURL);

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @abstract JWKS Endpoint URL for keys.
        */
        #[method_id(@__retain_semantics Other jwksEndpointURL)]
        pub unsafe fn jwksEndpointURL(&self) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @abstract JWKS Endpoint URL for keys.
        */
        #[method(setJwksEndpointURL:)]
        pub unsafe fn setJwksEndpointURL(&self, jwks_endpoint_url: &NSURL);

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @abstract Nonce Endpoint URL, defaults to token tokenEndpointURL.
        */
        #[method_id(@__retain_semantics Other nonceEndpointURL)]
        pub unsafe fn nonceEndpointURL(&self) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @abstract Nonce Endpoint URL, defaults to token tokenEndpointURL.
        */
        #[method(setNonceEndpointURL:)]
        pub unsafe fn setNonceEndpointURL(&self, nonce_endpoint_url: &NSURL);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The keypath in the nonce response that contains the nonce value.
        */
        #[method_id(@__retain_semantics Other nonceResponseKeypath)]
        pub unsafe fn nonceResponseKeypath(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The keypath in the nonce response that contains the nonce value.
        */
        #[method(setNonceResponseKeypath:)]
        pub unsafe fn setNonceResponseKeypath(&self, nonce_response_keypath: &NSString);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The name of the server nonce claim when included in authentication requests.
        */
        #[method_id(@__retain_semantics Other serverNonceClaimName)]
        pub unsafe fn serverNonceClaimName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The name of the server nonce claim when included in authentication requests.
        */
        #[method(setServerNonceClaimName:)]
        pub unsafe fn setServerNonceClaimName(&self, server_nonce_claim_name: &NSString);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
         @abstract Custom values added to the server nonce POST request body.
        */
        #[method_id(@__retain_semantics Other customNonceRequestValues)]
        pub unsafe fn customNonceRequestValues(&self) -> Id<NSArray<NSURLQueryItem>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
         @abstract Custom values added to the server nonce POST request body.
        */
        #[method(setCustomNonceRequestValues:)]
        pub unsafe fn setCustomNonceRequestValues(
            &self,
            custom_nonce_request_values: &NSArray<NSURLQueryItem>,
        );

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString"
        ))]
        #[method(setCustomAssertionRequestHeaderClaims:returningError:_)]
        pub unsafe fn setCustomAssertionRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, Object>,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString"
        ))]
        #[method(setCustomAssertionRequestBodyClaims:returningError:_)]
        pub unsafe fn setCustomAssertionRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, Object>,
        ) -> Result<(), Id<NSError>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract Additional login scopes.
        */
        #[method_id(@__retain_semantics Other additionalScopes)]
        pub unsafe fn additionalScopes(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract Additional login scopes.
        */
        #[method(setAdditionalScopes:)]
        pub unsafe fn setAdditionalScopes(&self, additional_scopes: &NSString);

        /**
         @abstract If true and there is a refresh token for the user in the SSO tokens, it will be included in the login request.
        */
        #[method(includePreviousRefreshTokenInLoginRequest)]
        pub unsafe fn includePreviousRefreshTokenInLoginRequest(&self) -> bool;

        /**
         @abstract If true and there is a refresh token for the user in the SSO tokens, it will be included in the login request.
        */
        #[method(setIncludePreviousRefreshTokenInLoginRequest:)]
        pub unsafe fn setIncludePreviousRefreshTokenInLoginRequest(
            &self,
            include_previous_refresh_token_in_login_request: bool,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The claim name for the previous SSO token value in the login request.
        */
        #[method_id(@__retain_semantics Other previousRefreshTokenClaimName)]
        pub unsafe fn previousRefreshTokenClaimName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @abstract The claim name for the previous SSO token value in the login request.
        */
        #[method(setPreviousRefreshTokenClaimName:)]
        pub unsafe fn setPreviousRefreshTokenClaimName(
            &self,
            previous_refresh_token_claim_name: &NSString,
        );

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
         @abstract Custom values added to the login POST request body.
        */
        #[method_id(@__retain_semantics Other customLoginRequestValues)]
        pub unsafe fn customLoginRequestValues(&self) -> Id<NSArray<NSURLQueryItem>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
         @abstract Custom values added to the login POST request body.
        */
        #[method(setCustomLoginRequestValues:)]
        pub unsafe fn setCustomLoginRequestValues(
            &self,
            custom_login_request_values: &NSArray<NSURLQueryItem>,
        );

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString"
        ))]
        #[method(setCustomLoginRequestHeaderClaims:returningError:_)]
        pub unsafe fn setCustomLoginRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, Object>,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError",
            feature = "Foundation_NSString"
        ))]
        #[method(setCustomLoginRequestBodyClaims:returningError:_)]
        pub unsafe fn setCustomLoginRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, Object>,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "AuthenticationServices_ASAuthorizationProviderExtensionKerberosMapping",
            feature = "Foundation_NSArray"
        ))]
        /**
         @abstract The Kerberos ticket mappings to use.
        */
        #[method_id(@__retain_semantics Other kerberosTicketMappings)]
        pub unsafe fn kerberosTicketMappings(
            &self,
        ) -> Id<NSArray<ASAuthorizationProviderExtensionKerberosMapping>>;

        #[cfg(all(
            feature = "AuthenticationServices_ASAuthorizationProviderExtensionKerberosMapping",
            feature = "Foundation_NSArray"
        ))]
        /**
         @abstract The Kerberos ticket mappings to use.
        */
        #[method(setKerberosTicketMappings:)]
        pub unsafe fn setKerberosTicketMappings(
            &self,
            kerberos_ticket_mappings: &NSArray<ASAuthorizationProviderExtensionKerberosMapping>,
        );
    }
);
