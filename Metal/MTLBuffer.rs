//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

extern_protocol!(
    /**
     @protocol MTLBuffer
    @abstract A typeless allocation accessible by both the CPU and the GPU (MTLDevice) or by only the GPU when the storage mode is
    MTLResourceStorageModePrivate.

    @discussion
    Unlike in OpenGL and OpenCL, access to buffers is not synchronized.  The caller may use the CPU to modify the data at any time
    but is also responsible for ensuring synchronization and coherency.

    The contents become undefined if both the CPU and GPU write to the same buffer without a synchronizing action between those writes.
    This is true even when the regions written do not overlap.
    */
    pub unsafe trait MTLBuffer: MTLResource {
        /**
         @property length
        @abstract The length of the buffer in bytes.
        */
        #[method(length)]
        fn length(&self) -> NSUInteger;

        #[method(contents)]
        fn contents(&self) -> NonNull<c_void>;

        #[method(didModifyRange:)]
        fn didModifyRange(&self, range: NSRange);

        #[cfg(feature = "Metal_MTLTextureDescriptor")]
        #[method_id(@__retain_semantics New newTextureWithDescriptor:offset:bytesPerRow:)]
        fn newTextureWithDescriptor_offset_bytesPerRow(
            &self,
            descriptor: &MTLTextureDescriptor,
            offset: NSUInteger,
            bytes_per_row: NSUInteger,
        ) -> Option<Id<ProtocolObject<dyn MTLTexture>>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(addDebugMarker:range:)]
        fn addDebugMarker_range(&self, marker: &NSString, range: NSRange);

        #[method(removeAllDebugMarkers)]
        fn removeAllDebugMarkers(&self);

        /**
         @property remoteStorageBuffer
        @abstract For Metal buffer objects that are remote views, this returns the buffer associated with the storage on the originating device.
        */
        #[method_id(@__retain_semantics Other remoteStorageBuffer)]
        fn remoteStorageBuffer(&self) -> Option<Id<ProtocolObject<dyn MTLBuffer>>>;

        #[method_id(@__retain_semantics New newRemoteBufferViewForDevice:)]
        fn newRemoteBufferViewForDevice(
            &self,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Id<ProtocolObject<dyn MTLBuffer>>>;

        /**
         @property gpuAddress
        @abstract Represents the GPU virtual address of a buffer resource
        */
        #[method(gpuAddress)]
        fn gpuAddress(&self) -> u64;
    }

    unsafe impl ProtocolType for dyn MTLBuffer {}
);
