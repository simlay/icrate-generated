//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLPurgeableOption
    @abstract Options for setPurgeable call.

    @constant MTLPurgeableStateNonVolatile
    The contents of this resource may not be discarded.

    @constant MTLPurgeableStateVolatile
    The contents of this resource may be discarded.

    @constant MTLPurgeableStateEmpty
    The contents of this are discarded.

    @constant MTLPurgeableStateKeepCurrent
    The purgeabelity state is not changed.
    */
    pub enum MTLPurgeableState {
        MTLPurgeableStateKeepCurrent = 1,
        MTLPurgeableStateNonVolatile = 2,
        MTLPurgeableStateVolatile = 3,
        MTLPurgeableStateEmpty = 4,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLCPUCacheMode
    @abstract Describes what CPU cache mode is used for the CPU's mapping of a texture resource.
    @constant MTLCPUCacheModeDefaultCache
    The default cache mode for the system.

    @constant MTLCPUCacheModeWriteCombined
    Write combined memory is optimized for resources that the CPU will write into, but never read.  On some implementations, writes may bypass caches avoiding cache pollution, and reads perform very poorly.

    @discussion
    Applications should only investigate changing the cache mode if writing to normally cached buffers is known to cause performance issues due to cache pollution, as write combined memory can have surprising performance pitfalls.  Another approach is to use non-temporal stores to normally cached memory (STNP on ARMv8, _mm_stream_* on x86_64).
    */
    pub enum MTLCPUCacheMode {
        MTLCPUCacheModeDefaultCache = 0,
        MTLCPUCacheModeWriteCombined = 1,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLStorageMode
    @abstract Describes location and CPU mapping of MTLTexture.
    @constant MTLStorageModeShared
    In this mode, CPU and device will nominally both use the same underlying memory when accessing the contents of the texture resource.
    However, coherency is only guaranteed at command buffer boundaries to minimize the required flushing of CPU and GPU caches.
    This is the default storage mode for iOS Textures.

    @constant MTLStorageModeManaged
    This mode relaxes the coherency requirements and requires that the developer make explicit requests to maintain
    coherency between a CPU and GPU version of the texture resource.  In order for CPU to access up to date GPU results,
    first, a blit synchronizations must be completed (see synchronize methods of MTLBlitCommandEncoder).
    Blit overhead is only incurred if GPU has modified the resource.
    This is the default storage mode for OS X Textures.

    @constant MTLStorageModePrivate
    This mode allows the texture resource data to be kept entirely to GPU (or driver) private memory that will never be accessed by the CPU directly, so no
    conherency of any kind must be maintained.

    @constant MTLStorageModeMemoryless
    This mode allows creation of resources that do not have a GPU or CPU memory backing, but do have on-chip storage for TBDR
    devices. The contents of the on-chip storage is undefined and does not persist, but its configuration is controlled by the
    MTLTexture descriptor. Textures created with MTLStorageModeMemoryless dont have an IOAccelResource at any point in their
    lifetime. The only way to populate such resource is to perform rendering operations on it. Blit operations are disallowed.
    */
    pub enum MTLStorageMode {
        MTLStorageModeShared = 0,
        MTLStorageModeManaged = 1,
        MTLStorageModePrivate = 2,
        MTLStorageModeMemoryless = 3,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLHazardTrackingMode
    @abstract Describes how hazard tracking is performed.
    @constant MTLHazardTrackingModeDefault The default hazard tracking mode for the context. Refer to the usage of the field for semantics.
    @constant MTLHazardTrackingModeUntracked Do not perform hazard tracking.
    @constant MTLHazardTrackingModeTracked Do perform hazard tracking.
    */
    pub enum MTLHazardTrackingMode {
        MTLHazardTrackingModeDefault = 0,
        MTLHazardTrackingModeUntracked = 1,
        MTLHazardTrackingModeTracked = 2,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum MTLResourceOptions {
        MTLResourceCPUCacheModeDefaultCache =
            MTLCPUCacheModeDefaultCache << MTLResourceCPUCacheModeShift,
        MTLResourceCPUCacheModeWriteCombined =
            MTLCPUCacheModeWriteCombined << MTLResourceCPUCacheModeShift,
        MTLResourceStorageModeShared = MTLStorageModeShared << MTLResourceStorageModeShift,
        MTLResourceStorageModeManaged = MTLStorageModeManaged << MTLResourceStorageModeShift,
        MTLResourceStorageModePrivate = MTLStorageModePrivate << MTLResourceStorageModeShift,
        MTLResourceStorageModeMemoryless = MTLStorageModeMemoryless << MTLResourceStorageModeShift,
        MTLResourceHazardTrackingModeDefault =
            MTLHazardTrackingModeDefault << MTLResourceHazardTrackingModeShift,
        MTLResourceHazardTrackingModeUntracked =
            MTLHazardTrackingModeUntracked << MTLResourceHazardTrackingModeShift,
        MTLResourceHazardTrackingModeTracked =
            MTLHazardTrackingModeTracked << MTLResourceHazardTrackingModeShift,
        #[deprecated]
        MTLResourceOptionCPUCacheModeDefault = MTLResourceCPUCacheModeDefaultCache,
        #[deprecated]
        MTLResourceOptionCPUCacheModeWriteCombined = MTLResourceCPUCacheModeWriteCombined,
    }
);

extern_protocol!(
    /**
     @protocol MTLResource
    @abstract Common APIs available for MTLBuffer and MTLTexture instances
    */
    pub unsafe trait MTLResource: NSObjectProtocol {
        #[cfg(feature = "Foundation_NSString")]
        /**
         @property label
        @abstract A string to help identify this object.
        */
        #[method_id(@__retain_semantics Other label)]
        fn label(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @property label
        @abstract A string to help identify this object.
        */
        #[method(setLabel:)]
        fn setLabel(&self, label: Option<&NSString>);

        /**
         @property device
        @abstract The device this resource was created against.  This resource can only be used with this device.
        */
        #[method_id(@__retain_semantics Other device)]
        fn device(&self) -> Id<ProtocolObject<dyn MTLDevice>>;

        /**
         @property cpuCacheMode
        @abstract The cache mode used for the CPU mapping for this resource
        */
        #[method(cpuCacheMode)]
        fn cpuCacheMode(&self) -> MTLCPUCacheMode;

        /**
         @property storageMode
        @abstract The resource storage mode used for the CPU mapping for this resource
        */
        #[method(storageMode)]
        fn storageMode(&self) -> MTLStorageMode;

        /**
         @property hazardTrackingMode
        @abstract Whether or not the resource is hazard tracked.
        @discussion This value can be either MTLHazardTrackingModeUntracked or MTLHazardTrackingModeTracked.
        Resources created from heaps are by default untracked, whereas resources created from the device are by default tracked.
        */
        #[method(hazardTrackingMode)]
        fn hazardTrackingMode(&self) -> MTLHazardTrackingMode;

        /**
         @property resourceOptions
        @abstract A packed tuple of the storageMode, cpuCacheMode and hazardTrackingMode properties.
        */
        #[method(resourceOptions)]
        fn resourceOptions(&self) -> MTLResourceOptions;

        #[method(setPurgeableState:)]
        fn setPurgeableState(&self, state: MTLPurgeableState) -> MTLPurgeableState;

        /**
         @property heap
        @abstract The heap from which this resouce was created.
        @discussion Nil when this resource is not backed by a heap.
        */
        #[method_id(@__retain_semantics Other heap)]
        fn heap(&self) -> Option<Id<ProtocolObject<dyn MTLHeap>>>;

        /**
         @property heapOffset
        @abstract The offset inside the heap at which this resource was created.
        @discussion Zero when this resource was not created on a heap with MTLHeapTypePlacement.
        */
        #[method(heapOffset)]
        fn heapOffset(&self) -> NSUInteger;

        /**
         @property allocatedSize
        @abstract The size in bytes occupied by this resource
        */
        #[method(allocatedSize)]
        fn allocatedSize(&self) -> NSUInteger;

        #[method(makeAliasable)]
        unsafe fn makeAliasable(&self);

        #[method(isAliasable)]
        fn isAliasable(&self) -> bool;
    }

    unsafe impl ProtocolType for dyn MTLResource {}
);
