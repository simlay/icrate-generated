//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

extern_static!(MTLBinaryArchiveDomain: &'static NSErrorDomain);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum MTLBinaryArchiveError {
        MTLBinaryArchiveErrorNone = 0,
        MTLBinaryArchiveErrorInvalidFile = 1,
        MTLBinaryArchiveErrorUnexpectedElement = 2,
        MTLBinaryArchiveErrorCompilationFailure = 3,
        MTLBinaryArchiveErrorInternalError = 4,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Metal_MTLBinaryArchiveDescriptor")]
    /**
     @class MTLBinaryArchiveDescriptor
    @abstract A class used to indicate how an archive should be created
    */
    pub struct MTLBinaryArchiveDescriptor;

    #[cfg(feature = "Metal_MTLBinaryArchiveDescriptor")]
    unsafe impl ClassType for MTLBinaryArchiveDescriptor {
        type Super = NSObject;
    }
);

#[cfg(feature = "Metal_MTLBinaryArchiveDescriptor")]
/**
 @class MTLBinaryArchiveDescriptor
@abstract A class used to indicate how an archive should be created
*/
unsafe impl NSObjectProtocol for MTLBinaryArchiveDescriptor {}

extern_methods!(
    /**
     @class MTLBinaryArchiveDescriptor
    @abstract A class used to indicate how an archive should be created
    */
    #[cfg(feature = "Metal_MTLBinaryArchiveDescriptor")]
    unsafe impl MTLBinaryArchiveDescriptor {
        #[cfg(feature = "Foundation_NSURL")]
        /**
         @property url
        @abstract The file URL from which to open a MTLBinaryArchive, or nil to create an empty MTLBinaryArchive.
        */
        #[method_id(@__retain_semantics Other url)]
        pub fn url(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
         @property url
        @abstract The file URL from which to open a MTLBinaryArchive, or nil to create an empty MTLBinaryArchive.
        */
        #[method(setUrl:)]
        pub fn setUrl(&self, url: Option<&NSURL>);
    }
);

extern_protocol!(
    /**
     @protocol MTLBinaryArchive
    @abstract A container of pipeline state descriptors and their associated compiled code.
    @discussion A MTLBinaryArchive allows to persist compiled pipeline state objects for a device, which can be used to skip recompilation on a subsequent run of the app.
    One or more archives may be supplied in the descriptor of a pipeline state, allowing the device to attempt to look up compiled code in them before performing compilation.
    If no archives are provided, or no archives contain the requested content, the pipeline state is created by compiling the code as usual.
    Note that software updates of the OS or device drivers may cause the archive to become outdated, causing the lookup to fail and the usual path performing on-demand compilation is taken.
    A MTLBinaryArchive is populated by adding functions from pipeline state descriptors to it, indicating which compiled code should be persisted in the archive.
    Once all desired pipeline state descriptors have been added, use serializeToURL:error: to write the contents for the current device to disk.
    MTLBinaryArchive files generated for multiple different devices can be combined using the "lipo" tool into a single archive, which can then be shipped with the application.
    It is possible to maintain different archive files for different contexts; for example each level in a game may use a different cache object.
    Note: Metal maintains a separate cache of pipeline states on behalf of each app that contains all compiled code; this cache is populated as compilation occurs.
    This cache will automatically accelerate pipeline state creation after a pipeline is created for the first time.
    Use MTLBinaryArchive to augment that cache by accelerating pipeline state creation even on the first run of an app.
    Updating a MTLBinaryArchive at runtime in a shipping app configuration is not recommended; such a scenario requires corruption resiliency, careful storage space management and may cache hard-to-reproduce errors.
    These kind of issues are handled transparently by the Metal maintained cache, therefore we recommend that MTLBinaryArchive is populated during development time and shipped as an asset.
    */
    pub unsafe trait MTLBinaryArchive: NSObjectProtocol {
        #[cfg(feature = "Foundation_NSString")]
        /**
         @property label
        @abstract A string to help identify this object.
        */
        #[method_id(@__retain_semantics Other label)]
        fn label(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @property label
        @abstract A string to help identify this object.
        */
        #[method(setLabel:)]
        fn setLabel(&self, label: Option<&NSString>);

        /**
         @property device
        @abstract The device this resource was created against.  This resource can only be used with this device.
        */
        #[method_id(@__retain_semantics Other device)]
        fn device(&self) -> Id<ProtocolObject<dyn MTLDevice>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLComputePipelineDescriptor"
        ))]
        #[method(addComputePipelineFunctionsWithDescriptor:error:_)]
        fn addComputePipelineFunctionsWithDescriptor_error(
            &self,
            descriptor: &MTLComputePipelineDescriptor,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLRenderPipelineDescriptor"
        ))]
        #[method(addRenderPipelineFunctionsWithDescriptor:error:_)]
        fn addRenderPipelineFunctionsWithDescriptor_error(
            &self,
            descriptor: &MTLRenderPipelineDescriptor,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLTileRenderPipelineDescriptor"
        ))]
        #[method(addTileRenderPipelineFunctionsWithDescriptor:error:_)]
        unsafe fn addTileRenderPipelineFunctionsWithDescriptor_error(
            &self,
            descriptor: &MTLTileRenderPipelineDescriptor,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(serializeToURL:error:_)]
        fn serializeToURL_error(&self, url: &NSURL) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLFunctionDescriptor"
        ))]
        #[method(addFunctionWithDescriptor:library:error:_)]
        unsafe fn addFunctionWithDescriptor_library_error(
            &self,
            descriptor: &MTLFunctionDescriptor,
            library: &ProtocolObject<dyn MTLLibrary>,
        ) -> Result<(), Id<NSError>>;
    }

    unsafe impl ProtocolType for dyn MTLBinaryArchive {}
);
