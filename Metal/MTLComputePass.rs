//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptor")]
    pub struct MTLComputePassSampleBufferAttachmentDescriptor;

    #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptor")]
    unsafe impl ClassType for MTLComputePassSampleBufferAttachmentDescriptor {
        type Super = NSObject;
    }
);

#[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptor")]
unsafe impl NSObjectProtocol for MTLComputePassSampleBufferAttachmentDescriptor {}

extern_methods!(
    #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptor")]
    unsafe impl MTLComputePassSampleBufferAttachmentDescriptor {
        /**
         @property sampleBuffer
        @abstract The sample buffer to store samples for the compute-pass defined samples.
        If sampleBuffer is non-nil, the sample indices will be used to store samples into
        the sample buffer.  If no sample buffer is provided, no samples will be taken.
        If any of the sample indices are specified as MTLCounterDontSample, no sample
        will be taken for that action.
        */
        #[method_id(@__retain_semantics Other sampleBuffer)]
        pub unsafe fn sampleBuffer(&self)
            -> Option<Id<ProtocolObject<dyn MTLCounterSampleBuffer>>>;

        /**
         @property sampleBuffer
        @abstract The sample buffer to store samples for the compute-pass defined samples.
        If sampleBuffer is non-nil, the sample indices will be used to store samples into
        the sample buffer.  If no sample buffer is provided, no samples will be taken.
        If any of the sample indices are specified as MTLCounterDontSample, no sample
        will be taken for that action.
        */
        #[method(setSampleBuffer:)]
        pub unsafe fn setSampleBuffer(
            &self,
            sample_buffer: Option<&ProtocolObject<dyn MTLCounterSampleBuffer>>,
        );

        /**
         @property startOfEncoderSampleIndex
        @abstract The sample index to use to store the sample taken at the start of
        command encoder processing.  Setting the value to MTLCounterDontSample will cause
        this sample to be omitted.
        @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported,
        this sample index is invalid and must be set to MTLCounterDontSample or creation of a compute pass will fail.
        */
        #[method(startOfEncoderSampleIndex)]
        pub unsafe fn startOfEncoderSampleIndex(&self) -> NSUInteger;

        /**
         @property startOfEncoderSampleIndex
        @abstract The sample index to use to store the sample taken at the start of
        command encoder processing.  Setting the value to MTLCounterDontSample will cause
        this sample to be omitted.
        @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported,
        this sample index is invalid and must be set to MTLCounterDontSample or creation of a compute pass will fail.
        */
        #[method(setStartOfEncoderSampleIndex:)]
        pub unsafe fn setStartOfEncoderSampleIndex(
            &self,
            start_of_encoder_sample_index: NSUInteger,
        );

        /**
         @property endOfEncoderSampleIndex
        @abstract The sample index to use to store the sample taken at the end of
        command encoder processing.  Setting the value to MTLCounterDontSample will cause
        this sample to be omitted.
        @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported,
        this sample index is invalid and must be set to MTLCounterDontSample or creation of a compute pass will fail.
        */
        #[method(endOfEncoderSampleIndex)]
        pub unsafe fn endOfEncoderSampleIndex(&self) -> NSUInteger;

        /**
         @property endOfEncoderSampleIndex
        @abstract The sample index to use to store the sample taken at the end of
        command encoder processing.  Setting the value to MTLCounterDontSample will cause
        this sample to be omitted.
        @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported,
        this sample index is invalid and must be set to MTLCounterDontSample or creation of a compute pass will fail.
        */
        #[method(setEndOfEncoderSampleIndex:)]
        pub unsafe fn setEndOfEncoderSampleIndex(&self, end_of_encoder_sample_index: NSUInteger);
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptorArray")]
    pub struct MTLComputePassSampleBufferAttachmentDescriptorArray;

    #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptorArray")]
    unsafe impl ClassType for MTLComputePassSampleBufferAttachmentDescriptorArray {
        type Super = NSObject;
    }
);

#[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptorArray")]
unsafe impl NSObjectProtocol for MTLComputePassSampleBufferAttachmentDescriptorArray {}

extern_methods!(
    #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptorArray")]
    unsafe impl MTLComputePassSampleBufferAttachmentDescriptorArray {
        #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptor")]
        #[method_id(@__retain_semantics Other objectAtIndexedSubscript:)]
        pub unsafe fn objectAtIndexedSubscript(
            &self,
            attachment_index: NSUInteger,
        ) -> Id<MTLComputePassSampleBufferAttachmentDescriptor>;

        #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptor")]
        #[method(setObject:atIndexedSubscript:)]
        pub unsafe fn setObject_atIndexedSubscript(
            &self,
            attachment: Option<&MTLComputePassSampleBufferAttachmentDescriptor>,
            attachment_index: NSUInteger,
        );
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Metal_MTLComputePassDescriptor")]
    /**
     @class MTLComputePassDescriptor
    @abstract MTLComputePassDescriptor represents a collection of attachments to be used to create a concrete compute command encoder
    */
    pub struct MTLComputePassDescriptor;

    #[cfg(feature = "Metal_MTLComputePassDescriptor")]
    unsafe impl ClassType for MTLComputePassDescriptor {
        type Super = NSObject;
    }
);

#[cfg(feature = "Metal_MTLComputePassDescriptor")]
/**
 @class MTLComputePassDescriptor
@abstract MTLComputePassDescriptor represents a collection of attachments to be used to create a concrete compute command encoder
*/
unsafe impl NSObjectProtocol for MTLComputePassDescriptor {}

extern_methods!(
    /**
     @class MTLComputePassDescriptor
    @abstract MTLComputePassDescriptor represents a collection of attachments to be used to create a concrete compute command encoder
    */
    #[cfg(feature = "Metal_MTLComputePassDescriptor")]
    unsafe impl MTLComputePassDescriptor {
        #[method_id(@__retain_semantics Other computePassDescriptor)]
        pub unsafe fn computePassDescriptor() -> Id<MTLComputePassDescriptor>;

        /**
         @property dispatchType
        @abstract The dispatch type of the compute command encoder.
        */
        #[method(dispatchType)]
        pub unsafe fn dispatchType(&self) -> MTLDispatchType;

        /**
         @property dispatchType
        @abstract The dispatch type of the compute command encoder.
        */
        #[method(setDispatchType:)]
        pub unsafe fn setDispatchType(&self, dispatch_type: MTLDispatchType);

        #[cfg(feature = "Metal_MTLComputePassSampleBufferAttachmentDescriptorArray")]
        /**
         @property sampleBufferAttachments
        @abstract An array of sample buffers and associated sample indices.
        */
        #[method_id(@__retain_semantics Other sampleBufferAttachments)]
        pub unsafe fn sampleBufferAttachments(
            &self,
        ) -> Id<MTLComputePassSampleBufferAttachmentDescriptorArray>;
    }
);
