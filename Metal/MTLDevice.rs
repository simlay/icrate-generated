//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum MTLIOCompressionMethod {
        MTLIOCompressionMethodZlib = 0,
        MTLIOCompressionMethodLZFSE = 1,
        MTLIOCompressionMethodLZ4 = 2,
        MTLIOCompressionMethodLZMA = 3,
        MTLIOCompressionMethodLZBitmap = 4,
    }
);

extern_fn!(
    pub unsafe fn MTLCreateSystemDefaultDevice() -> *mut ProtocolObject<dyn MTLDevice>;
);

extern_fn!(
    #[cfg(feature = "Foundation_NSArray")]
    pub unsafe fn MTLCopyAllDevices() -> NonNull<NSArray<ProtocolObject<dyn MTLDevice>>>;
);

typed_enum!(
    pub type MTLDeviceNotificationName = NSString;
);

extern_static!(MTLDeviceWasAddedNotification: &'static MTLDeviceNotificationName);

extern_static!(MTLDeviceRemovalRequestedNotification: &'static MTLDeviceNotificationName);

extern_static!(MTLDeviceWasRemovedNotification: &'static MTLDeviceNotificationName);

pub type MTLDeviceNotificationHandler = *mut Block<
    (
        NonNull<ProtocolObject<dyn MTLDevice>>,
        NonNull<MTLDeviceNotificationName>,
    ),
    (),
>;

extern_fn!(
    pub unsafe fn MTLRemoveDeviceObserver(observer: &NSObject);
);

ns_enum!(
    #[underlying(NSUInteger)]
    #[deprecated = "Use MTLGPUFamily instead"]
    pub enum MTLFeatureSet {
        MTLFeatureSet_iOS_GPUFamily1_v1 = 0,
        MTLFeatureSet_iOS_GPUFamily2_v1 = 1,
        MTLFeatureSet_iOS_GPUFamily1_v2 = 2,
        MTLFeatureSet_iOS_GPUFamily2_v2 = 3,
        MTLFeatureSet_iOS_GPUFamily3_v1 = 4,
        MTLFeatureSet_iOS_GPUFamily1_v3 = 5,
        MTLFeatureSet_iOS_GPUFamily2_v3 = 6,
        MTLFeatureSet_iOS_GPUFamily3_v2 = 7,
        MTLFeatureSet_iOS_GPUFamily1_v4 = 8,
        MTLFeatureSet_iOS_GPUFamily2_v4 = 9,
        MTLFeatureSet_iOS_GPUFamily3_v3 = 10,
        MTLFeatureSet_iOS_GPUFamily4_v1 = 11,
        MTLFeatureSet_iOS_GPUFamily1_v5 = 12,
        MTLFeatureSet_iOS_GPUFamily2_v5 = 13,
        MTLFeatureSet_iOS_GPUFamily3_v4 = 14,
        MTLFeatureSet_iOS_GPUFamily4_v2 = 15,
        MTLFeatureSet_iOS_GPUFamily5_v1 = 16,
        MTLFeatureSet_macOS_GPUFamily1_v1 = 10000,
        MTLFeatureSet_OSX_GPUFamily1_v1 = MTLFeatureSet_macOS_GPUFamily1_v1,
        MTLFeatureSet_macOS_GPUFamily1_v2 = 10001,
        MTLFeatureSet_OSX_GPUFamily1_v2 = MTLFeatureSet_macOS_GPUFamily1_v2,
        MTLFeatureSet_macOS_ReadWriteTextureTier2 = 10002,
        MTLFeatureSet_OSX_ReadWriteTextureTier2 = MTLFeatureSet_macOS_ReadWriteTextureTier2,
        MTLFeatureSet_macOS_GPUFamily1_v3 = 10003,
        MTLFeatureSet_macOS_GPUFamily1_v4 = 10004,
        MTLFeatureSet_macOS_GPUFamily2_v1 = 10005,
        MTLFeatureSet_tvOS_GPUFamily1_v1 = 30000,
        MTLFeatureSet_TVOS_GPUFamily1_v1 = MTLFeatureSet_tvOS_GPUFamily1_v1,
        MTLFeatureSet_tvOS_GPUFamily1_v2 = 30001,
        MTLFeatureSet_tvOS_GPUFamily1_v3 = 30002,
        MTLFeatureSet_tvOS_GPUFamily2_v1 = 30003,
        MTLFeatureSet_tvOS_GPUFamily1_v4 = 30004,
        MTLFeatureSet_tvOS_GPUFamily2_v2 = 30005,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    pub enum MTLGPUFamily {
        MTLGPUFamilyApple1 = 1001,
        MTLGPUFamilyApple2 = 1002,
        MTLGPUFamilyApple3 = 1003,
        MTLGPUFamilyApple4 = 1004,
        MTLGPUFamilyApple5 = 1005,
        MTLGPUFamilyApple6 = 1006,
        MTLGPUFamilyApple7 = 1007,
        MTLGPUFamilyApple8 = 1008,
        #[deprecated]
        MTLGPUFamilyMac1 = 2001,
        MTLGPUFamilyMac2 = 2002,
        MTLGPUFamilyCommon1 = 3001,
        MTLGPUFamilyCommon2 = 3002,
        MTLGPUFamilyCommon3 = 3003,
        #[deprecated]
        MTLGPUFamilyMacCatalyst1 = 4001,
        #[deprecated]
        MTLGPUFamilyMacCatalyst2 = 4002,
        MTLGPUFamilyMetal3 = 5001,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLDeviceLocation
    @abstract Specifies the location of the GPU on macOS
    */
    pub enum MTLDeviceLocation {
        MTLDeviceLocationBuiltIn = 0,
        MTLDeviceLocationSlot = 1,
        MTLDeviceLocationExternal = 2,
        MTLDeviceLocationUnspecified = NSUIntegerMax as _,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLPipelineOption
    @abstract Controls the creation of the pipeline
    */
    pub enum MTLPipelineOption {
        MTLPipelineOptionNone = 0,
        MTLPipelineOptionArgumentInfo = 1 << 0,
        MTLPipelineOptionBufferTypeInfo = 1 << 1,
        MTLPipelineOptionFailOnBinaryArchiveMiss = 1 << 2,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLReadWriteTextureTier
    @abstract MTLReadWriteTextureTier determines support level for read-write texture formats.
    */
    pub enum MTLReadWriteTextureTier {
        MTLReadWriteTextureTierNone = 0,
        MTLReadWriteTextureTier1 = 1,
        MTLReadWriteTextureTier2 = 2,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLArgumentBuffersTier
    @abstract MTLArgumentBuffersTier determines support level for argument buffers.
    */
    pub enum MTLArgumentBuffersTier {
        MTLArgumentBuffersTier1 = 0,
        MTLArgumentBuffersTier2 = 1,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLSparseTextureRegionAlignmentMode
    @abstract MTLSparseTextureRegionAlignmentMode determines type of alignment used when converting from pixel region to tile region.
    */
    pub enum MTLSparseTextureRegionAlignmentMode {
        MTLSparseTextureRegionAlignmentModeOutward = 0,
        MTLSparseTextureRegionAlignmentModeInward = 1,
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    /**
     @enum MTLSparsePageSize
    @abstract Physical size of sparse resource page in KBs.
    */
    pub enum MTLSparsePageSize {
        MTLSparsePageSize16 = 101,
        MTLSparsePageSize64 = 102,
        MTLSparsePageSize256 = 103,
    }
);

extern_struct!(
    #[encoding_name("?")]
    /**
      @brief Describes the memory requirements for an acceleration structure
    */
    pub struct MTLAccelerationStructureSizes {
        pub accelerationStructureSize: NSUInteger,
        pub buildScratchBufferSize: NSUInteger,
        pub refitScratchBufferSize: NSUInteger,
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
     @enum MTLCounterSamplingPoint
    @abstract MTLCounterSamplingPoint determines type of sampling points that are supported on given device.

    @constant MTLCounterSamplingPointAtStageBoundary
    Counter sampling points at render, compute, and blit command encoder stage boundary are supported.

    @constant MTLCounterSamplingPointAtDrawBoundary
    Counter sampling at draw boundary is supported, render encoder method sampleCountersInBuffer can be used for sampling.

    @constant MTLCounterSamplingPointAtDispatchBoundary
    Counter sampling at compute dispatch boundary is supported, compute encoder method sampleCountersInBuffer can be used for sampling.

    @constant MTLCounterSamplingPointAtTileDispatchBoundary
    Counter sampling at tile shader dispatch boundary is supported.

    @constant MTLCounterSamplingPointAtBlitBoundary
    Counter sampling at blit boundary is supported, blit encoder method sampleCountersInBuffer can be used for sampling.
    */
    pub enum MTLCounterSamplingPoint {
        MTLCounterSamplingPointAtStageBoundary = 0,
        MTLCounterSamplingPointAtDrawBoundary = 1,
        MTLCounterSamplingPointAtDispatchBoundary = 2,
        MTLCounterSamplingPointAtTileDispatchBoundary = 3,
        MTLCounterSamplingPointAtBlitBoundary = 4,
    }
);

extern_struct!(
    #[encoding_name("?")]
    /**
     @abstract Represent a memory size and alignment in bytes.
    */
    pub struct MTLSizeAndAlign {
        pub size: NSUInteger,
        pub align: NSUInteger,
    }
);

pub type MTLNewLibraryCompletionHandler =
    *mut Block<(*mut ProtocolObject<dyn MTLLibrary>, *mut NSError), ()>;

pub type MTLNewRenderPipelineStateCompletionHandler = *mut Block<
    (
        *mut ProtocolObject<dyn MTLRenderPipelineState>,
        *mut NSError,
    ),
    (),
>;

pub type MTLNewRenderPipelineStateWithReflectionCompletionHandler = *mut Block<
    (
        *mut ProtocolObject<dyn MTLRenderPipelineState>,
        *mut MTLRenderPipelineReflection,
        *mut NSError,
    ),
    (),
>;

pub type MTLNewComputePipelineStateCompletionHandler = *mut Block<
    (
        *mut ProtocolObject<dyn MTLComputePipelineState>,
        *mut NSError,
    ),
    (),
>;

pub type MTLNewComputePipelineStateWithReflectionCompletionHandler = *mut Block<
    (
        *mut ProtocolObject<dyn MTLComputePipelineState>,
        *mut MTLComputePipelineReflection,
        *mut NSError,
    ),
    (),
>;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Metal_MTLArgumentDescriptor")]
    /**
      @class MTLArgumentDescriptor
     @abstract Represents a member of an argument buffer
    */
    pub struct MTLArgumentDescriptor;

    #[cfg(feature = "Metal_MTLArgumentDescriptor")]
    unsafe impl ClassType for MTLArgumentDescriptor {
        type Super = NSObject;
    }
);

#[cfg(feature = "Metal_MTLArgumentDescriptor")]
/**
  @class MTLArgumentDescriptor
 @abstract Represents a member of an argument buffer
*/
unsafe impl NSObjectProtocol for MTLArgumentDescriptor {}

extern_methods!(
    /**
      @class MTLArgumentDescriptor
     @abstract Represents a member of an argument buffer
    */
    #[cfg(feature = "Metal_MTLArgumentDescriptor")]
    unsafe impl MTLArgumentDescriptor {
        #[method_id(@__retain_semantics Other argumentDescriptor)]
        pub fn argumentDescriptor() -> Id<MTLArgumentDescriptor>;

        /**
          @property dataType
         @abstract For constants, the data type. Otherwise, MTLDataTypeTexture, MTLDataTypeSampler, or
         MTLDataTypePointer.
        */
        #[method(dataType)]
        pub unsafe fn dataType(&self) -> MTLDataType;

        /**
          @property dataType
         @abstract For constants, the data type. Otherwise, MTLDataTypeTexture, MTLDataTypeSampler, or
         MTLDataTypePointer.
        */
        #[method(setDataType:)]
        pub fn setDataType(&self, data_type: MTLDataType);

        /**
          @property index
         @abstract The binding point index of the argument
        */
        #[method(index)]
        pub unsafe fn index(&self) -> NSUInteger;

        /**
          @property index
         @abstract The binding point index of the argument
        */
        #[method(setIndex:)]
        pub fn setIndex(&self, index: NSUInteger);

        /**
          @property arrayLength
         @abstract The length of an array of constants, textures, or samplers, or 0 for non-array arguments
        */
        #[method(arrayLength)]
        pub unsafe fn arrayLength(&self) -> NSUInteger;

        /**
          @property arrayLength
         @abstract The length of an array of constants, textures, or samplers, or 0 for non-array arguments
        */
        #[method(setArrayLength:)]
        pub unsafe fn setArrayLength(&self, array_length: NSUInteger);

        /**
          @property access
         @abstract Access flags for the argument
        */
        #[method(access)]
        pub unsafe fn access(&self) -> MTLArgumentAccess;

        /**
          @property access
         @abstract Access flags for the argument
        */
        #[method(setAccess:)]
        pub fn setAccess(&self, access: MTLArgumentAccess);

        /**
          @property textureType
         @abstract For texture arguments, the texture type
        */
        #[method(textureType)]
        pub unsafe fn textureType(&self) -> MTLTextureType;

        /**
          @property textureType
         @abstract For texture arguments, the texture type
        */
        #[method(setTextureType:)]
        pub fn setTextureType(&self, texture_type: MTLTextureType);

        /**
         @property constantBlockAlignment
        @abstract if set forces the constant block to be aligned to the given alignment
        @discussion Should only be set on the first constant of the block and is only valid if a corresponding
        explicit "alignas" is applied to the constant in the metal shader language.
        */
        #[method(constantBlockAlignment)]
        pub unsafe fn constantBlockAlignment(&self) -> NSUInteger;

        /**
         @property constantBlockAlignment
        @abstract if set forces the constant block to be aligned to the given alignment
        @discussion Should only be set on the first constant of the block and is only valid if a corresponding
        explicit "alignas" is applied to the constant in the metal shader language.
        */
        #[method(setConstantBlockAlignment:)]
        pub unsafe fn setConstantBlockAlignment(&self, constant_block_alignment: NSUInteger);
    }
);

pub type MTLTimestamp = u64;

extern_protocol!(
    /**
     @protocol MTLDevice
    @abstract MTLDevice represents a processor capable of data parallel computations
    */
    pub unsafe trait MTLDevice: NSObjectProtocol {
        #[cfg(feature = "Foundation_NSString")]
        /**
         @property name
        @abstract The full name of the vendor device.
        */
        #[method_id(@__retain_semantics Other name)]
        fn name(&self) -> Id<NSString>;

        /**
         @property registryID
        @abstract Returns the IORegistry ID for the Metal device
        @discussion The registryID value for a Metal device is global to all tasks, and may be used
        to identify the GPU across task boundaries.
        */
        #[method(registryID)]
        fn registryID(&self) -> u64;

        /**
         @property maxThreadsPerThreadgroup
        @abstract The maximum number of threads along each dimension.
        */
        #[method(maxThreadsPerThreadgroup)]
        fn maxThreadsPerThreadgroup(&self) -> MTLSize;

        /**
         @property lowPower
        @abstract On systems that support automatic graphics switching, this will return YES for the the low power device.
        */
        #[method(isLowPower)]
        fn isLowPower(&self) -> bool;

        /**
         @property headless
        @abstract On systems that include more that one GPU, this will return YES for any device that does not support any displays.  Only available on Mac OS X.
        */
        #[method(isHeadless)]
        fn isHeadless(&self) -> bool;

        /**
         @property removable
        @abstract If this GPU is removable, this property will return YES.
        @discussion If a GPU is is removed without warning, APIs may fail even with good input, even before a notification can get posted informing
        the application that the device has been removed.
        */
        #[method(isRemovable)]
        fn isRemovable(&self) -> bool;

        /**
         @property hasUnifiedMemory
        @abstract Returns YES if this GPU shares its memory with the rest of the machine (CPU, etc.)
        @discussion Some GPU architectures do not have dedicated local memory and instead only use the same memory shared with the rest
        of the machine.  This property will return YES for GPUs that fall into that category.
        */
        #[method(hasUnifiedMemory)]
        fn hasUnifiedMemory(&self) -> bool;

        /**
         @property recommendedMaxWorkingSetSize
        @abstract Returns an approximation of how much memory this device can use with good performance.
        @discussion Performance may be improved by keeping the total size of all resources (texture and buffers)
        and heaps less than this threshold, beyond which the device is likely to be overcommitted and incur a
        performance penalty.
        */
        #[method(recommendedMaxWorkingSetSize)]
        fn recommendedMaxWorkingSetSize(&self) -> u64;

        /**
         @property location
        @abstract Returns an enum that indicates where the GPU is located relative to the host computer.
        @discussion The returned value indicates if the GPU is built into the computer, inserted into
        a slot internal to the computer, or external to the computer. Otherwise it is Unspecified
        */
        #[method(location)]
        fn location(&self) -> MTLDeviceLocation;

        /**
         @property locationNumber
        @abstract Returns a value that further specifies the GPU's location
        @discussion The returned value indicates which slot or Thunderbolt port the GPU is attached
        to. For Built-in GPUs, if LowPower this value is 0, otherwise it is 1.  It is possible for multiple GPUs to have
        the same location and locationNumber; e.g.: A PCI card with multiple GPUs, or an eGPU
        daisy-chained off of another eGPU attached to a host Thunderbolt port.
        */
        #[method(locationNumber)]
        fn locationNumber(&self) -> NSUInteger;

        /**
         @property maxTransferRate
        @abstract Upper bound of System RAM <=> VRAM transfer rate in bytes/sec
        @discussion The returned value indicates the theoretical maximum data rate in bytes/second
        from host memory to the GPU's VRAM. This is derived from the raw data clock rate and as
        such may not be reachable under real-world conditions. For Built-in GPUs this value is 0.
        */
        #[method(maxTransferRate)]
        fn maxTransferRate(&self) -> u64;

        /**
         @property depth24Stencil8PixelFormatSupported
        @abstract If YES, device supports MTLPixelFormatDepth24Unorm_Stencil8.
        */
        #[method(isDepth24Stencil8PixelFormatSupported)]
        fn isDepth24Stencil8PixelFormatSupported(&self) -> bool;

        /**
         @property readWriteTextureSupport
        @abstract Query support tier for read-write texture formats.
        @return MTLReadWriteTextureTier enum value.
        */
        #[method(readWriteTextureSupport)]
        fn readWriteTextureSupport(&self) -> MTLReadWriteTextureTier;

        /**
         @property argumentBuffersSupport
        @abstract Query support tier for Argument Buffers.
        @return MTLArgumentBuffersTier enum value.
        */
        #[method(argumentBuffersSupport)]
        fn argumentBuffersSupport(&self) -> MTLArgumentBuffersTier;

        /**
         @property rasterOrderGroupsSupported
        @abstract Query device for raster order groups support.
        @return BOOL value. If YES, the device supports raster order groups. If NO, the device does not.
        */
        #[method(areRasterOrderGroupsSupported)]
        unsafe fn areRasterOrderGroupsSupported(&self) -> bool;

        /**
         @property supports32BitFloatFiltering
        @abstract Query device for 32-bit Float texture filtering support. Specifically, R32Float, RG32Float, and RGBA32Float.
        @return BOOL value. If YES, the device supports filtering 32-bit Float textures. If NO, the device does not.
        */
        #[method(supports32BitFloatFiltering)]
        fn supports32BitFloatFiltering(&self) -> bool;

        /**
         @property supports32BitMSAA
        @abstract Query device for 32-bit MSAA texture support. Specifically, added support for allocating 32-bit Integer format textures (R32Uint, R32Sint, RG32Uint, RG32Sint, RGBA32Uint, and RGBA32Sint) and resolving 32-bit Float format textures (R32Float, RG32Float, and RGBA32Float).
        @return BOOL value. If YES, the device supports these additional 32-bit MSAA texture capabilities. If NO, the devices does not.
        */
        #[method(supports32BitMSAA)]
        fn supports32BitMSAA(&self) -> bool;

        /**
         @property supportsQueryTextureLOD
        @abstract Query device for whether it supports the `calculate_clampled_lod` and `calculate_unclamped_lod` Metal shading language functionality.
        @return BOOL value. If YES, the device supports the calculate LOD functionality. If NO, the device does not.
        */
        #[method(supportsQueryTextureLOD)]
        fn supportsQueryTextureLOD(&self) -> bool;

        /**
         @property supportsBCTextureCompression
        @abstract Query device for BC Texture format support
        @return BOOL value. If YES, the device supports compressed BC Texture formats. If NO, the device does not.
        */
        #[method(supportsBCTextureCompression)]
        fn supportsBCTextureCompression(&self) -> bool;

        /**
         @property supportsPullModelInterpolation
        @abstract Query device for pull model interpolation support which allows a fragment shader to compute multiple interpolations (at center, at centroid, at offset, at sample) of a fragment input.
        @return BOOL value. If YES, the device supports pull model interpolation. If NO, the device does not.
        */
        #[method(supportsPullModelInterpolation)]
        fn supportsPullModelInterpolation(&self) -> bool;

        /**
         @property barycentricsSupported
        @abstract Query device for Barycentric coordinates support; deprecated, use supportsShaderBarycentricCoordinates
        @return BOOL value. If YES, the device barycentric coordinates
        */
        #[deprecated]
        #[method(areBarycentricCoordsSupported)]
        unsafe fn areBarycentricCoordsSupported(&self) -> bool;

        /**
         @property supportsShaderBarycentricCoordinates
        @abstract Query device for Barycentric Coordinates support.
        @return BOOL value. If YES, the device supports barycentric coordinates. If NO, the device does not.
        */
        #[method(supportsShaderBarycentricCoordinates)]
        fn supportsShaderBarycentricCoordinates(&self) -> bool;

        /**
         @property currentAllocatedSize
        @abstract The current size in bytes of all resources allocated by this device
        */
        #[method(currentAllocatedSize)]
        fn currentAllocatedSize(&self) -> NSUInteger;

        #[method_id(@__retain_semantics New newCommandQueue)]
        fn newCommandQueue(&self) -> Option<Id<ProtocolObject<dyn MTLCommandQueue>>>;

        #[method_id(@__retain_semantics New newCommandQueueWithMaxCommandBufferCount:)]
        fn newCommandQueueWithMaxCommandBufferCount(
            &self,
            max_command_buffer_count: NSUInteger,
        ) -> Option<Id<ProtocolObject<dyn MTLCommandQueue>>>;

        #[cfg(feature = "Metal_MTLTextureDescriptor")]
        #[method(heapTextureSizeAndAlignWithDescriptor:)]
        fn heapTextureSizeAndAlignWithDescriptor(
            &self,
            desc: &MTLTextureDescriptor,
        ) -> MTLSizeAndAlign;

        #[method(heapBufferSizeAndAlignWithLength:options:)]
        fn heapBufferSizeAndAlignWithLength_options(
            &self,
            length: NSUInteger,
            options: MTLResourceOptions,
        ) -> MTLSizeAndAlign;

        #[cfg(feature = "Metal_MTLHeapDescriptor")]
        #[method_id(@__retain_semantics New newHeapWithDescriptor:)]
        fn newHeapWithDescriptor(
            &self,
            descriptor: &MTLHeapDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLHeap>>>;

        #[method_id(@__retain_semantics New newBufferWithLength:options:)]
        fn newBufferWithLength_options(
            &self,
            length: NSUInteger,
            options: MTLResourceOptions,
        ) -> Option<Id<ProtocolObject<dyn MTLBuffer>>>;

        #[method_id(@__retain_semantics New newBufferWithBytes:length:options:)]
        unsafe fn newBufferWithBytes_length_options(
            &self,
            pointer: NonNull<c_void>,
            length: NSUInteger,
            options: MTLResourceOptions,
        ) -> Option<Id<ProtocolObject<dyn MTLBuffer>>>;

        #[method_id(@__retain_semantics New newBufferWithBytesNoCopy:length:options:deallocator:)]
        unsafe fn newBufferWithBytesNoCopy_length_options_deallocator(
            &self,
            pointer: NonNull<c_void>,
            length: NSUInteger,
            options: MTLResourceOptions,
            deallocator: Option<&Block<(NonNull<c_void>, NSUInteger), ()>>,
        ) -> Option<Id<ProtocolObject<dyn MTLBuffer>>>;

        #[cfg(feature = "Metal_MTLDepthStencilDescriptor")]
        #[method_id(@__retain_semantics New newDepthStencilStateWithDescriptor:)]
        fn newDepthStencilStateWithDescriptor(
            &self,
            descriptor: &MTLDepthStencilDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLDepthStencilState>>>;

        #[cfg(feature = "Metal_MTLTextureDescriptor")]
        #[method_id(@__retain_semantics New newTextureWithDescriptor:)]
        fn newTextureWithDescriptor(
            &self,
            descriptor: &MTLTextureDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLTexture>>>;

        #[cfg(feature = "Metal_MTLTextureDescriptor")]
        #[method_id(@__retain_semantics New newSharedTextureWithDescriptor:)]
        unsafe fn newSharedTextureWithDescriptor(
            &self,
            descriptor: &MTLTextureDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLTexture>>>;

        #[cfg(feature = "Metal_MTLSharedTextureHandle")]
        #[method_id(@__retain_semantics New newSharedTextureWithHandle:)]
        unsafe fn newSharedTextureWithHandle(
            &self,
            shared_handle: &MTLSharedTextureHandle,
        ) -> Option<Id<ProtocolObject<dyn MTLTexture>>>;

        #[cfg(feature = "Metal_MTLSamplerDescriptor")]
        #[method_id(@__retain_semantics New newSamplerStateWithDescriptor:)]
        fn newSamplerStateWithDescriptor(
            &self,
            descriptor: &MTLSamplerDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLSamplerState>>>;

        #[method_id(@__retain_semantics New newDefaultLibrary)]
        fn newDefaultLibrary(&self) -> Option<Id<ProtocolObject<dyn MTLLibrary>>>;

        #[cfg(all(feature = "Foundation_NSBundle", feature = "Foundation_NSError"))]
        #[method_id(@__retain_semantics New newDefaultLibraryWithBundle:error:_)]
        unsafe fn newDefaultLibraryWithBundle_error(
            &self,
            bundle: &NSBundle,
        ) -> Result<Id<ProtocolObject<dyn MTLLibrary>>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSString"))]
        #[deprecated = "Use -newLibraryWithURL:error: instead"]
        #[method_id(@__retain_semantics New newLibraryWithFile:error:_)]
        fn newLibraryWithFile_error(
            &self,
            filepath: &NSString,
        ) -> Result<Id<ProtocolObject<dyn MTLLibrary>>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics New newLibraryWithURL:error:_)]
        unsafe fn newLibraryWithURL_error(
            &self,
            url: &NSURL,
        ) -> Result<Id<ProtocolObject<dyn MTLLibrary>>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSString",
            feature = "Metal_MTLCompileOptions"
        ))]
        #[method_id(@__retain_semantics New newLibraryWithSource:options:error:_)]
        fn newLibraryWithSource_options_error(
            &self,
            source: &NSString,
            options: Option<&MTLCompileOptions>,
        ) -> Result<Id<ProtocolObject<dyn MTLLibrary>>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Metal_MTLCompileOptions"))]
        #[method(newLibraryWithSource:options:completionHandler:)]
        unsafe fn newLibraryWithSource_options_completionHandler(
            &self,
            source: &NSString,
            options: Option<&MTLCompileOptions>,
            completion_handler: MTLNewLibraryCompletionHandler,
        );

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLStitchedLibraryDescriptor"
        ))]
        #[method_id(@__retain_semantics New newLibraryWithStitchedDescriptor:error:_)]
        unsafe fn newLibraryWithStitchedDescriptor_error(
            &self,
            descriptor: &MTLStitchedLibraryDescriptor,
        ) -> Result<Id<ProtocolObject<dyn MTLLibrary>>, Id<NSError>>;

        #[cfg(feature = "Metal_MTLStitchedLibraryDescriptor")]
        #[method(newLibraryWithStitchedDescriptor:completionHandler:)]
        unsafe fn newLibraryWithStitchedDescriptor_completionHandler(
            &self,
            descriptor: &MTLStitchedLibraryDescriptor,
            completion_handler: MTLNewLibraryCompletionHandler,
        );

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLRenderPipelineDescriptor"
        ))]
        #[method_id(@__retain_semantics New newRenderPipelineStateWithDescriptor:error:_)]
        fn newRenderPipelineStateWithDescriptor_error(
            &self,
            descriptor: &MTLRenderPipelineDescriptor,
        ) -> Result<Id<ProtocolObject<dyn MTLRenderPipelineState>>, Id<NSError>>;

        #[cfg(feature = "Metal_MTLRenderPipelineDescriptor")]
        #[method(newRenderPipelineStateWithDescriptor:completionHandler:)]
        unsafe fn newRenderPipelineStateWithDescriptor_completionHandler(
            &self,
            descriptor: &MTLRenderPipelineDescriptor,
            completion_handler: MTLNewRenderPipelineStateCompletionHandler,
        );

        #[cfg(feature = "Metal_MTLRenderPipelineDescriptor")]
        #[method(newRenderPipelineStateWithDescriptor:options:completionHandler:)]
        unsafe fn newRenderPipelineStateWithDescriptor_options_completionHandler(
            &self,
            descriptor: &MTLRenderPipelineDescriptor,
            options: MTLPipelineOption,
            completion_handler: MTLNewRenderPipelineStateWithReflectionCompletionHandler,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method_id(@__retain_semantics New newComputePipelineStateWithFunction:error:_)]
        fn newComputePipelineStateWithFunction_error(
            &self,
            compute_function: &ProtocolObject<dyn MTLFunction>,
        ) -> Result<Id<ProtocolObject<dyn MTLComputePipelineState>>, Id<NSError>>;

        #[method(newComputePipelineStateWithFunction:completionHandler:)]
        unsafe fn newComputePipelineStateWithFunction_completionHandler(
            &self,
            compute_function: &ProtocolObject<dyn MTLFunction>,
            completion_handler: MTLNewComputePipelineStateCompletionHandler,
        );

        #[method(newComputePipelineStateWithFunction:options:completionHandler:)]
        unsafe fn newComputePipelineStateWithFunction_options_completionHandler(
            &self,
            compute_function: &ProtocolObject<dyn MTLFunction>,
            options: MTLPipelineOption,
            completion_handler: MTLNewComputePipelineStateWithReflectionCompletionHandler,
        );

        #[cfg(feature = "Metal_MTLComputePipelineDescriptor")]
        #[method(newComputePipelineStateWithDescriptor:options:completionHandler:)]
        unsafe fn newComputePipelineStateWithDescriptor_options_completionHandler(
            &self,
            descriptor: &MTLComputePipelineDescriptor,
            options: MTLPipelineOption,
            completion_handler: MTLNewComputePipelineStateWithReflectionCompletionHandler,
        );

        #[method_id(@__retain_semantics New newFence)]
        fn newFence(&self) -> Option<Id<ProtocolObject<dyn MTLFence>>>;

        #[deprecated = "Use supportsFamily instead"]
        #[method(supportsFeatureSet:)]
        fn supportsFeatureSet(&self, feature_set: MTLFeatureSet) -> bool;

        #[method(supportsFamily:)]
        fn supportsFamily(&self, gpu_family: MTLGPUFamily) -> bool;

        #[method(supportsTextureSampleCount:)]
        fn supportsTextureSampleCount(&self, sample_count: NSUInteger) -> bool;

        #[method(minimumLinearTextureAlignmentForPixelFormat:)]
        fn minimumLinearTextureAlignmentForPixelFormat(&self, format: MTLPixelFormat)
            -> NSUInteger;

        #[method(minimumTextureBufferAlignmentForPixelFormat:)]
        fn minimumTextureBufferAlignmentForPixelFormat(&self, format: MTLPixelFormat)
            -> NSUInteger;

        #[cfg(feature = "Metal_MTLTileRenderPipelineDescriptor")]
        #[method(newRenderPipelineStateWithTileDescriptor:options:completionHandler:)]
        unsafe fn newRenderPipelineStateWithTileDescriptor_options_completionHandler(
            &self,
            descriptor: &MTLTileRenderPipelineDescriptor,
            options: MTLPipelineOption,
            completion_handler: MTLNewRenderPipelineStateWithReflectionCompletionHandler,
        );

        #[cfg(feature = "Metal_MTLMeshRenderPipelineDescriptor")]
        #[method(newRenderPipelineStateWithMeshDescriptor:options:completionHandler:)]
        unsafe fn newRenderPipelineStateWithMeshDescriptor_options_completionHandler(
            &self,
            descriptor: &MTLMeshRenderPipelineDescriptor,
            options: MTLPipelineOption,
            completion_handler: MTLNewRenderPipelineStateWithReflectionCompletionHandler,
        );

        /**
         @property maxThreadgroupMemoryLength
        @abstract The maximum threadgroup memory available, in bytes.
        */
        #[method(maxThreadgroupMemoryLength)]
        fn maxThreadgroupMemoryLength(&self) -> NSUInteger;

        /**
         @property maxArgumentBufferSamplerCount
        @abstract The maximum number of unique argument buffer samplers per app.
        @discussion This limit is only applicable to samplers that have their supportArgumentBuffers property set to true. A MTLSamplerState object is considered unique if the configuration of its originating MTLSamplerDescriptor properties is unique. For example, two samplers with equal minFilter values but different magFilter values are considered unique.
        */
        #[method(maxArgumentBufferSamplerCount)]
        fn maxArgumentBufferSamplerCount(&self) -> NSUInteger;

        /**
         @property programmableSaplePositionsSupported
        @abstract Query device for programmable sample position support.
        @return BOOL value. If YES, the device supports programmable sample positions. If NO, the device does not.
        */
        #[method(areProgrammableSamplePositionsSupported)]
        unsafe fn areProgrammableSamplePositionsSupported(&self) -> bool;

        #[method(getDefaultSamplePositions:count:)]
        unsafe fn getDefaultSamplePositions_count(
            &self,
            positions: NonNull<MTLSamplePosition>,
            count: NSUInteger,
        );

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Metal_MTLArgumentDescriptor"
        ))]
        #[method_id(@__retain_semantics New newArgumentEncoderWithArguments:)]
        fn newArgumentEncoderWithArguments(
            &self,
            arguments: &NSArray<MTLArgumentDescriptor>,
        ) -> Option<Id<ProtocolObject<dyn MTLArgumentEncoder>>>;

        #[method(supportsRasterizationRateMapWithLayerCount:)]
        unsafe fn supportsRasterizationRateMapWithLayerCount(
            &self,
            layer_count: NSUInteger,
        ) -> bool;

        #[cfg(feature = "Metal_MTLRasterizationRateMapDescriptor")]
        #[method_id(@__retain_semantics New newRasterizationRateMapWithDescriptor:)]
        unsafe fn newRasterizationRateMapWithDescriptor(
            &self,
            descriptor: &MTLRasterizationRateMapDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLRasterizationRateMap>>>;

        #[cfg(feature = "Metal_MTLIndirectCommandBufferDescriptor")]
        #[method_id(@__retain_semantics New newIndirectCommandBufferWithDescriptor:maxCommandCount:options:)]
        unsafe fn newIndirectCommandBufferWithDescriptor_maxCommandCount_options(
            &self,
            descriptor: &MTLIndirectCommandBufferDescriptor,
            max_count: NSUInteger,
            options: MTLResourceOptions,
        ) -> Option<Id<ProtocolObject<dyn MTLIndirectCommandBuffer>>>;

        #[method_id(@__retain_semantics New newEvent)]
        fn newEvent(&self) -> Option<Id<ProtocolObject<dyn MTLEvent>>>;

        #[method_id(@__retain_semantics New newSharedEvent)]
        fn newSharedEvent(&self) -> Option<Id<ProtocolObject<dyn MTLSharedEvent>>>;

        #[cfg(feature = "Metal_MTLSharedEventHandle")]
        #[method_id(@__retain_semantics New newSharedEventWithHandle:)]
        unsafe fn newSharedEventWithHandle(
            &self,
            shared_event_handle: &MTLSharedEventHandle,
        ) -> Option<Id<ProtocolObject<dyn MTLSharedEvent>>>;

        /**
         @property peerGroupID
        @abstract If a device supports peer to peer transfers with another device (or devices), this property will return
        a unique 64-bit identifier associated with all devices in the same peer group.
        */
        #[method(peerGroupID)]
        unsafe fn peerGroupID(&self) -> u64;

        /**
         @property peerIndex
        @abstract All Metal devices that are part of the same peer group will have a unique index value within the group in
        the range from 0 to peerCount - 1.
        */
        #[method(peerIndex)]
        unsafe fn peerIndex(&self) -> u32;

        /**
         @property peerCount
        @abstract For Metal devices that are part of a peer group, this property returns the total number of devices in that group.
        */
        #[method(peerCount)]
        unsafe fn peerCount(&self) -> u32;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics New newIOHandleWithURL:error:_)]
        unsafe fn newIOHandleWithURL_error(
            &self,
            url: &NSURL,
        ) -> Result<Id<ProtocolObject<dyn MTLIOFileHandle>>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLIOCommandQueueDescriptor"
        ))]
        #[method_id(@__retain_semantics New newIOCommandQueueWithDescriptor:error:_)]
        unsafe fn newIOCommandQueueWithDescriptor_error(
            &self,
            descriptor: &MTLIOCommandQueueDescriptor,
        ) -> Result<Id<ProtocolObject<dyn MTLIOCommandQueue>>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics New newIOHandleWithURL:compressionMethod:error:_)]
        unsafe fn newIOHandleWithURL_compressionMethod_error(
            &self,
            url: &NSURL,
            compression_method: MTLIOCompressionMethod,
        ) -> Result<Id<ProtocolObject<dyn MTLIOFileHandle>>, Id<NSError>>;

        #[method(sparseTileSizeWithTextureType:pixelFormat:sampleCount:)]
        unsafe fn sparseTileSizeWithTextureType_pixelFormat_sampleCount(
            &self,
            texture_type: MTLTextureType,
            pixel_format: MTLPixelFormat,
            sample_count: NSUInteger,
        ) -> MTLSize;

        /**
         @property sparseTileSizeInBytes
        @abstract Returns the number of bytes required to map one sparse texture tile.
        */
        #[method(sparseTileSizeInBytes)]
        unsafe fn sparseTileSizeInBytes(&self) -> NSUInteger;

        #[optional]
        #[method(convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:)]
        unsafe fn convertSparsePixelRegions_toTileRegions_withTileSize_alignmentMode_numRegions(
            &self,
            pixel_regions: NonNull<MTLRegion>,
            tile_regions: NonNull<MTLRegion>,
            tile_size: MTLSize,
            mode: MTLSparseTextureRegionAlignmentMode,
            num_regions: NSUInteger,
        );

        #[optional]
        #[method(convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:)]
        unsafe fn convertSparseTileRegions_toPixelRegions_withTileSize_numRegions(
            &self,
            tile_regions: NonNull<MTLRegion>,
            pixel_regions: NonNull<MTLRegion>,
            tile_size: MTLSize,
            num_regions: NSUInteger,
        );

        #[method(sparseTileSizeInBytesForSparsePageSize:)]
        unsafe fn sparseTileSizeInBytesForSparsePageSize(
            &self,
            sparse_page_size: MTLSparsePageSize,
        ) -> NSUInteger;

        #[method(sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize:)]
        unsafe fn sparseTileSizeWithTextureType_pixelFormat_sampleCount_sparsePageSize(
            &self,
            texture_type: MTLTextureType,
            pixel_format: MTLPixelFormat,
            sample_count: NSUInteger,
            sparse_page_size: MTLSparsePageSize,
        ) -> MTLSize;

        #[method(maxBufferLength)]
        fn maxBufferLength(&self) -> NSUInteger;

        #[cfg(feature = "Foundation_NSArray")]
        /**
         @property counterSets
        @abstract Returns the set of Counter Sets exposed by the device.
        */
        #[method_id(@__retain_semantics Other counterSets)]
        unsafe fn counterSets(&self) -> Option<Id<NSArray<ProtocolObject<dyn MTLCounterSet>>>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLCounterSampleBufferDescriptor"
        ))]
        #[method_id(@__retain_semantics New newCounterSampleBufferWithDescriptor:error:_)]
        unsafe fn newCounterSampleBufferWithDescriptor_error(
            &self,
            descriptor: &MTLCounterSampleBufferDescriptor,
        ) -> Result<Id<ProtocolObject<dyn MTLCounterSampleBuffer>>, Id<NSError>>;

        #[method(sampleTimestamps:gpuTimestamp:)]
        unsafe fn sampleTimestamps_gpuTimestamp(
            &self,
            cpu_timestamp: NonNull<MTLTimestamp>,
            gpu_timestamp: NonNull<MTLTimestamp>,
        );

        #[method_id(@__retain_semantics New newArgumentEncoderWithBufferBinding:)]
        unsafe fn newArgumentEncoderWithBufferBinding(
            &self,
            buffer_binding: &ProtocolObject<dyn MTLBufferBinding>,
        ) -> Id<ProtocolObject<dyn MTLArgumentEncoder>>;

        #[method(supportsCounterSampling:)]
        fn supportsCounterSampling(&self, sampling_point: MTLCounterSamplingPoint) -> bool;

        #[method(supportsVertexAmplificationCount:)]
        fn supportsVertexAmplificationCount(&self, count: NSUInteger) -> bool;

        /**
         @property supportsDynamicLibraries
        @abstract Query device support for creating and using dynamic libraries in a compute pipeline.
        @return BOOL value. If YES, the device supports creating and using dynamic libraries in a compute pipeline. If NO, the device does not.
        */
        #[method(supportsDynamicLibraries)]
        fn supportsDynamicLibraries(&self) -> bool;

        /**
         @property supportsRenderDynamicLibraries
        @abstract Query device support for creating and using dynamic libraries in render pipeline stages.
        @return BOOL value. If YES, the device supports creating and using dynamic libraries in render pipeline stages. If NO, the device does not.
        */
        #[method(supportsRenderDynamicLibraries)]
        unsafe fn supportsRenderDynamicLibraries(&self) -> bool;

        #[cfg(feature = "Foundation_NSError")]
        #[method_id(@__retain_semantics New newDynamicLibrary:error:_)]
        fn newDynamicLibrary_error(
            &self,
            library: &ProtocolObject<dyn MTLLibrary>,
        ) -> Result<Id<ProtocolObject<dyn MTLDynamicLibrary>>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics New newDynamicLibraryWithURL:error:_)]
        fn newDynamicLibraryWithURL_error(
            &self,
            url: &NSURL,
        ) -> Result<Id<ProtocolObject<dyn MTLDynamicLibrary>>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Metal_MTLBinaryArchiveDescriptor"
        ))]
        #[method_id(@__retain_semantics New newBinaryArchiveWithDescriptor:error:_)]
        fn newBinaryArchiveWithDescriptor_error(
            &self,
            descriptor: &MTLBinaryArchiveDescriptor,
        ) -> Result<Id<ProtocolObject<dyn MTLBinaryArchive>>, Id<NSError>>;

        /**
         @property supportsRaytracing
        @abstract Query device support for using ray tracing from compute pipelines.
        @return BOOL value. If YES, the device supports ray tracing from compute pipelines. If NO, the device does not.
        */
        #[method(supportsRaytracing)]
        fn supportsRaytracing(&self) -> bool;

        #[cfg(feature = "Metal_MTLAccelerationStructureDescriptor")]
        #[method(accelerationStructureSizesWithDescriptor:)]
        fn accelerationStructureSizesWithDescriptor(
            &self,
            descriptor: &MTLAccelerationStructureDescriptor,
        ) -> MTLAccelerationStructureSizes;

        #[method_id(@__retain_semantics New newAccelerationStructureWithSize:)]
        fn newAccelerationStructureWithSize(
            &self,
            size: NSUInteger,
        ) -> Option<Id<ProtocolObject<dyn MTLAccelerationStructure>>>;

        #[cfg(feature = "Metal_MTLAccelerationStructureDescriptor")]
        #[method_id(@__retain_semantics New newAccelerationStructureWithDescriptor:)]
        unsafe fn newAccelerationStructureWithDescriptor(
            &self,
            descriptor: &MTLAccelerationStructureDescriptor,
        ) -> Option<Id<ProtocolObject<dyn MTLAccelerationStructure>>>;

        #[method(heapAccelerationStructureSizeAndAlignWithSize:)]
        unsafe fn heapAccelerationStructureSizeAndAlignWithSize(
            &self,
            size: NSUInteger,
        ) -> MTLSizeAndAlign;

        #[cfg(feature = "Metal_MTLAccelerationStructureDescriptor")]
        #[method(heapAccelerationStructureSizeAndAlignWithDescriptor:)]
        unsafe fn heapAccelerationStructureSizeAndAlignWithDescriptor(
            &self,
            descriptor: &MTLAccelerationStructureDescriptor,
        ) -> MTLSizeAndAlign;

        /**
         @property supportsFunctionPointers
        @abstract Query device support for using function pointers from compute pipelines.
        @return BOOL value. If YES, the device supports function pointers from compute pipelines. If NO, the device does not.
        */
        #[method(supportsFunctionPointers)]
        fn supportsFunctionPointers(&self) -> bool;

        /**
         @property supportsFunctionPointersFromRender
        @abstract Query device support for using function pointers from render pipeline stages.
        @return BOOL value. If YES, the device supports function pointers from render pipeline stages. If NO, the device does not.
        */
        #[method(supportsFunctionPointersFromRender)]
        unsafe fn supportsFunctionPointersFromRender(&self) -> bool;

        /**
         @property supportsRaytracingFromRender
        @abstract Query device support for using ray tracing from render pipeline stages.
        @return BOOL value. If YES, the device supports ray tracing from render pipeline stages. If NO, the device does not.
        */
        #[method(supportsRaytracingFromRender)]
        unsafe fn supportsRaytracingFromRender(&self) -> bool;

        /**
         @property supportsPrimitiveMotionBlur
        @abstract Query device support for using ray tracing primitive motion blur.
        @return BOOL value. If YES, the device supports the primitive motion blur api. If NO, the device does not.
        */
        #[method(supportsPrimitiveMotionBlur)]
        unsafe fn supportsPrimitiveMotionBlur(&self) -> bool;
    }

    unsafe impl ProtocolType for dyn MTLDevice {}
);
