//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_enum!(
    #[underlying(c_uint)]
    /**
      Method for determining executable architectures.
    */
    pub enum __anonymous__ {
        NSBundleExecutableArchitectureI386 = 0x00000007,
        NSBundleExecutableArchitecturePPC = 0x00000012,
        NSBundleExecutableArchitectureX86_64 = 0x01000007,
        NSBundleExecutableArchitecturePPC64 = 0x01000012,
        NSBundleExecutableArchitectureARM64 = 0x0100000c,
    }
);

extern_class!(
    #[derive(PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSBundle")]
    /**
      Because NSBundle caches allocated instances, subclasses should be prepared
    to receive an already initialized object back from [super initWithPath:]
    */
    pub struct NSBundle;

    #[cfg(feature = "Foundation_NSBundle")]
    unsafe impl ClassType for NSBundle {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSBundle")]
/**
  Because NSBundle caches allocated instances, subclasses should be prepared
to receive an already initialized object back from [super initWithPath:]
*/
unsafe impl NSObjectProtocol for NSBundle {}

extern_methods!(
    /**
      Because NSBundle caches allocated instances, subclasses should be prepared
    to receive an already initialized object back from [super initWithPath:]
    */
    #[cfg(feature = "Foundation_NSBundle")]
    unsafe impl NSBundle {
        /**
          Methods for creating or retrieving bundle instances.
        */
        #[method_id(@__retain_semantics Other mainBundle)]
        pub fn mainBundle() -> Id<NSBundle>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other bundleWithPath:)]
        pub unsafe fn bundleWithPath(path: &NSString) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithPath:)]
        pub unsafe fn initWithPath(
            this: Option<Allocated<Self>>,
            path: &NSString,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other bundleWithURL:)]
        pub unsafe fn bundleWithURL(url: &NSURL) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Init initWithURL:)]
        pub unsafe fn initWithURL(this: Option<Allocated<Self>>, url: &NSURL) -> Option<Id<Self>>;

        #[method_id(@__retain_semantics Other bundleForClass:)]
        pub unsafe fn bundleForClass(a_class: &Class) -> Id<NSBundle>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other bundleWithIdentifier:)]
        pub unsafe fn bundleWithIdentifier(identifier: &NSString) -> Option<Id<NSBundle>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other allBundles)]
        pub unsafe fn allBundles() -> Id<NSArray<NSBundle>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other allFrameworks)]
        pub unsafe fn allFrameworks() -> Id<NSArray<NSBundle>>;

        #[method(load)]
        pub unsafe fn load(&self) -> bool;

        #[method(isLoaded)]
        pub unsafe fn isLoaded(&self) -> bool;

        #[method(unload)]
        pub unsafe fn unload(&self) -> bool;

        #[cfg(feature = "Foundation_NSError")]
        #[method(preflightAndReturnError:_)]
        pub unsafe fn preflightAndReturnError(&self) -> Result<(), Id<NSError>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(loadAndReturnError:_)]
        pub unsafe fn loadAndReturnError(&self) -> Result<(), Id<NSError>>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
          Methods for locating various components of a bundle.
        */
        #[method_id(@__retain_semantics Other bundleURL)]
        pub unsafe fn bundleURL(&self) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other resourceURL)]
        pub unsafe fn resourceURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other executableURL)]
        pub unsafe fn executableURL(&self) -> Option<Id<NSURL>>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForAuxiliaryExecutable:)]
        pub unsafe fn URLForAuxiliaryExecutable(
            &self,
            executable_name: &NSString,
        ) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other privateFrameworksURL)]
        pub unsafe fn privateFrameworksURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other sharedFrameworksURL)]
        pub unsafe fn sharedFrameworksURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other sharedSupportURL)]
        pub unsafe fn sharedSupportURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other builtInPlugInsURL)]
        pub unsafe fn builtInPlugInsURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other appStoreReceiptURL)]
        pub unsafe fn appStoreReceiptURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other bundlePath)]
        pub unsafe fn bundlePath(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other resourcePath)]
        pub unsafe fn resourcePath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other executablePath)]
        pub unsafe fn executablePath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other pathForAuxiliaryExecutable:)]
        pub unsafe fn pathForAuxiliaryExecutable(
            &self,
            executable_name: &NSString,
        ) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other privateFrameworksPath)]
        pub unsafe fn privateFrameworksPath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other sharedFrameworksPath)]
        pub unsafe fn sharedFrameworksPath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other sharedSupportPath)]
        pub unsafe fn sharedSupportPath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other builtInPlugInsPath)]
        pub unsafe fn builtInPlugInsPath(&self) -> Option<Id<NSString>>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForResource:withExtension:subdirectory:inBundleWithURL:)]
        pub unsafe fn URLForResource_withExtension_subdirectory_inBundleWithURL(
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            bundle_url: &NSURL,
        ) -> Option<Id<NSURL>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other URLsForResourcesWithExtension:subdirectory:inBundleWithURL:)]
        pub unsafe fn URLsForResourcesWithExtension_subdirectory_inBundleWithURL(
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            bundle_url: &NSURL,
        ) -> Option<Id<NSArray<NSURL>>>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForResource:withExtension:)]
        pub unsafe fn URLForResource_withExtension(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
        ) -> Option<Id<NSURL>>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForResource:withExtension:subdirectory:)]
        pub unsafe fn URLForResource_withExtension_subdirectory(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Option<Id<NSURL>>;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other URLForResource:withExtension:subdirectory:localization:)]
        pub unsafe fn URLForResource_withExtension_subdirectory_localization(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Option<Id<NSURL>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other URLsForResourcesWithExtension:subdirectory:)]
        pub unsafe fn URLsForResourcesWithExtension_subdirectory(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Option<Id<NSArray<NSURL>>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other URLsForResourcesWithExtension:subdirectory:localization:)]
        pub unsafe fn URLsForResourcesWithExtension_subdirectory_localization(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Option<Id<NSArray<NSURL>>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other pathForResource:ofType:inDirectory:)]
        pub unsafe fn pathForResource_ofType_inDirectory_class(
            name: Option<&NSString>,
            ext: Option<&NSString>,
            bundle_path: &NSString,
        ) -> Option<Id<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other pathsForResourcesOfType:inDirectory:)]
        pub unsafe fn pathsForResourcesOfType_inDirectory_class(
            ext: Option<&NSString>,
            bundle_path: &NSString,
        ) -> Id<NSArray<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other pathForResource:ofType:)]
        pub unsafe fn pathForResource_ofType(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
        ) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other pathForResource:ofType:inDirectory:)]
        pub unsafe fn pathForResource_ofType_inDirectory(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other pathForResource:ofType:inDirectory:forLocalization:)]
        pub unsafe fn pathForResource_ofType_inDirectory_forLocalization(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Option<Id<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other pathsForResourcesOfType:inDirectory:)]
        pub unsafe fn pathsForResourcesOfType_inDirectory(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Id<NSArray<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other pathsForResourcesOfType:inDirectory:forLocalization:)]
        pub unsafe fn pathsForResourcesOfType_inDirectory_forLocalization(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Id<NSArray<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other localizedStringForKey:value:table:)]
        pub unsafe fn localizedStringForKey_value_table(
            &self,
            key: &NSString,
            value: Option<&NSString>,
            table_name: Option<&NSString>,
        ) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Methods for obtaining various information about a bundle.
        */
        #[method_id(@__retain_semantics Other bundleIdentifier)]
        pub unsafe fn bundleIdentifier(&self) -> Option<Id<NSString>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other infoDictionary)]
        pub fn infoDictionary(&self) -> Option<Id<NSDictionary<NSString, Object>>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other localizedInfoDictionary)]
        pub unsafe fn localizedInfoDictionary(&self) -> Option<Id<NSDictionary<NSString, Object>>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other objectForInfoDictionaryKey:)]
        pub unsafe fn objectForInfoDictionaryKey(&self, key: &NSString) -> Option<Id<Object>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(classNamed:)]
        pub unsafe fn classNamed(&self, class_name: &NSString) -> Option<&'static Class>;

        #[method(principalClass)]
        pub unsafe fn principalClass(&self) -> Option<&'static Class>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        /**
          a subset of this bundle's localizations, re-ordered into the preferred order for this process's current execution environment; the main bundle's preferred localizations indicate the language (of text) the user is most likely seeing in the UI
        */
        #[method_id(@__retain_semantics Other preferredLocalizations)]
        pub unsafe fn preferredLocalizations(&self) -> Id<NSArray<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        /**
          list of language names this bundle appears to be localized to
        */
        #[method_id(@__retain_semantics Other localizations)]
        pub unsafe fn localizations(&self) -> Id<NSArray<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other developmentLocalization)]
        pub unsafe fn developmentLocalization(&self) -> Option<Id<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other preferredLocalizationsFromArray:)]
        pub unsafe fn preferredLocalizationsFromArray(
            localizations_array: &NSArray<NSString>,
        ) -> Id<NSArray<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other preferredLocalizationsFromArray:forPreferences:)]
        pub unsafe fn preferredLocalizationsFromArray_forPreferences(
            localizations_array: &NSArray<NSString>,
            preferences_array: Option<&NSArray<NSString>>,
        ) -> Id<NSArray<NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSNumber"))]
        #[method_id(@__retain_semantics Other executableArchitectures)]
        pub unsafe fn executableArchitectures(&self) -> Option<Id<NSArray<NSNumber>>>;
    }
);

extern_methods!(
    /// NSBundleExtensionMethods
    #[cfg(feature = "Foundation_NSString")]
    unsafe impl NSString {
        #[method_id(@__retain_semantics Other variantFittingPresentationWidth:)]
        pub unsafe fn variantFittingPresentationWidth(&self, width: NSInteger) -> Id<NSString>;
    }
);

extern_static!(NSBundleDidLoadNotification: &'static NSNotificationName);

extern_static!(NSLoadedClasses: &'static NSString);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSBundleResourceRequest")]
    /**
     The NSBundleResourceRequest class is used to interact with the on demand resource loading system.

    The purpose of the system is to allow an application to download certain resources on demand, when they are required. This also means that the system can purge a resource from disk when it is no longer required, which will save disk space. This class describes which resources are required, makes the request and reports progress, allows the app to specify how long during its execution that they are required.

    Resources are downloaded into the application container, and are made available via the standard NSBundle resource lookup API.

    The request object itself is lightweight. You may create as many as you need, for example to request the same set of tags in different components of your application.
    */
    pub struct NSBundleResourceRequest;

    #[cfg(feature = "Foundation_NSBundleResourceRequest")]
    unsafe impl ClassType for NSBundleResourceRequest {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSBundleResourceRequest")]
/**
 The NSBundleResourceRequest class is used to interact with the on demand resource loading system.

The purpose of the system is to allow an application to download certain resources on demand, when they are required. This also means that the system can purge a resource from disk when it is no longer required, which will save disk space. This class describes which resources are required, makes the request and reports progress, allows the app to specify how long during its execution that they are required.

Resources are downloaded into the application container, and are made available via the standard NSBundle resource lookup API.

The request object itself is lightweight. You may create as many as you need, for example to request the same set of tags in different components of your application.
*/
unsafe impl NSObjectProtocol for NSBundleResourceRequest {}

#[cfg(feature = "Foundation_NSBundleResourceRequest")]
/**
 The NSBundleResourceRequest class is used to interact with the on demand resource loading system.

The purpose of the system is to allow an application to download certain resources on demand, when they are required. This also means that the system can purge a resource from disk when it is no longer required, which will save disk space. This class describes which resources are required, makes the request and reports progress, allows the app to specify how long during its execution that they are required.

Resources are downloaded into the application container, and are made available via the standard NSBundle resource lookup API.

The request object itself is lightweight. You may create as many as you need, for example to request the same set of tags in different components of your application.
*/
unsafe impl NSProgressReporting for NSBundleResourceRequest {}

extern_methods!(
    /**
     The NSBundleResourceRequest class is used to interact with the on demand resource loading system.

    The purpose of the system is to allow an application to download certain resources on demand, when they are required. This also means that the system can purge a resource from disk when it is no longer required, which will save disk space. This class describes which resources are required, makes the request and reports progress, allows the app to specify how long during its execution that they are required.

    Resources are downloaded into the application container, and are made available via the standard NSBundle resource lookup API.

    The request object itself is lightweight. You may create as many as you need, for example to request the same set of tags in different components of your application.
    */
    #[cfg(feature = "Foundation_NSBundleResourceRequest")]
    unsafe impl NSBundleResourceRequest {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(all(feature = "Foundation_NSSet", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Init initWithTags:)]
        pub unsafe fn initWithTags(
            this: Option<Allocated<Self>>,
            tags: &NSSet<NSString>,
        ) -> Id<Self>;

        #[cfg(all(
            feature = "Foundation_NSBundle",
            feature = "Foundation_NSSet",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Init initWithTags:bundle:)]
        pub unsafe fn initWithTags_bundle(
            this: Option<Allocated<Self>>,
            tags: &NSSet<NSString>,
            bundle: &NSBundle,
        ) -> Id<Self>;

        /**
         Provides a hint to the resource loading system as to the loading priority of this request. Values are limited to between 0 and 1, with 1 being the highest priority. The default priority is 0.5.

        The exact meaning of the value is up to your application. The system will prefer to act on requests that have a higher priority (from the same application). You may change the priority at any time, even after a request has started. The system will make a best attempt to take the new priority into account.
        */
        #[method(loadingPriority)]
        pub unsafe fn loadingPriority(&self) -> c_double;

        /**
         Provides a hint to the resource loading system as to the loading priority of this request. Values are limited to between 0 and 1, with 1 being the highest priority. The default priority is 0.5.

        The exact meaning of the value is up to your application. The system will prefer to act on requests that have a higher priority (from the same application). You may change the priority at any time, even after a request has started. The system will make a best attempt to take the new priority into account.
        */
        #[method(setLoadingPriority:)]
        pub unsafe fn setLoadingPriority(&self, loading_priority: c_double);

        #[cfg(all(feature = "Foundation_NSSet", feature = "Foundation_NSString"))]
        /**
         The tags this request will load.
        */
        #[method_id(@__retain_semantics Other tags)]
        pub unsafe fn tags(&self) -> Id<NSSet<NSString>>;

        #[cfg(feature = "Foundation_NSBundle")]
        /**
         The bundle object that will hold the requested resources. After the -beginAccessingResourcesWithCompletionHandler: callback is invoked, you may use the standard bundle lookup APIs on this bundle object to find your resources.
        */
        #[method_id(@__retain_semantics Other bundle)]
        pub unsafe fn bundle(&self) -> Id<NSBundle>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(beginAccessingResourcesWithCompletionHandler:)]
        pub unsafe fn beginAccessingResourcesWithCompletionHandler(
            &self,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[method(conditionallyBeginAccessingResourcesWithCompletionHandler:)]
        pub unsafe fn conditionallyBeginAccessingResourcesWithCompletionHandler(
            &self,
            completion_handler: &Block<(Bool,), ()>,
        );

        #[method(endAccessingResources)]
        pub unsafe fn endAccessingResources(&self);

        #[cfg(feature = "Foundation_NSProgress")]
        /**
         Progress for the request. The progress object will be valid at initialization and begin updating after the -beginAccessingResourcesWithCompletionHandler: method is called.
        */
        #[method_id(@__retain_semantics Other progress)]
        pub unsafe fn progress(&self) -> Id<NSProgress>;
    }
);

extern_methods!(
    /// NSBundleResourceRequestAdditions
    #[cfg(feature = "Foundation_NSBundle")]
    unsafe impl NSBundle {
        #[cfg(all(feature = "Foundation_NSSet", feature = "Foundation_NSString"))]
        #[method(setPreservationPriority:forTags:)]
        pub unsafe fn setPreservationPriority_forTags(
            &self,
            priority: c_double,
            tags: &NSSet<NSString>,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method(preservationPriorityForTag:)]
        pub unsafe fn preservationPriorityForTag(&self, tag: &NSString) -> c_double;
    }
);

extern_static!(NSBundleResourceRequestLowDiskSpaceNotification: &'static NSNotificationName);

extern_static!(NSBundleResourceRequestLoadingPriorityUrgent: c_double);
