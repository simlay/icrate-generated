//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSSpellServer")]
    /**
     The server just handles all the checking in and IAC and delegates the real work to its delegate.  A single server can handle more than one language.  Services is used to rendezvous applications with servers.
    */
    pub struct NSSpellServer;

    #[cfg(feature = "Foundation_NSSpellServer")]
    unsafe impl ClassType for NSSpellServer {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSSpellServer")]
/**
 The server just handles all the checking in and IAC and delegates the real work to its delegate.  A single server can handle more than one language.  Services is used to rendezvous applications with servers.
*/
unsafe impl NSObjectProtocol for NSSpellServer {}

extern_methods!(
    /**
     The server just handles all the checking in and IAC and delegates the real work to its delegate.  A single server can handle more than one language.  Services is used to rendezvous applications with servers.
    */
    #[cfg(feature = "Foundation_NSSpellServer")]
    unsafe impl NSSpellServer {
        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSSpellServerDelegate>>>;

        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSSpellServerDelegate>>,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method(registerLanguage:byVendor:)]
        pub unsafe fn registerLanguage_byVendor(
            &self,
            language: Option<&NSString>,
            vendor: Option<&NSString>,
        ) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[method(isWordInUserDictionaries:caseSensitive:)]
        pub unsafe fn isWordInUserDictionaries_caseSensitive(
            &self,
            word: &NSString,
            flag: bool,
        ) -> bool;

        #[method(run)]
        pub unsafe fn run(&self);
    }
);

extern_static!(NSGrammarRange: &'static NSString);

extern_static!(NSGrammarUserDescription: &'static NSString);

extern_static!(NSGrammarCorrections: &'static NSString);

extern_protocol!(
    /**
     These are the methods the object in the server that does the real work should respond to.  Only the first method is required.  The first method checks spelling and the second suggests proper corrections.  The third and fourth allow the delegate to be notified when new words are learned or forgotten.

    The argument wordCount is an out parameter.  It should return the number of words found in the document from startPosition until the misspelled word was found (or the end of the stream)  If your spell server can't count words (though it is hard to imagine why that might be), return -1 in wordCount.  countOnly of Yes means forget about checking the spelling of words, just count them until you get to the end of the stream.

    The fifth method suggests potential completions, in the order in which they should be presented to the user.  The elements of the suggested completions array should be complete words that the user might be trying to type when starting by typing the partial word at the given range in the given string.

    The sixth method permits those delegates that support it to provide grammar checking.  The return value should be the range of the next sentence or other similar grammatical unit that contains sections to be flagged for grammatical issues; the details array optionally points out subranges of that range with specific issues.  The elements of the details array should be dictionaries with some or all of the keys listed below.

    The value for the NSGrammarRange key should be an NSValue containing an NSRange, a subrange of the sentence range used as the return value, whose location should be an offset from the beginning of the sentence--so, for example, an NSGrammarRange for the first four characters of the overall sentence range should be {0, 4}.  The value for the NSGrammarUserDescription key should be an NSString containing descriptive text about that range, to be presented directly to the user; it is intended that the user description should provide enough information to allow the user to correct the problem.  A value may also be provided for the NSGrammarCorrections key, consisting of an NSArray of NSStrings representing potential substitutions to correct the problem, but it is expected that this may not be available in all cases.  It is recommended that NSGrammarUserDescription be supplied in all cases; in any event, either NSGrammarUserDescription or NSGrammarCorrections must be supplied in order for something to be presented to the user.  If NSGrammarRange is not present, it will be assumed to be equal to the overall sentence range.  Additional keys may be added in future releases.

    The seventh method is optional, but if implemented it will be called during the course of unified text checking via the NSSpellChecker checkString:... or requestCheckingOfString:... methods.  This allows spelling and grammar checking to be performed simultaneously, which can be significantly more efficient, and allows the delegate to return autocorrection results as well.  If this method is not implemented, then unified text checking will call the separate spelling and grammar checking methods described above instead.

    The result should be an array of NSTextCheckingResult objects, of the spelling, grammar, or correction types, depending on the checkingTypes requested.  This method may be called repeatedly with strings representing different subranges of the string that was originally requested to be checked; the offset argument represents the offset of the portion passed in to this method within that original string, and should be added to the origin of the range in any NSTextCheckingResult returned.  The options dictionary corresponds to the options supplied to the NSSpellChecker checkString:... or requestCheckingOfString:... methods, and the orthography argument represents the identified orthography of the text being passed in.
    */
    pub unsafe trait NSSpellServerDelegate: NSObjectProtocol {
        #[cfg(all(feature = "Foundation_NSSpellServer", feature = "Foundation_NSString"))]
        #[optional]
        #[method(spellServer:findMisspelledWordInString:language:wordCount:countOnly:)]
        unsafe fn spellServer_findMisspelledWordInString_language_wordCount_countOnly(
            &self,
            sender: &NSSpellServer,
            string_to_check: &NSString,
            language: &NSString,
            word_count: NonNull<NSInteger>,
            count_only: bool,
        ) -> NSRange;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSSpellServer",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other spellServer:suggestGuessesForWord:inLanguage:)]
        unsafe fn spellServer_suggestGuessesForWord_inLanguage(
            &self,
            sender: &NSSpellServer,
            word: &NSString,
            language: &NSString,
        ) -> Option<Id<NSArray<NSString>>>;

        #[cfg(all(feature = "Foundation_NSSpellServer", feature = "Foundation_NSString"))]
        #[optional]
        #[method(spellServer:didLearnWord:inLanguage:)]
        unsafe fn spellServer_didLearnWord_inLanguage(
            &self,
            sender: &NSSpellServer,
            word: &NSString,
            language: &NSString,
        );

        #[cfg(all(feature = "Foundation_NSSpellServer", feature = "Foundation_NSString"))]
        #[optional]
        #[method(spellServer:didForgetWord:inLanguage:)]
        unsafe fn spellServer_didForgetWord_inLanguage(
            &self,
            sender: &NSSpellServer,
            word: &NSString,
            language: &NSString,
        );

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSSpellServer",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other spellServer:suggestCompletionsForPartialWordRange:inString:language:)]
        unsafe fn spellServer_suggestCompletionsForPartialWordRange_inString_language(
            &self,
            sender: &NSSpellServer,
            range: NSRange,
            string: &NSString,
            language: &NSString,
        ) -> Option<Id<NSArray<NSString>>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSSpellServer",
            feature = "Foundation_NSString"
        ))]
        #[optional]
        #[method(spellServer:checkGrammarInString:language:details:)]
        unsafe fn spellServer_checkGrammarInString_language_details(
            &self,
            sender: &NSSpellServer,
            string_to_check: &NSString,
            language: Option<&NSString>,
            details: Option<&mut Option<Id<NSArray<NSDictionary<NSString, Object>>>>>,
        ) -> NSRange;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSOrthography",
            feature = "Foundation_NSSpellServer",
            feature = "Foundation_NSString",
            feature = "Foundation_NSTextCheckingResult"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other spellServer:checkString:offset:types:options:orthography:wordCount:)]
        unsafe fn spellServer_checkString_offset_types_options_orthography_wordCount(
            &self,
            sender: &NSSpellServer,
            string_to_check: &NSString,
            offset: NSUInteger,
            checking_types: NSTextCheckingTypes,
            options: Option<&NSDictionary<NSString, Object>>,
            orthography: Option<&NSOrthography>,
            word_count: NonNull<NSInteger>,
        ) -> Option<Id<NSArray<NSTextCheckingResult>>>;

        #[cfg(all(feature = "Foundation_NSSpellServer", feature = "Foundation_NSString"))]
        #[optional]
        #[method(spellServer:recordResponse:toCorrection:forWord:language:)]
        unsafe fn spellServer_recordResponse_toCorrection_forWord_language(
            &self,
            sender: &NSSpellServer,
            response: NSUInteger,
            correction: &NSString,
            word: &NSString,
            language: &NSString,
        );
    }

    unsafe impl ProtocolType for dyn NSSpellServerDelegate {}
);
