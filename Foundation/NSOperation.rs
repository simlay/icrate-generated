//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSOperationQueuePriority {
        NSOperationQueuePriorityVeryLow = -8,
        NSOperationQueuePriorityLow = -4,
        NSOperationQueuePriorityNormal = 0,
        NSOperationQueuePriorityHigh = 4,
        NSOperationQueuePriorityVeryHigh = 8,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSOperation")]
    pub struct NSOperation;

    #[cfg(feature = "Foundation_NSOperation")]
    unsafe impl ClassType for NSOperation {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSOperation")]
unsafe impl NSObjectProtocol for NSOperation {}

extern_methods!(
    #[cfg(feature = "Foundation_NSOperation")]
    unsafe impl NSOperation {
        #[method(start)]
        pub unsafe fn start(&self);

        #[method(main)]
        pub unsafe fn main(&self);

        #[method(isCancelled)]
        pub unsafe fn isCancelled(&self) -> bool;

        #[method(cancel)]
        pub unsafe fn cancel(&self);

        #[method(isExecuting)]
        pub unsafe fn isExecuting(&self) -> bool;

        #[method(isFinished)]
        pub unsafe fn isFinished(&self) -> bool;

        /**
          To be deprecated; use and override 'asynchronous' below
        */
        #[method(isConcurrent)]
        pub unsafe fn isConcurrent(&self) -> bool;

        #[method(isAsynchronous)]
        pub unsafe fn isAsynchronous(&self) -> bool;

        #[method(isReady)]
        pub unsafe fn isReady(&self) -> bool;

        #[method(addDependency:)]
        pub unsafe fn addDependency(&self, op: &NSOperation);

        #[method(removeDependency:)]
        pub unsafe fn removeDependency(&self, op: &NSOperation);

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other dependencies)]
        pub unsafe fn dependencies(&self) -> Id<NSArray<NSOperation>>;

        #[method(queuePriority)]
        pub unsafe fn queuePriority(&self) -> NSOperationQueuePriority;

        #[method(setQueuePriority:)]
        pub unsafe fn setQueuePriority(&self, queue_priority: NSOperationQueuePriority);

        #[method(completionBlock)]
        pub unsafe fn completionBlock(&self) -> *mut Block<(), ()>;

        #[method(setCompletionBlock:)]
        pub unsafe fn setCompletionBlock(&self, completion_block: Option<&Block<(), ()>>);

        #[method(waitUntilFinished)]
        pub unsafe fn waitUntilFinished(&self);

        #[deprecated = "Not supported"]
        #[method(threadPriority)]
        pub unsafe fn threadPriority(&self) -> c_double;

        #[deprecated = "Not supported"]
        #[method(setThreadPriority:)]
        pub unsafe fn setThreadPriority(&self, thread_priority: c_double);

        #[method(qualityOfService)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        #[method(setQualityOfService:)]
        pub unsafe fn setQualityOfService(&self, quality_of_service: NSQualityOfService);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&NSString>);
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSBlockOperation")]
    pub struct NSBlockOperation;

    #[cfg(feature = "Foundation_NSBlockOperation")]
    unsafe impl ClassType for NSBlockOperation {
        #[inherits(NSObject)]
        type Super = NSOperation;
    }
);

#[cfg(feature = "Foundation_NSBlockOperation")]
unsafe impl NSObjectProtocol for NSBlockOperation {}

extern_methods!(
    #[cfg(feature = "Foundation_NSBlockOperation")]
    unsafe impl NSBlockOperation {
        #[method_id(@__retain_semantics Other blockOperationWithBlock:)]
        pub unsafe fn blockOperationWithBlock(block: &Block<(), ()>) -> Id<Self>;

        #[method(addExecutionBlock:)]
        pub unsafe fn addExecutionBlock(&self, block: &Block<(), ()>);
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSInvocationOperation")]
    pub struct NSInvocationOperation;

    #[cfg(feature = "Foundation_NSInvocationOperation")]
    unsafe impl ClassType for NSInvocationOperation {
        #[inherits(NSObject)]
        type Super = NSOperation;
    }
);

#[cfg(feature = "Foundation_NSInvocationOperation")]
unsafe impl NSObjectProtocol for NSInvocationOperation {}

extern_methods!(
    #[cfg(feature = "Foundation_NSInvocationOperation")]
    unsafe impl NSInvocationOperation {
        #[method_id(@__retain_semantics Init initWithTarget:selector:object:)]
        pub unsafe fn initWithTarget_selector_object(
            this: Option<Allocated<Self>>,
            target: &Object,
            sel: Sel,
            arg: Option<&Object>,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSInvocation")]
        #[method_id(@__retain_semantics Init initWithInvocation:)]
        pub unsafe fn initWithInvocation(
            this: Option<Allocated<Self>>,
            inv: &NSInvocation,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSInvocation")]
        #[method_id(@__retain_semantics Other invocation)]
        pub unsafe fn invocation(&self) -> Id<NSInvocation>;

        #[method_id(@__retain_semantics Other result)]
        pub unsafe fn result(&self) -> Option<Id<Object>>;
    }
);

extern_static!(NSInvocationOperationVoidResultException: &'static NSExceptionName);

extern_static!(NSInvocationOperationCancelledException: &'static NSExceptionName);

extern_static!(NSOperationQueueDefaultMaxConcurrentOperationCount: NSInteger = -1);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSOperationQueue")]
    pub struct NSOperationQueue;

    #[cfg(feature = "Foundation_NSOperationQueue")]
    unsafe impl ClassType for NSOperationQueue {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSOperationQueue")]
unsafe impl NSObjectProtocol for NSOperationQueue {}

#[cfg(feature = "Foundation_NSOperationQueue")]
unsafe impl NSProgressReporting for NSOperationQueue {}

extern_methods!(
    #[cfg(feature = "Foundation_NSOperationQueue")]
    unsafe impl NSOperationQueue {
        #[cfg(feature = "Foundation_NSProgress")]
        /**
          @property progress
         @discussion     The `progress` property represents a total progress of the operations executed in the queue. By default NSOperationQueue
         does not report progress until the `totalUnitCount` of the progress is set. When the `totalUnitCount` property of the progress is set the
         queue then opts into participating in progress reporting. When enabled, each operation will contribute 1 unit of completion to the
         overall progress of the queue for operations that are finished by the end of main (operations that override start and do not invoke super
         will not contribute to progress). Special attention to race conditions should be made when updating the `totalUnitCount` of the progress
         as well as care should be taken to avoid 'backwards progress'. For example; when a NSOperationQueue's progress is 5/10, representing 50%
         completed, and there are 90 more operations about to be added and the `totalUnitCount` that would then make the progress report as 5/100
         which represents 5%. In this example it would mean that any progress bar would jump from displaying 50% back to 5%, which might not be
         desirable. In the cases where the `totalUnitCount` needs to be adjusted it is suggested to do this for thread-safety in a barrier by
         using the `addBarrierBlock:` API. This ensures that no un-expected execution state occurs adjusting into a potentially backwards moving
         progress scenario.

         @example
         NSOperationQueue *queue = [[NSOperationQueue alloc] init];
         queue.progress.totalUnitCount = 10;
        */
        #[method_id(@__retain_semantics Other progress)]
        pub unsafe fn progress(&self) -> Id<NSProgress>;

        #[cfg(feature = "Foundation_NSOperation")]
        #[method(addOperation:)]
        pub unsafe fn addOperation(&self, op: &NSOperation);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSOperation"))]
        #[method(addOperations:waitUntilFinished:)]
        pub unsafe fn addOperations_waitUntilFinished(
            &self,
            ops: &NSArray<NSOperation>,
            wait: bool,
        );

        #[method(addOperationWithBlock:)]
        pub unsafe fn addOperationWithBlock(&self, block: &Block<(), ()>);

        #[method(addBarrierBlock:)]
        pub unsafe fn addBarrierBlock(&self, barrier: &Block<(), ()>);

        #[method(maxConcurrentOperationCount)]
        pub unsafe fn maxConcurrentOperationCount(&self) -> NSInteger;

        #[method(setMaxConcurrentOperationCount:)]
        pub unsafe fn setMaxConcurrentOperationCount(
            &self,
            max_concurrent_operation_count: NSInteger,
        );

        #[method(isSuspended)]
        pub unsafe fn isSuspended(&self) -> bool;

        #[method(setSuspended:)]
        pub unsafe fn setSuspended(&self, suspended: bool);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[method(qualityOfService)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        #[method(setQualityOfService:)]
        pub unsafe fn setQualityOfService(&self, quality_of_service: NSQualityOfService);

        #[method(cancelAllOperations)]
        pub unsafe fn cancelAllOperations(&self);

        #[method(waitUntilAllOperationsAreFinished)]
        pub unsafe fn waitUntilAllOperationsAreFinished(&self);

        #[method_id(@__retain_semantics Other currentQueue)]
        pub unsafe fn currentQueue() -> Option<Id<NSOperationQueue>>;

        #[method_id(@__retain_semantics Other mainQueue)]
        pub unsafe fn mainQueue() -> Id<NSOperationQueue>;
    }
);

extern_methods!(
    /// NSDeprecated
    #[cfg(feature = "Foundation_NSOperationQueue")]
    unsafe impl NSOperationQueue {
        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSOperation"))]
        /**
          These two functions are inherently a race condition and should be avoided if possible
        */
        #[deprecated = "access to operations is inherently a race condition, it should not be used. For barrier style behaviors please use addBarrierBlock: instead"]
        #[method_id(@__retain_semantics Other operations)]
        pub unsafe fn operations(&self) -> Id<NSArray<NSOperation>>;

        #[deprecated]
        #[method(operationCount)]
        pub unsafe fn operationCount(&self) -> NSUInteger;
    }
);
