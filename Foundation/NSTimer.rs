//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSTimer")]
    pub struct NSTimer;

    #[cfg(feature = "Foundation_NSTimer")]
    unsafe impl ClassType for NSTimer {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSTimer")]
unsafe impl NSObjectProtocol for NSTimer {}

extern_methods!(
    #[cfg(feature = "Foundation_NSTimer")]
    unsafe impl NSTimer {
        #[cfg(feature = "Foundation_NSInvocation")]
        #[method_id(@__retain_semantics Other timerWithTimeInterval:invocation:repeats:)]
        pub unsafe fn timerWithTimeInterval_invocation_repeats(
            ti: NSTimeInterval,
            invocation: &NSInvocation,
            yes_or_no: bool,
        ) -> Id<NSTimer>;

        #[cfg(feature = "Foundation_NSInvocation")]
        #[method_id(@__retain_semantics Other scheduledTimerWithTimeInterval:invocation:repeats:)]
        pub unsafe fn scheduledTimerWithTimeInterval_invocation_repeats(
            ti: NSTimeInterval,
            invocation: &NSInvocation,
            yes_or_no: bool,
        ) -> Id<NSTimer>;

        #[method_id(@__retain_semantics Other timerWithTimeInterval:target:selector:userInfo:repeats:)]
        pub unsafe fn timerWithTimeInterval_target_selector_userInfo_repeats(
            ti: NSTimeInterval,
            a_target: &Object,
            a_selector: Sel,
            user_info: Option<&Object>,
            yes_or_no: bool,
        ) -> Id<NSTimer>;

        #[method_id(@__retain_semantics Other scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:)]
        pub unsafe fn scheduledTimerWithTimeInterval_target_selector_userInfo_repeats(
            ti: NSTimeInterval,
            a_target: &Object,
            a_selector: Sel,
            user_info: Option<&Object>,
            yes_or_no: bool,
        ) -> Id<NSTimer>;

        #[method_id(@__retain_semantics Other timerWithTimeInterval:repeats:block:)]
        pub unsafe fn timerWithTimeInterval_repeats_block(
            interval: NSTimeInterval,
            repeats: bool,
            block: &Block<(NonNull<NSTimer>,), ()>,
        ) -> Id<NSTimer>;

        #[method_id(@__retain_semantics Other scheduledTimerWithTimeInterval:repeats:block:)]
        pub unsafe fn scheduledTimerWithTimeInterval_repeats_block(
            interval: NSTimeInterval,
            repeats: bool,
            block: &Block<(NonNull<NSTimer>,), ()>,
        ) -> Id<NSTimer>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Init initWithFireDate:interval:repeats:block:)]
        pub unsafe fn initWithFireDate_interval_repeats_block(
            this: Option<Allocated<Self>>,
            date: &NSDate,
            interval: NSTimeInterval,
            repeats: bool,
            block: &Block<(NonNull<NSTimer>,), ()>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Init initWithFireDate:interval:target:selector:userInfo:repeats:)]
        pub unsafe fn initWithFireDate_interval_target_selector_userInfo_repeats(
            this: Option<Allocated<Self>>,
            date: &NSDate,
            ti: NSTimeInterval,
            t: &Object,
            s: Sel,
            ui: Option<&Object>,
            rep: bool,
        ) -> Id<Self>;

        #[method(fire)]
        pub unsafe fn fire(&self);

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other fireDate)]
        pub unsafe fn fireDate(&self) -> Id<NSDate>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method(setFireDate:)]
        pub unsafe fn setFireDate(&self, fire_date: &NSDate);

        #[method(timeInterval)]
        pub unsafe fn timeInterval(&self) -> NSTimeInterval;

        /**
          Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
         As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
        */
        #[method(tolerance)]
        pub unsafe fn tolerance(&self) -> NSTimeInterval;

        /**
          Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
         As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
        */
        #[method(setTolerance:)]
        pub unsafe fn setTolerance(&self, tolerance: NSTimeInterval);

        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[method(isValid)]
        pub unsafe fn isValid(&self) -> bool;

        #[method_id(@__retain_semantics Other userInfo)]
        pub unsafe fn userInfo(&self) -> Option<Id<Object>>;
    }
);
