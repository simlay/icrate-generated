//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSDateComponentsFormatterUnitsStyle {
        NSDateComponentsFormatterUnitsStylePositional = 0,
        NSDateComponentsFormatterUnitsStyleAbbreviated = 1,
        NSDateComponentsFormatterUnitsStyleShort = 2,
        NSDateComponentsFormatterUnitsStyleFull = 3,
        NSDateComponentsFormatterUnitsStyleSpellOut = 4,
        NSDateComponentsFormatterUnitsStyleBrief = 5,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSDateComponentsFormatterZeroFormattingBehavior {
        NSDateComponentsFormatterZeroFormattingBehaviorNone = 0,
        NSDateComponentsFormatterZeroFormattingBehaviorDefault = 1 << 0,
        NSDateComponentsFormatterZeroFormattingBehaviorDropLeading = 1 << 1,
        NSDateComponentsFormatterZeroFormattingBehaviorDropMiddle = 1 << 2,
        NSDateComponentsFormatterZeroFormattingBehaviorDropTrailing = 1 << 3,
        NSDateComponentsFormatterZeroFormattingBehaviorDropAll =
            NSDateComponentsFormatterZeroFormattingBehaviorDropLeading
                | NSDateComponentsFormatterZeroFormattingBehaviorDropMiddle
                | NSDateComponentsFormatterZeroFormattingBehaviorDropTrailing,
        NSDateComponentsFormatterZeroFormattingBehaviorPad = 1 << 16,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSDateComponentsFormatter")]
    pub struct NSDateComponentsFormatter;

    #[cfg(feature = "Foundation_NSDateComponentsFormatter")]
    unsafe impl ClassType for NSDateComponentsFormatter {
        #[inherits(NSObject)]
        type Super = NSFormatter;
    }
);

#[cfg(feature = "Foundation_NSDateComponentsFormatter")]
unsafe impl NSCoding for NSDateComponentsFormatter {}

#[cfg(feature = "Foundation_NSDateComponentsFormatter")]
unsafe impl NSObjectProtocol for NSDateComponentsFormatter {}

extern_methods!(
    #[cfg(feature = "Foundation_NSDateComponentsFormatter")]
    unsafe impl NSDateComponentsFormatter {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other stringForObjectValue:)]
        pub unsafe fn stringForObjectValue(&self, obj: Option<&Object>) -> Option<Id<NSString>>;

        #[cfg(all(
            feature = "Foundation_NSDateComponents",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other stringFromDateComponents:)]
        pub unsafe fn stringFromDateComponents(
            &self,
            components: &NSDateComponents,
        ) -> Option<Id<NSString>>;

        #[cfg(all(feature = "Foundation_NSDate", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other stringFromDate:toDate:)]
        pub unsafe fn stringFromDate_toDate(
            &self,
            start_date: &NSDate,
            end_date: &NSDate,
        ) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other stringFromTimeInterval:)]
        pub unsafe fn stringFromTimeInterval(&self, ti: NSTimeInterval) -> Option<Id<NSString>>;

        #[cfg(all(
            feature = "Foundation_NSDateComponents",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other localizedStringFromDateComponents:unitsStyle:)]
        pub unsafe fn localizedStringFromDateComponents_unitsStyle(
            components: &NSDateComponents,
            units_style: NSDateComponentsFormatterUnitsStyle,
        ) -> Option<Id<NSString>>;

        /**
          Choose how to indicate units. For example, 1h 10m vs 1:10. Default is NSDateComponentsFormatterUnitsStylePositional.
        */
        #[method(unitsStyle)]
        pub unsafe fn unitsStyle(&self) -> NSDateComponentsFormatterUnitsStyle;

        /**
          Choose how to indicate units. For example, 1h 10m vs 1:10. Default is NSDateComponentsFormatterUnitsStylePositional.
        */
        #[method(setUnitsStyle:)]
        pub unsafe fn setUnitsStyle(&self, units_style: NSDateComponentsFormatterUnitsStyle);

        /**
          Bitmask of units to include. Set to 0 to get the default behavior. Note that, especially if the maximum number of units is low, unit collapsing is on, or zero dropping is on, not all allowed units may actually be used for a given NSDateComponents. Default value is the components of the passed-in NSDateComponents object, or years | months | weeks | days | hours | minutes | seconds if passed an NSTimeInterval or pair of NSDates.

        Allowed units are:

        NSCalendarUnitYear
        NSCalendarUnitMonth
        NSCalendarUnitWeekOfMonth (used to mean "quantity of weeks")
        NSCalendarUnitDay
        NSCalendarUnitHour
        NSCalendarUnitMinute
        NSCalendarUnitSecond

        Specifying any other NSCalendarUnits will result in an exception.
        */
        #[method(allowedUnits)]
        pub unsafe fn allowedUnits(&self) -> NSCalendarUnit;

        /**
          Bitmask of units to include. Set to 0 to get the default behavior. Note that, especially if the maximum number of units is low, unit collapsing is on, or zero dropping is on, not all allowed units may actually be used for a given NSDateComponents. Default value is the components of the passed-in NSDateComponents object, or years | months | weeks | days | hours | minutes | seconds if passed an NSTimeInterval or pair of NSDates.

        Allowed units are:

        NSCalendarUnitYear
        NSCalendarUnitMonth
        NSCalendarUnitWeekOfMonth (used to mean "quantity of weeks")
        NSCalendarUnitDay
        NSCalendarUnitHour
        NSCalendarUnitMinute
        NSCalendarUnitSecond

        Specifying any other NSCalendarUnits will result in an exception.
        */
        #[method(setAllowedUnits:)]
        pub unsafe fn setAllowedUnits(&self, allowed_units: NSCalendarUnit);

        /**
          Bitmask specifying how to handle zeros in units. This includes both padding and dropping zeros so that a consistent number digits are displayed, causing updating displays to remain more stable. Default is NSDateComponentsFormatterZeroFormattingBehaviorDefault.

        If the combination of zero formatting behavior and style would lead to ambiguous date formats (for example, 1:10 meaning 1 hour, 10 seconds), NSDateComponentsFormatter will throw an exception.
        */
        #[method(zeroFormattingBehavior)]
        pub unsafe fn zeroFormattingBehavior(
            &self,
        ) -> NSDateComponentsFormatterZeroFormattingBehavior;

        /**
          Bitmask specifying how to handle zeros in units. This includes both padding and dropping zeros so that a consistent number digits are displayed, causing updating displays to remain more stable. Default is NSDateComponentsFormatterZeroFormattingBehaviorDefault.

        If the combination of zero formatting behavior and style would lead to ambiguous date formats (for example, 1:10 meaning 1 hour, 10 seconds), NSDateComponentsFormatter will throw an exception.
        */
        #[method(setZeroFormattingBehavior:)]
        pub unsafe fn setZeroFormattingBehavior(
            &self,
            zero_formatting_behavior: NSDateComponentsFormatterZeroFormattingBehavior,
        );

        #[cfg(feature = "Foundation_NSCalendar")]
        /**
          Specifies the locale and calendar to use for formatting date components that do not themselves have calendars. Defaults to NSAutoupdatingCurrentCalendar. If set to nil, uses the gregorian calendar with the en_US_POSIX locale.
        */
        #[method_id(@__retain_semantics Other calendar)]
        pub unsafe fn calendar(&self) -> Option<Id<NSCalendar>>;

        #[cfg(feature = "Foundation_NSCalendar")]
        /**
          Specifies the locale and calendar to use for formatting date components that do not themselves have calendars. Defaults to NSAutoupdatingCurrentCalendar. If set to nil, uses the gregorian calendar with the en_US_POSIX locale.
        */
        #[method(setCalendar:)]
        pub unsafe fn setCalendar(&self, calendar: Option<&NSCalendar>);

        #[cfg(feature = "Foundation_NSDate")]
        /**
           Where units have variable length (number of days in a month, number of hours in a day, etc...), NSDateComponentsFormatter will calculate as though counting from the date specified by the referenceDate in the appropriate calendar. Defaults to [NSDate dateWithTimeIntervalSinceReferenceDate:0] at the time of the -stringForObjectValue: call if not set. Set to nil to get the default behavior.
        */
        #[method_id(@__retain_semantics Other referenceDate)]
        pub unsafe fn referenceDate(&self) -> Option<Id<NSDate>>;

        #[cfg(feature = "Foundation_NSDate")]
        /**
           Where units have variable length (number of days in a month, number of hours in a day, etc...), NSDateComponentsFormatter will calculate as though counting from the date specified by the referenceDate in the appropriate calendar. Defaults to [NSDate dateWithTimeIntervalSinceReferenceDate:0] at the time of the -stringForObjectValue: call if not set. Set to nil to get the default behavior.
        */
        #[method(setReferenceDate:)]
        pub unsafe fn setReferenceDate(&self, reference_date: Option<&NSDate>);

        /**
          Choose whether non-integer units should be used to handle display of values that can't be exactly represented with the allowed units. For example, if minutes aren't allowed, then "1h 30m" could be formatted as "1.5h". Default is NO.
        */
        #[method(allowsFractionalUnits)]
        pub unsafe fn allowsFractionalUnits(&self) -> bool;

        /**
          Choose whether non-integer units should be used to handle display of values that can't be exactly represented with the allowed units. For example, if minutes aren't allowed, then "1h 30m" could be formatted as "1.5h". Default is NO.
        */
        #[method(setAllowsFractionalUnits:)]
        pub unsafe fn setAllowsFractionalUnits(&self, allows_fractional_units: bool);

        /**
          Choose whether or not, and at which point, to round small units in large values to zero.
        Examples:
        1h 10m 30s, maximumUnitCount set to 0: "1h 10m 30s"
        1h 10m 30s, maximumUnitCount set to 2: "1h 10m"
        10m 30s, maximumUnitCount set to 0: "10m 30s"
        10m 30s, maximumUnitCount set to 2: "10m 30s"

        Default is 0, which is interpreted as unlimited.
        */
        #[method(maximumUnitCount)]
        pub unsafe fn maximumUnitCount(&self) -> NSInteger;

        /**
          Choose whether or not, and at which point, to round small units in large values to zero.
        Examples:
        1h 10m 30s, maximumUnitCount set to 0: "1h 10m 30s"
        1h 10m 30s, maximumUnitCount set to 2: "1h 10m"
        10m 30s, maximumUnitCount set to 0: "10m 30s"
        10m 30s, maximumUnitCount set to 2: "10m 30s"

        Default is 0, which is interpreted as unlimited.
        */
        #[method(setMaximumUnitCount:)]
        pub unsafe fn setMaximumUnitCount(&self, maximum_unit_count: NSInteger);

        /**
          Choose whether to express largest units just above the threshold for the next lowest unit as a larger quantity of the lower unit. For example: "1m 3s" vs "63s". Default is NO.
        */
        #[method(collapsesLargestUnit)]
        pub unsafe fn collapsesLargestUnit(&self) -> bool;

        /**
          Choose whether to express largest units just above the threshold for the next lowest unit as a larger quantity of the lower unit. For example: "1m 3s" vs "63s". Default is NO.
        */
        #[method(setCollapsesLargestUnit:)]
        pub unsafe fn setCollapsesLargestUnit(&self, collapses_largest_unit: bool);

        /**
          Choose whether to indicate that the allowed units/insignificant units choices lead to inexact results. In some languages, simply prepending "about " to the string will produce incorrect results; this handles those cases correctly. Default is NO.
        */
        #[method(includesApproximationPhrase)]
        pub unsafe fn includesApproximationPhrase(&self) -> bool;

        /**
          Choose whether to indicate that the allowed units/insignificant units choices lead to inexact results. In some languages, simply prepending "about " to the string will produce incorrect results; this handles those cases correctly. Default is NO.
        */
        #[method(setIncludesApproximationPhrase:)]
        pub unsafe fn setIncludesApproximationPhrase(&self, includes_approximation_phrase: bool);

        /**
          Choose whether to produce strings like "35 minutes remaining". Default is NO.
        */
        #[method(includesTimeRemainingPhrase)]
        pub unsafe fn includesTimeRemainingPhrase(&self) -> bool;

        /**
          Choose whether to produce strings like "35 minutes remaining". Default is NO.
        */
        #[method(setIncludesTimeRemainingPhrase:)]
        pub unsafe fn setIncludesTimeRemainingPhrase(&self, includes_time_remaining_phrase: bool);

        /**
         Not yet supported.
        */
        #[method(formattingContext)]
        pub unsafe fn formattingContext(&self) -> NSFormattingContext;

        /**
         Not yet supported.
        */
        #[method(setFormattingContext:)]
        pub unsafe fn setFormattingContext(&self, formatting_context: NSFormattingContext);

        #[cfg(feature = "Foundation_NSString")]
        #[method(getObjectValue:forString:errorDescription:)]
        pub unsafe fn getObjectValue_forString_errorDescription(
            &self,
            obj: Option<&mut Option<Id<Object>>>,
            string: &NSString,
            error: Option<&mut Option<Id<NSString>>>,
        ) -> bool;
    }
);
