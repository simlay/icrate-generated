//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_enum!(
    #[underlying(c_uint)]
    #[deprecated = "Not supported"]
    pub enum __anonymous__ {
        #[deprecated = "Not supported"]
        NSWindowsNTOperatingSystem = 1,
        #[deprecated = "Not supported"]
        NSWindows95OperatingSystem = 2,
        #[deprecated = "Not supported"]
        NSSolarisOperatingSystem = 3,
        #[deprecated = "Not supported"]
        NSHPUXOperatingSystem = 4,
        #[deprecated = "Not supported"]
        NSMACHOperatingSystem = 5,
        #[deprecated = "Not supported"]
        NSSunOSOperatingSystem = 6,
        #[deprecated = "Not supported"]
        NSOSF1OperatingSystem = 7,
    }
);

extern_struct!(
    #[encoding_name("?")]
    pub struct NSOperatingSystemVersion {
        pub majorVersion: NSInteger,
        pub minorVersion: NSInteger,
        pub patchVersion: NSInteger,
    }
);

extern_class!(
    #[derive(PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSProcessInfo")]
    pub struct NSProcessInfo;

    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl ClassType for NSProcessInfo {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSProcessInfo")]
unsafe impl NSObjectProtocol for NSProcessInfo {}

extern_methods!(
    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl NSProcessInfo {
        #[method_id(@__retain_semantics Other processInfo)]
        pub fn processInfo() -> Id<NSProcessInfo>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other environment)]
        pub unsafe fn environment(&self) -> Id<NSDictionary<NSString, NSString>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other arguments)]
        pub unsafe fn arguments(&self) -> Id<NSArray<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other hostName)]
        pub unsafe fn hostName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other processName)]
        pub fn processName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setProcessName:)]
        pub unsafe fn setProcessName(&self, process_name: &NSString);

        #[method(processIdentifier)]
        pub unsafe fn processIdentifier(&self) -> c_int;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other globallyUniqueString)]
        pub unsafe fn globallyUniqueString(&self) -> Id<NSString>;

        #[deprecated = "-operatingSystem always returns NSMACHOperatingSystem, use -operatingSystemVersion or -isOperatingSystemAtLeastVersion: instead"]
        #[method(operatingSystem)]
        pub unsafe fn operatingSystem(&self) -> NSUInteger;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "-operatingSystemName always returns NSMACHOperatingSystem, use -operatingSystemVersionString instead"]
        #[method_id(@__retain_semantics Other operatingSystemName)]
        pub unsafe fn operatingSystemName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Human readable, localized; appropriate for displaying to user or using in bug emails and such; NOT appropriate for parsing
        */
        #[method_id(@__retain_semantics Other operatingSystemVersionString)]
        pub unsafe fn operatingSystemVersionString(&self) -> Id<NSString>;

        #[method(operatingSystemVersion)]
        pub fn operatingSystemVersion(&self) -> NSOperatingSystemVersion;

        #[method(processorCount)]
        pub unsafe fn processorCount(&self) -> NSUInteger;

        #[method(activeProcessorCount)]
        pub unsafe fn activeProcessorCount(&self) -> NSUInteger;

        #[method(physicalMemory)]
        pub unsafe fn physicalMemory(&self) -> c_ulonglong;

        #[method(isOperatingSystemAtLeastVersion:)]
        pub unsafe fn isOperatingSystemAtLeastVersion(
            &self,
            version: NSOperatingSystemVersion,
        ) -> bool;

        #[method(systemUptime)]
        pub unsafe fn systemUptime(&self) -> NSTimeInterval;

        #[method(disableSuddenTermination)]
        pub unsafe fn disableSuddenTermination(&self);

        #[method(enableSuddenTermination)]
        pub unsafe fn enableSuddenTermination(&self);

        #[cfg(feature = "Foundation_NSString")]
        #[method(disableAutomaticTermination:)]
        pub unsafe fn disableAutomaticTermination(&self, reason: &NSString);

        #[cfg(feature = "Foundation_NSString")]
        #[method(enableAutomaticTermination:)]
        pub unsafe fn enableAutomaticTermination(&self, reason: &NSString);

        /**
          Marks the calling app as supporting automatic termination. Without calling this or setting the equivalent Info.plist key (NSSupportsAutomaticTermination), the above methods (disableAutomaticTermination:/enableAutomaticTermination:) have no effect,
         although the counter tracking automatic termination opt-outs is still kept up to date to ensure correctness if this is called later. Currently, passing NO has no effect.
         This should be called during -applicationDidFinishLaunching or earlier.
        */
        #[method(automaticTerminationSupportEnabled)]
        pub unsafe fn automaticTerminationSupportEnabled(&self) -> bool;

        /**
          Marks the calling app as supporting automatic termination. Without calling this or setting the equivalent Info.plist key (NSSupportsAutomaticTermination), the above methods (disableAutomaticTermination:/enableAutomaticTermination:) have no effect,
         although the counter tracking automatic termination opt-outs is still kept up to date to ensure correctness if this is called later. Currently, passing NO has no effect.
         This should be called during -applicationDidFinishLaunching or earlier.
        */
        #[method(setAutomaticTerminationSupportEnabled:)]
        pub unsafe fn setAutomaticTerminationSupportEnabled(
            &self,
            automatic_termination_support_enabled: bool,
        );
    }
);

ns_options!(
    #[underlying(u64)]
    /**
     The system has heuristics to improve battery life, performance, and responsiveness of applications for the benefit of the user. This API can be used to give hints to the system that your application has special requirements. In response to creating one of these activities, the system will disable some or all of the heuristics so your application can finish quickly while still providing responsive behavior if the user needs it.

    These activities can be used when your application is performing a long-running operation. If the activity can take different amounts of time (for example, calculating the next move in a chess game), it should use this API. This will ensure correct behavior when the amount of data or the capabilities of the user's computer varies. You should put your activity into one of two major categories:

    User initiated: These are finite length activities that the user has explicitly started. Examples include exporting or downloading a user specified file.

    Background: These are finite length activities that are part of the normal operation of your application but are not explicitly started by the user. Examples include autosaving, indexing, and automatic downloading of files.

    In addition, if your application requires high priority IO, you can include the 'NSActivityLatencyCritical' flag (using a bitwise or). This should be reserved for activities like audio or video recording.

    If your activity takes place synchronously inside an event callback on the main thread, you do not need to use this API.

    Be aware that failing to end these activities for an extended period of time can have significant negative impacts to the performance of your user's computer, so be sure to use only the minimum amount of time required. User preferences may override your applicationâ€™s request.

    This API can also be used to control auto termination or sudden termination.

    id activity = [NSProcessInfo.processInfo beginActivityWithOptions:NSActivityAutomaticTerminationDisabled reason:@"Good Reason"];
    // work
    [NSProcessInfo.processInfo endActivity:activity];

    is equivalent to:

    [NSProcessInfo.processInfo disableAutomaticTermination:@"Good Reason"];
    // work
    [NSProcessInfo.processInfo enableAutomaticTermination:@"Good Reason"]

    Since this API returns an object, it may be easier to pair begins and ends. If the object is deallocated before the -endActivity: call, the activity will be automatically ended.

    This API also provides a mechanism to disable system-wide idle sleep and display idle sleep. These can have a large impact on the user experience, so be sure not to forget to end activities that disable sleep (including NSActivityUserInitiated).

    */
    pub enum NSActivityOptions {
        NSActivityIdleDisplaySleepDisabled = 1 << 40,
        NSActivityIdleSystemSleepDisabled = 1 << 20,
        NSActivitySuddenTerminationDisabled = 1 << 14,
        NSActivityAutomaticTerminationDisabled = 1 << 15,
        NSActivityAnimationTrackingEnabled = 1 << 45,
        NSActivityTrackingEnabled = 1 << 46,
        NSActivityUserInitiated = 0x00FFFFFF | NSActivityIdleSystemSleepDisabled,
        NSActivityUserInitiatedAllowingIdleSystemSleep =
            NSActivityUserInitiated & !NSActivityIdleSystemSleepDisabled,
        NSActivityBackground = 0x000000FF,
        NSActivityLatencyCritical = 0xFF00000000,
        NSActivityUserInteractive = NSActivityUserInitiated | NSActivityLatencyCritical,
    }
);

extern_methods!(
    /// NSProcessInfoActivity
    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl NSProcessInfo {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other beginActivityWithOptions:reason:)]
        pub unsafe fn beginActivityWithOptions_reason(
            &self,
            options: NSActivityOptions,
            reason: &NSString,
        ) -> Id<NSObject>;

        #[method(endActivity:)]
        pub unsafe fn endActivity(&self, activity: &NSObject);

        #[cfg(feature = "Foundation_NSString")]
        #[method(performActivityWithOptions:reason:usingBlock:)]
        pub unsafe fn performActivityWithOptions_reason_usingBlock(
            &self,
            options: NSActivityOptions,
            reason: &NSString,
            block: &Block<(), ()>,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method(performExpiringActivityWithReason:usingBlock:)]
        pub unsafe fn performExpiringActivityWithReason_usingBlock(
            &self,
            reason: &NSString,
            block: &Block<(Bool,), ()>,
        );
    }
);

extern_methods!(
    /// NSUserInformation
    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl NSProcessInfo {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other userName)]
        pub unsafe fn userName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fullUserName)]
        pub unsafe fn fullUserName(&self) -> Id<NSString>;
    }
);

ns_enum!(
    #[underlying(NSInteger)]
    /**
      Describes the current thermal state of the system.
    */
    pub enum NSProcessInfoThermalState {
        NSProcessInfoThermalStateNominal = 0,
        NSProcessInfoThermalStateFair = 1,
        NSProcessInfoThermalStateSerious = 2,
        NSProcessInfoThermalStateCritical = 3,
    }
);

extern_methods!(
    /// NSProcessInfoThermalState
    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl NSProcessInfo {
        /**
          Retrieve the current thermal state of the system. On systems where thermal state is unknown or unsupported, the value returned from the thermalState property is always NSProcessInfoThermalStateNominal.
        */
        #[method(thermalState)]
        pub unsafe fn thermalState(&self) -> NSProcessInfoThermalState;
    }
);

extern_methods!(
    /// NSProcessInfoPowerState
    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl NSProcessInfo {
        /**
          Retrieve the current setting of the system for the low power mode setting. On systems where the low power mode is unknown or unsupported, the value returned from the lowPowerModeEnabled property is always NO
        */
        #[method(isLowPowerModeEnabled)]
        pub unsafe fn isLowPowerModeEnabled(&self) -> bool;
    }
);

extern_static!(NSProcessInfoThermalStateDidChangeNotification: &'static NSNotificationName);

extern_static!(NSProcessInfoPowerStateDidChangeNotification: &'static NSNotificationName);

extern_methods!(
    /// NSProcessInfoPlatform
    #[cfg(feature = "Foundation_NSProcessInfo")]
    unsafe impl NSProcessInfo {
        #[method(isMacCatalystApp)]
        pub unsafe fn isMacCatalystApp(&self) -> bool;

        #[method(isiOSAppOnMac)]
        pub unsafe fn isiOSAppOnMac(&self) -> bool;
    }
);
