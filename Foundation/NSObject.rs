//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_protocol!(
    pub unsafe trait NSCoding {
        #[cfg(feature = "Foundation_NSCoder")]
        #[method(encodeWithCoder:)]
        unsafe fn encodeWithCoder(&self, coder: &NSCoder);

        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        unsafe fn initWithCoder(this: Option<Allocated<Self>>, coder: &NSCoder)
            -> Option<Id<Self>>;
    }

    unsafe impl ProtocolType for dyn NSCoding {}
);

extern_protocol!(
    /**
      Objects which are safe to be encoded and decoded across privilege boundaries should adopt NSSecureCoding instead of NSCoding. Secure coders (those that respond YES to requiresSecureCoding) will only encode objects that adopt the NSSecureCoding protocol.
     NOTE: NSSecureCoding guarantees only that an archive contains the classes it claims. It makes no guarantees about the suitability for consumption by the receiver of the decoded content of the archive. Archived objects which  may trigger code evaluation should be validated independently by the consumer of the objects to verify that no malicious code is executed (i.e. by checking key paths, selectors etc. specified in the archive).
    */
    pub unsafe trait NSSecureCoding: NSCoding {
        /**
          This property must return YES on all classes that allow secure coding. Subclasses of classes that adopt NSSecureCoding and override initWithCoder: must also override this method and return YES.
         The Secure Coding Guide should be consulted when writing methods that decode data.
        */
        #[method(supportsSecureCoding)]
        unsafe fn supportsSecureCoding() -> bool;
    }

    unsafe impl ProtocolType for dyn NSSecureCoding {}
);

extern_protocol!(
    /**
         Discardable Content
    */
    pub unsafe trait NSDiscardableContent {
        #[method(beginContentAccess)]
        unsafe fn beginContentAccess(&self) -> bool;

        #[method(endContentAccess)]
        unsafe fn endContentAccess(&self);

        #[method(discardContentIfPossible)]
        unsafe fn discardContentIfPossible(&self);

        #[method(isContentDiscarded)]
        unsafe fn isContentDiscarded(&self) -> bool;
    }

    unsafe impl ProtocolType for dyn NSDiscardableContent {}
);

extern_fn!(
    pub unsafe fn NSAllocateObject(
        a_class: &Class,
        extra_bytes: NSUInteger,
        zone: *mut NSZone,
    ) -> NonNull<Object>;
);

extern_fn!(
    pub unsafe fn NSDeallocateObject(object: &Object);
);

extern_fn!(
    #[deprecated = "Not supported"]
    pub unsafe fn NSCopyObject(
        object: &Object,
        extra_bytes: NSUInteger,
        zone: *mut NSZone,
    ) -> NonNull<Object>;
);

extern_fn!(
    pub unsafe fn NSShouldRetainWithZone(an_object: &Object, requested_zone: *mut NSZone) -> Bool;
);

extern_fn!(
    pub unsafe fn NSIncrementExtraRefCount(object: &Object);
);

extern_fn!(
    pub unsafe fn NSDecrementExtraRefCountWasZero(object: &Object) -> Bool;
);

extern_fn!(
    pub unsafe fn NSExtraRefCount(object: &Object) -> NSUInteger;
);
