//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

typed_extensible_enum!(
    pub type NSURLResourceKey = NSString;
);

extern_static!(NSURLFileScheme: &'static NSString);

extern_static!(NSURLKeysOfUnsetValuesKey: &'static NSURLResourceKey);

extern_static!(NSURLNameKey: &'static NSURLResourceKey);

extern_static!(NSURLLocalizedNameKey: &'static NSURLResourceKey);

extern_static!(NSURLIsRegularFileKey: &'static NSURLResourceKey);

extern_static!(NSURLIsDirectoryKey: &'static NSURLResourceKey);

extern_static!(NSURLIsSymbolicLinkKey: &'static NSURLResourceKey);

extern_static!(NSURLIsVolumeKey: &'static NSURLResourceKey);

extern_static!(NSURLIsPackageKey: &'static NSURLResourceKey);

extern_static!(NSURLIsApplicationKey: &'static NSURLResourceKey);

extern_static!(NSURLApplicationIsScriptableKey: &'static NSURLResourceKey);

extern_static!(NSURLIsSystemImmutableKey: &'static NSURLResourceKey);

extern_static!(NSURLIsUserImmutableKey: &'static NSURLResourceKey);

extern_static!(NSURLIsHiddenKey: &'static NSURLResourceKey);

extern_static!(NSURLHasHiddenExtensionKey: &'static NSURLResourceKey);

extern_static!(NSURLCreationDateKey: &'static NSURLResourceKey);

extern_static!(NSURLContentAccessDateKey: &'static NSURLResourceKey);

extern_static!(NSURLContentModificationDateKey: &'static NSURLResourceKey);

extern_static!(NSURLAttributeModificationDateKey: &'static NSURLResourceKey);

extern_static!(NSURLLinkCountKey: &'static NSURLResourceKey);

extern_static!(NSURLParentDirectoryURLKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeURLKey: &'static NSURLResourceKey);

extern_static!(NSURLTypeIdentifierKey: &'static NSURLResourceKey);

extern_static!(NSURLContentTypeKey: &'static NSURLResourceKey);

extern_static!(NSURLLocalizedTypeDescriptionKey: &'static NSURLResourceKey);

extern_static!(NSURLLabelNumberKey: &'static NSURLResourceKey);

extern_static!(NSURLLabelColorKey: &'static NSURLResourceKey);

extern_static!(NSURLLocalizedLabelKey: &'static NSURLResourceKey);

extern_static!(NSURLEffectiveIconKey: &'static NSURLResourceKey);

extern_static!(NSURLCustomIconKey: &'static NSURLResourceKey);

extern_static!(NSURLFileResourceIdentifierKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIdentifierKey: &'static NSURLResourceKey);

extern_static!(NSURLPreferredIOBlockSizeKey: &'static NSURLResourceKey);

extern_static!(NSURLIsReadableKey: &'static NSURLResourceKey);

extern_static!(NSURLIsWritableKey: &'static NSURLResourceKey);

extern_static!(NSURLIsExecutableKey: &'static NSURLResourceKey);

extern_static!(NSURLFileSecurityKey: &'static NSURLResourceKey);

extern_static!(NSURLIsExcludedFromBackupKey: &'static NSURLResourceKey);

extern_static!(NSURLTagNamesKey: &'static NSURLResourceKey);

extern_static!(NSURLPathKey: &'static NSURLResourceKey);

extern_static!(NSURLCanonicalPathKey: &'static NSURLResourceKey);

extern_static!(NSURLIsMountTriggerKey: &'static NSURLResourceKey);

extern_static!(NSURLGenerationIdentifierKey: &'static NSURLResourceKey);

extern_static!(NSURLDocumentIdentifierKey: &'static NSURLResourceKey);

extern_static!(NSURLAddedToDirectoryDateKey: &'static NSURLResourceKey);

extern_static!(NSURLQuarantinePropertiesKey: &'static NSURLResourceKey);

extern_static!(NSURLFileResourceTypeKey: &'static NSURLResourceKey);

extern_static!(NSURLFileContentIdentifierKey: &'static NSURLResourceKey);

extern_static!(NSURLMayShareFileContentKey: &'static NSURLResourceKey);

extern_static!(NSURLMayHaveExtendedAttributesKey: &'static NSURLResourceKey);

extern_static!(NSURLIsPurgeableKey: &'static NSURLResourceKey);

extern_static!(NSURLIsSparseKey: &'static NSURLResourceKey);

typed_enum!(
    pub type NSURLFileResourceType = NSString;
);

extern_static!(NSURLFileResourceTypeNamedPipe: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeCharacterSpecial: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeDirectory: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeBlockSpecial: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeRegular: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeSymbolicLink: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeSocket: &'static NSURLFileResourceType);

extern_static!(NSURLFileResourceTypeUnknown: &'static NSURLFileResourceType);

extern_static!(NSURLThumbnailDictionaryKey: &'static NSURLResourceKey);

extern_static!(NSURLThumbnailKey: &'static NSURLResourceKey);

typed_extensible_enum!(
    pub type NSURLThumbnailDictionaryItem = NSString;
);

extern_static!(NSThumbnail1024x1024SizeKey: &'static NSURLThumbnailDictionaryItem);

extern_static!(NSURLFileSizeKey: &'static NSURLResourceKey);

extern_static!(NSURLFileAllocatedSizeKey: &'static NSURLResourceKey);

extern_static!(NSURLTotalFileSizeKey: &'static NSURLResourceKey);

extern_static!(NSURLTotalFileAllocatedSizeKey: &'static NSURLResourceKey);

extern_static!(NSURLIsAliasFileKey: &'static NSURLResourceKey);

extern_static!(NSURLFileProtectionKey: &'static NSURLResourceKey);

typed_enum!(
    pub type NSURLFileProtectionType = NSString;
);

extern_static!(NSURLFileProtectionNone: &'static NSURLFileProtectionType);

extern_static!(NSURLFileProtectionComplete: &'static NSURLFileProtectionType);

extern_static!(NSURLFileProtectionCompleteUnlessOpen: &'static NSURLFileProtectionType);

extern_static!(
    NSURLFileProtectionCompleteUntilFirstUserAuthentication: &'static NSURLFileProtectionType
);

extern_static!(NSURLVolumeLocalizedFormatDescriptionKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeTotalCapacityKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeAvailableCapacityKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeResourceCountKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsPersistentIDsKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsSymbolicLinksKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsHardLinksKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsJournalingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsJournalingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsSparseFilesKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsZeroRunsKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsCaseSensitiveNamesKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsCasePreservedNamesKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsRootDirectoryDatesKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsVolumeSizesKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsRenamingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsAdvisoryFileLockingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsExtendedSecurityKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsBrowsableKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeMaximumFileSizeKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsEjectableKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsRemovableKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsInternalKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsAutomountedKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsLocalKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsReadOnlyKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeCreationDateKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeURLForRemountingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeUUIDStringKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeNameKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeLocalizedNameKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsEncryptedKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeIsRootFileSystemKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsCompressionKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsFileCloningKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsSwapRenamingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsExclusiveRenamingKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsImmutableFilesKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsAccessPermissionsKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeSupportsFileProtectionKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeAvailableCapacityForImportantUsageKey: &'static NSURLResourceKey);

extern_static!(NSURLVolumeAvailableCapacityForOpportunisticUsageKey: &'static NSURLResourceKey);

extern_static!(NSURLIsUbiquitousItemKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemHasUnresolvedConflictsKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemIsDownloadedKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemIsDownloadingKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemIsUploadedKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemIsUploadingKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemPercentDownloadedKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemPercentUploadedKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemDownloadingStatusKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemDownloadingErrorKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemUploadingErrorKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemDownloadRequestedKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemContainerDisplayNameKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemIsExcludedFromSyncKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousItemIsSharedKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousSharedItemCurrentUserRoleKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousSharedItemCurrentUserPermissionsKey: &'static NSURLResourceKey);

extern_static!(NSURLUbiquitousSharedItemOwnerNameComponentsKey: &'static NSURLResourceKey);

extern_static!(
    NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey: &'static NSURLResourceKey
);

typed_enum!(
    pub type NSURLUbiquitousItemDownloadingStatus = NSString;
);

extern_static!(
    NSURLUbiquitousItemDownloadingStatusNotDownloaded:
        &'static NSURLUbiquitousItemDownloadingStatus
);

extern_static!(
    NSURLUbiquitousItemDownloadingStatusDownloaded: &'static NSURLUbiquitousItemDownloadingStatus
);

extern_static!(
    NSURLUbiquitousItemDownloadingStatusCurrent: &'static NSURLUbiquitousItemDownloadingStatus
);

typed_enum!(
    pub type NSURLUbiquitousSharedItemRole = NSString;
);

extern_static!(NSURLUbiquitousSharedItemRoleOwner: &'static NSURLUbiquitousSharedItemRole);

extern_static!(NSURLUbiquitousSharedItemRoleParticipant: &'static NSURLUbiquitousSharedItemRole);

typed_enum!(
    pub type NSURLUbiquitousSharedItemPermissions = NSString;
);

extern_static!(
    NSURLUbiquitousSharedItemPermissionsReadOnly: &'static NSURLUbiquitousSharedItemPermissions
);

extern_static!(
    NSURLUbiquitousSharedItemPermissionsReadWrite: &'static NSURLUbiquitousSharedItemPermissions
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
      Working with Bookmarks and alias (bookmark) files
    */
    pub enum NSURLBookmarkCreationOptions {
        #[deprecated = "Not supported"]
        NSURLBookmarkCreationPreferFileIDResolution = 1 << 8,
        NSURLBookmarkCreationMinimalBookmark = 1 << 9,
        NSURLBookmarkCreationSuitableForBookmarkFile = 1 << 10,
        NSURLBookmarkCreationWithSecurityScope = 1 << 11,
        NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 1 << 12,
        NSURLBookmarkCreationWithoutImplicitSecurityScope = 1 << 29,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSURLBookmarkResolutionOptions {
        NSURLBookmarkResolutionWithoutUI = 1 << 8,
        NSURLBookmarkResolutionWithoutMounting = 1 << 9,
        NSURLBookmarkResolutionWithSecurityScope = 1 << 10,
        NSURLBookmarkResolutionWithoutImplicitStartAccessing = 1 << 15,
    }
);

pub type NSURLBookmarkFileCreationOptions = NSUInteger;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSURL")]
    /**
      NSURLHandle has been deprecated; please use NSURLConnection instead.
    */
    pub struct NSURL;

    #[cfg(feature = "Foundation_NSURL")]
    unsafe impl ClassType for NSURL {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSURL")]
/**
  NSURLHandle has been deprecated; please use NSURLConnection instead.
*/
unsafe impl NSCoding for NSURL {}

#[cfg(feature = "Foundation_NSURL")]
/**
  NSURLHandle has been deprecated; please use NSURLConnection instead.
*/
unsafe impl NSObjectProtocol for NSURL {}

#[cfg(feature = "Foundation_NSURL")]
/**
  NSURLHandle has been deprecated; please use NSURLConnection instead.
*/
unsafe impl NSSecureCoding for NSURL {}

extern_methods!(
    /**
      NSURLHandle has been deprecated; please use NSURLConnection instead.
    */
    #[cfg(feature = "Foundation_NSURL")]
    unsafe impl NSURL {
        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use NSURLComponents instead, which lets you create a valid URL with any valid combination of URL components and subcomponents (not just scheme, host and path), and lets you set components and subcomponents with either percent-encoded or un-percent-encoded strings."]
        #[method_id(@__retain_semantics Init initWithScheme:host:path:)]
        pub unsafe fn initWithScheme_host_path(
            this: Option<Allocated<Self>>,
            scheme: &NSString,
            host: Option<&NSString>,
            path: &NSString,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initFileURLWithPath:isDirectory:relativeToURL:)]
        pub unsafe fn initFileURLWithPath_isDirectory_relativeToURL(
            this: Option<Allocated<Self>>,
            path: &NSString,
            is_dir: bool,
            base_url: Option<&NSURL>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initFileURLWithPath:relativeToURL:)]
        pub unsafe fn initFileURLWithPath_relativeToURL(
            this: Option<Allocated<Self>>,
            path: &NSString,
            base_url: Option<&NSURL>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initFileURLWithPath:isDirectory:)]
        pub unsafe fn initFileURLWithPath_isDirectory(
            this: Option<Allocated<Self>>,
            path: &NSString,
            is_dir: bool,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initFileURLWithPath:)]
        pub unsafe fn initFileURLWithPath(
            this: Option<Allocated<Self>>,
            path: &NSString,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fileURLWithPath:isDirectory:relativeToURL:)]
        pub unsafe fn fileURLWithPath_isDirectory_relativeToURL(
            path: &NSString,
            is_dir: bool,
            base_url: Option<&NSURL>,
        ) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fileURLWithPath:relativeToURL:)]
        pub unsafe fn fileURLWithPath_relativeToURL(
            path: &NSString,
            base_url: Option<&NSURL>,
        ) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fileURLWithPath:isDirectory:)]
        pub unsafe fn fileURLWithPath_isDirectory(path: &NSString, is_dir: bool) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fileURLWithPath:)]
        pub unsafe fn fileURLWithPath(path: &NSString) -> Id<NSURL>;

        #[method_id(@__retain_semantics Init initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:)]
        pub unsafe fn initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL(
            this: Option<Allocated<Self>>,
            path: NonNull<c_char>,
            is_dir: bool,
            base_url: Option<&NSURL>,
        ) -> Id<Self>;

        #[method_id(@__retain_semantics Other fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:)]
        pub unsafe fn fileURLWithFileSystemRepresentation_isDirectory_relativeToURL(
            path: NonNull<c_char>,
            is_dir: bool,
            base_url: Option<&NSURL>,
        ) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithString:)]
        pub unsafe fn initWithString(
            this: Option<Allocated<Self>>,
            url_string: &NSString,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithString:relativeToURL:)]
        pub unsafe fn initWithString_relativeToURL(
            this: Option<Allocated<Self>>,
            url_string: &NSString,
            base_url: Option<&NSURL>,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other URLWithString:)]
        pub unsafe fn URLWithString(url_string: &NSString) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other URLWithString:relativeToURL:)]
        pub unsafe fn URLWithString_relativeToURL(
            url_string: &NSString,
            base_url: Option<&NSURL>,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Init initWithDataRepresentation:relativeToURL:)]
        pub unsafe fn initWithDataRepresentation_relativeToURL(
            this: Option<Allocated<Self>>,
            data: &NSData,
            base_url: Option<&NSURL>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other URLWithDataRepresentation:relativeToURL:)]
        pub unsafe fn URLWithDataRepresentation_relativeToURL(
            data: &NSData,
            base_url: Option<&NSURL>,
        ) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Init initAbsoluteURLWithDataRepresentation:relativeToURL:)]
        pub unsafe fn initAbsoluteURLWithDataRepresentation_relativeToURL(
            this: Option<Allocated<Self>>,
            data: &NSData,
            base_url: Option<&NSURL>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSData")]
        #[method_id(@__retain_semantics Other absoluteURLWithDataRepresentation:relativeToURL:)]
        pub unsafe fn absoluteURLWithDataRepresentation_relativeToURL(
            data: &NSData,
            base_url: Option<&NSURL>,
        ) -> Id<NSURL>;

        #[cfg(feature = "Foundation_NSData")]
        /**
          Returns the data representation of the URL's relativeString. If the URL was initialized with -initWithData:relativeToURL:, the data representation returned are the same bytes as those used at initialization; otherwise, the data representation returned are the bytes of the relativeString encoded with NSUTF8StringEncoding.
        */
        #[method_id(@__retain_semantics Other dataRepresentation)]
        pub unsafe fn dataRepresentation(&self) -> Id<NSData>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other absoluteString)]
        pub unsafe fn absoluteString(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          The relative portion of a URL.  If baseURL is nil, or if the receiver is itself absolute, this is the same as absoluteString
        */
        #[method_id(@__retain_semantics Other relativeString)]
        pub unsafe fn relativeString(&self) -> Id<NSString>;

        /**
          may be nil.
        */
        #[method_id(@__retain_semantics Other baseURL)]
        pub unsafe fn baseURL(&self) -> Option<Id<NSURL>>;

        /**
          if the receiver is itself absolute, this will return self.
        */
        #[method_id(@__retain_semantics Other absoluteURL)]
        pub unsafe fn absoluteURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Any URL is composed of these two basic pieces.  The full URL would be the concatenation of [myURL scheme], ':', [myURL resourceSpecifier]
        */
        #[method_id(@__retain_semantics Other scheme)]
        pub unsafe fn scheme(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other resourceSpecifier)]
        pub unsafe fn resourceSpecifier(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          If the URL conforms to rfc 1808 (the most common form of URL), the following accessors will return the various components; otherwise they return nil.  The litmus test for conformance is as recommended in RFC 1808 - whether the first two characters of resourceSpecifier is @"//".  In all cases, they return the component's value after resolving the receiver against its base URL.
        */
        #[method_id(@__retain_semantics Other host)]
        pub unsafe fn host(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSNumber")]
        #[method_id(@__retain_semantics Other port)]
        pub unsafe fn port(&self) -> Option<Id<NSNumber>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other user)]
        pub unsafe fn user(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other password)]
        pub unsafe fn password(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other path)]
        pub unsafe fn path(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fragment)]
        pub unsafe fn fragment(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "The parameterString method is deprecated. Post deprecation for applications linked with or after the macOS 10.15, and for all iOS, watchOS, and tvOS applications, parameterString will always return nil, and the path method will return the complete path including the semicolon separator and params component if the URL string contains them."]
        #[method_id(@__retain_semantics Other parameterString)]
        pub unsafe fn parameterString(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other query)]
        pub unsafe fn query(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          The same as path if baseURL is nil
        */
        #[method_id(@__retain_semantics Other relativePath)]
        pub unsafe fn relativePath(&self) -> Option<Id<NSString>>;

        /**
          Determines if a given URL string's path represents a directory (i.e. the path component in the URL string ends with a '/' character). This does not check the resource the URL refers to.
        */
        #[method(hasDirectoryPath)]
        pub unsafe fn hasDirectoryPath(&self) -> bool;

        #[method(getFileSystemRepresentation:maxLength:)]
        pub unsafe fn getFileSystemRepresentation_maxLength(
            &self,
            buffer: NonNull<c_char>,
            max_buffer_length: NSUInteger,
        ) -> bool;

        /**
          Returns the URL's path in file system representation. File system representation is a null-terminated C string with canonical UTF-8 encoding. The returned C string will be automatically freed just as a returned object would be released; your code should copy the representation or use getFileSystemRepresentation:maxLength: if it needs to store the representation outside of the autorelease context in which the representation is created.
        */
        #[method(fileSystemRepresentation)]
        pub unsafe fn fileSystemRepresentation(&self) -> NonNull<c_char>;

        /**
          Whether the scheme is file:; if [myURL isFileURL] is YES, then [myURL path] is suitable for input into NSFileManager or NSPathUtilities.
        */
        #[method(isFileURL)]
        pub unsafe fn isFileURL(&self) -> bool;

        #[method_id(@__retain_semantics Other standardizedURL)]
        pub unsafe fn standardizedURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(checkResourceIsReachableAndReturnError:_)]
        pub unsafe fn checkResourceIsReachableAndReturnError(&self) -> Result<(), Id<NSError>>;

        #[method(isFileReferenceURL)]
        pub unsafe fn isFileReferenceURL(&self) -> bool;

        #[method_id(@__retain_semantics Other fileReferenceURL)]
        pub unsafe fn fileReferenceURL(&self) -> Option<Id<NSURL>>;

        /**
          Returns a file path URL that refers to the same resource as a specified URL. File path URLs use a file system style path. An error will occur if the url parameter is not a file URL. A file reference URL's resource must exist and be reachable to be converted to a file path URL. Symbol is present in iOS 4, but performs no operation.
        */
        #[method_id(@__retain_semantics Other filePathURL)]
        pub unsafe fn filePathURL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(getResourceValue:forKey:error:_)]
        pub unsafe fn getResourceValue_forKey_error(
            &self,
            value: &mut Option<Id<Object>>,
            key: &NSURLResourceKey,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other resourceValuesForKeys:error:_)]
        pub unsafe fn resourceValuesForKeys_error(
            &self,
            keys: &NSArray<NSURLResourceKey>,
        ) -> Result<Id<NSDictionary<NSURLResourceKey, Object>>, Id<NSError>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(setResourceValue:forKey:error:_)]
        pub unsafe fn setResourceValue_forKey_error(
            &self,
            value: Option<&Object>,
            key: &NSURLResourceKey,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSError"))]
        #[method(setResourceValues:error:_)]
        pub unsafe fn setResourceValues_error(
            &self,
            keyed_values: &NSDictionary<NSURLResourceKey, Object>,
        ) -> Result<(), Id<NSError>>;

        #[method(removeCachedResourceValueForKey:)]
        pub unsafe fn removeCachedResourceValueForKey(&self, key: &NSURLResourceKey);

        #[method(removeAllCachedResourceValues)]
        pub unsafe fn removeAllCachedResourceValues(&self);

        #[method(setTemporaryResourceValue:forKey:)]
        pub unsafe fn setTemporaryResourceValue_forKey(
            &self,
            value: Option<&Object>,
            key: &NSURLResourceKey,
        );

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSData",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:_)]
        pub unsafe fn bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error(
            &self,
            options: NSURLBookmarkCreationOptions,
            keys: Option<&NSArray<NSURLResourceKey>>,
            relative_url: Option<&NSURL>,
        ) -> Result<Id<NSData>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
        #[method_id(@__retain_semantics Init initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:_)]
        pub unsafe fn initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(
            this: Option<Allocated<Self>>,
            bookmark_data: &NSData,
            options: NSURLBookmarkResolutionOptions,
            relative_url: Option<&NSURL>,
            is_stale: *mut Bool,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
        #[method_id(@__retain_semantics Other URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:_)]
        pub unsafe fn URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error(
            bookmark_data: &NSData,
            options: NSURLBookmarkResolutionOptions,
            relative_url: Option<&NSURL>,
            is_stale: *mut Bool,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSData",
            feature = "Foundation_NSDictionary"
        ))]
        #[method_id(@__retain_semantics Other resourceValuesForKeys:fromBookmarkData:)]
        pub unsafe fn resourceValuesForKeys_fromBookmarkData(
            keys: &NSArray<NSURLResourceKey>,
            bookmark_data: &NSData,
        ) -> Option<Id<NSDictionary<NSURLResourceKey, Object>>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
        #[method(writeBookmarkData:toURL:options:error:_)]
        pub unsafe fn writeBookmarkData_toURL_options_error(
            bookmark_data: &NSData,
            bookmark_file_url: &NSURL,
            options: NSURLBookmarkFileCreationOptions,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
        #[method_id(@__retain_semantics Other bookmarkDataWithContentsOfURL:error:_)]
        pub unsafe fn bookmarkDataWithContentsOfURL_error(
            bookmark_file_url: &NSURL,
        ) -> Result<Id<NSData>, Id<NSError>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method_id(@__retain_semantics Other URLByResolvingAliasFileAtURL:options:error:_)]
        pub unsafe fn URLByResolvingAliasFileAtURL_options_error(
            url: &NSURL,
            options: NSURLBookmarkResolutionOptions,
        ) -> Result<Id<Self>, Id<NSError>>;

        #[method(startAccessingSecurityScopedResource)]
        pub unsafe fn startAccessingSecurityScopedResource(&self) -> bool;

        #[method(stopAccessingSecurityScopedResource)]
        pub unsafe fn stopAccessingSecurityScopedResource(&self);
    }
);

extern_methods!(
    /// NSPromisedItems
    #[cfg(feature = "Foundation_NSURL")]
    unsafe impl NSURL {
        #[cfg(feature = "Foundation_NSError")]
        #[method(getPromisedItemResourceValue:forKey:error:_)]
        pub unsafe fn getPromisedItemResourceValue_forKey_error(
            &self,
            value: &mut Option<Id<Object>>,
            key: &NSURLResourceKey,
        ) -> Result<(), Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other promisedItemResourceValuesForKeys:error:_)]
        pub unsafe fn promisedItemResourceValuesForKeys_error(
            &self,
            keys: &NSArray<NSURLResourceKey>,
        ) -> Result<Id<NSDictionary<NSURLResourceKey, Object>>, Id<NSError>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(checkPromisedItemIsReachableAndReturnError:_)]
        pub unsafe fn checkPromisedItemIsReachableAndReturnError(&self) -> Result<(), Id<NSError>>;
    }
);

extern_methods!(
    /// NSItemProvider
    #[cfg(feature = "Foundation_NSURL")]
    unsafe impl NSURL {}
);

#[cfg(feature = "Foundation_NSURL")]
unsafe impl NSItemProviderReading for NSURL {}

#[cfg(feature = "Foundation_NSURL")]
unsafe impl NSItemProviderWriting for NSURL {}

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSURLQueryItem")]
    /**
      NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
    */
    pub struct NSURLQueryItem;

    #[cfg(feature = "Foundation_NSURLQueryItem")]
    unsafe impl ClassType for NSURLQueryItem {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSURLQueryItem")]
/**
  NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
*/
unsafe impl NSCoding for NSURLQueryItem {}

#[cfg(feature = "Foundation_NSURLQueryItem")]
/**
  NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
*/
unsafe impl NSObjectProtocol for NSURLQueryItem {}

#[cfg(feature = "Foundation_NSURLQueryItem")]
/**
  NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
*/
unsafe impl NSSecureCoding for NSURLQueryItem {}

extern_methods!(
    /**
      NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
    */
    #[cfg(feature = "Foundation_NSURLQueryItem")]
    unsafe impl NSURLQueryItem {
        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithName:value:)]
        pub unsafe fn initWithName_value(
            this: Option<Allocated<Self>>,
            name: &NSString,
            value: Option<&NSString>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other queryItemWithName:value:)]
        pub unsafe fn queryItemWithName_value(
            name: &NSString,
            value: Option<&NSString>,
        ) -> Id<Self>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other value)]
        pub unsafe fn value(&self) -> Option<Id<NSString>>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSURLComponents")]
    pub struct NSURLComponents;

    #[cfg(feature = "Foundation_NSURLComponents")]
    unsafe impl ClassType for NSURLComponents {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSURLComponents")]
unsafe impl NSObjectProtocol for NSURLComponents {}

extern_methods!(
    #[cfg(feature = "Foundation_NSURLComponents")]
    unsafe impl NSURLComponents {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Init initWithURL:resolvingAgainstBaseURL:)]
        pub unsafe fn initWithURL_resolvingAgainstBaseURL(
            this: Option<Allocated<Self>>,
            url: &NSURL,
            resolve: bool,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other componentsWithURL:resolvingAgainstBaseURL:)]
        pub unsafe fn componentsWithURL_resolvingAgainstBaseURL(
            url: &NSURL,
            resolve: bool,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Init initWithString:)]
        pub unsafe fn initWithString(
            this: Option<Allocated<Self>>,
            url_string: &NSString,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other componentsWithString:)]
        pub unsafe fn componentsWithString(url_string: &NSString) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
          Returns a URL created from the NSURLComponents. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
        */
        #[method_id(@__retain_semantics Other URL)]
        pub unsafe fn URL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other URLRelativeToURL:)]
        pub unsafe fn URLRelativeToURL(&self, base_url: Option<&NSURL>) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Returns a URL string created from the NSURLComponents. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
        */
        #[method_id(@__retain_semantics Other string)]
        pub unsafe fn string(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Attempting to set the scheme with an invalid scheme string will cause an exception.
        */
        #[method_id(@__retain_semantics Other scheme)]
        pub unsafe fn scheme(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Attempting to set the scheme with an invalid scheme string will cause an exception.
        */
        #[method(setScheme:)]
        pub unsafe fn setScheme(&self, scheme: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other user)]
        pub unsafe fn user(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setUser:)]
        pub unsafe fn setUser(&self, user: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other password)]
        pub unsafe fn password(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPassword:)]
        pub unsafe fn setPassword(&self, password: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other host)]
        pub unsafe fn host(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setHost:)]
        pub unsafe fn setHost(&self, host: Option<&NSString>);

        #[cfg(feature = "Foundation_NSNumber")]
        /**
          Attempting to set a negative port number will cause an exception.
        */
        #[method_id(@__retain_semantics Other port)]
        pub unsafe fn port(&self) -> Option<Id<NSNumber>>;

        #[cfg(feature = "Foundation_NSNumber")]
        /**
          Attempting to set a negative port number will cause an exception.
        */
        #[method(setPort:)]
        pub unsafe fn setPort(&self, port: Option<&NSNumber>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other path)]
        pub unsafe fn path(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPath:)]
        pub unsafe fn setPath(&self, path: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other query)]
        pub unsafe fn query(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setQuery:)]
        pub unsafe fn setQuery(&self, query: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other fragment)]
        pub unsafe fn fragment(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setFragment:)]
        pub unsafe fn setFragment(&self, fragment: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        /**
          Getting these properties retains any percent encoding these components may have. Setting these properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause an exception. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
        */
        #[method_id(@__retain_semantics Other percentEncodedUser)]
        pub unsafe fn percentEncodedUser(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Getting these properties retains any percent encoding these components may have. Setting these properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause an exception. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
        */
        #[method(setPercentEncodedUser:)]
        pub unsafe fn setPercentEncodedUser(&self, percent_encoded_user: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other percentEncodedPassword)]
        pub unsafe fn percentEncodedPassword(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPercentEncodedPassword:)]
        pub unsafe fn setPercentEncodedPassword(&self, percent_encoded_password: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use encodedHost instead"]
        #[method_id(@__retain_semantics Other percentEncodedHost)]
        pub unsafe fn percentEncodedHost(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use encodedHost instead"]
        #[method(setPercentEncodedHost:)]
        pub unsafe fn setPercentEncodedHost(&self, percent_encoded_host: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other percentEncodedPath)]
        pub unsafe fn percentEncodedPath(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPercentEncodedPath:)]
        pub unsafe fn setPercentEncodedPath(&self, percent_encoded_path: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other percentEncodedQuery)]
        pub unsafe fn percentEncodedQuery(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPercentEncodedQuery:)]
        pub unsafe fn setPercentEncodedQuery(&self, percent_encoded_query: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other percentEncodedFragment)]
        pub unsafe fn percentEncodedFragment(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setPercentEncodedFragment:)]
        pub unsafe fn setPercentEncodedFragment(&self, percent_encoded_fragment: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other encodedHost)]
        pub unsafe fn encodedHost(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setEncodedHost:)]
        pub unsafe fn setEncodedHost(&self, encoded_host: Option<&NSString>);

        /**
          These properties return the character range of a component in the URL string returned by -[NSURLComponents string]. If the component does not exist in the NSURLComponents object, {NSNotFound, 0} is returned. Note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
        */
        #[method(rangeOfScheme)]
        pub unsafe fn rangeOfScheme(&self) -> NSRange;

        #[method(rangeOfUser)]
        pub unsafe fn rangeOfUser(&self) -> NSRange;

        #[method(rangeOfPassword)]
        pub unsafe fn rangeOfPassword(&self) -> NSRange;

        #[method(rangeOfHost)]
        pub unsafe fn rangeOfHost(&self) -> NSRange;

        #[method(rangeOfPort)]
        pub unsafe fn rangeOfPort(&self) -> NSRange;

        #[method(rangeOfPath)]
        pub unsafe fn rangeOfPath(&self) -> NSRange;

        #[method(rangeOfQuery)]
        pub unsafe fn rangeOfQuery(&self) -> NSRange;

        #[method(rangeOfFragment)]
        pub unsafe fn rangeOfFragment(&self) -> NSRange;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
          The query component as an array of NSURLQueryItems for this NSURLComponents.

         Each NSURLQueryItem represents a single key-value pair,

         Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the NSURLComponents has an empty query component, returns an empty array. If the NSURLComponents has no query component, returns nil.

         The queryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is removed.

         The queryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. If the NSURLQueryItems name or value strings contain any characters not allowed in a URL's query component, those characters are percent-encoded. In addition, any '&' and '=' characters in a NSURLQueryItem name are percent-encoded. Passing an empty array sets the query component of the NSURLComponents to an empty string. Passing nil removes the query component of the NSURLComponents.

         - note: If a NSURLQueryItem name-value pair is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a NSURLQueryItem with a zero-length name and a nil value. If a NSURLQueryItem name-value pair has nothing before the equals sign, you get a zero-length name. If a NSURLQueryItem name-value pair has nothing after the equals sign, you get a zero-length value. If a NSURLQueryItem name-value pair has no equals sign, the NSURLQueryItem name-value pair string is the name and you get a nil value.
        */
        #[method_id(@__retain_semantics Other queryItems)]
        pub unsafe fn queryItems(&self) -> Option<Id<NSArray<NSURLQueryItem>>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
          The query component as an array of NSURLQueryItems for this NSURLComponents.

         Each NSURLQueryItem represents a single key-value pair,

         Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the NSURLComponents has an empty query component, returns an empty array. If the NSURLComponents has no query component, returns nil.

         The queryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is removed.

         The queryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. If the NSURLQueryItems name or value strings contain any characters not allowed in a URL's query component, those characters are percent-encoded. In addition, any '&' and '=' characters in a NSURLQueryItem name are percent-encoded. Passing an empty array sets the query component of the NSURLComponents to an empty string. Passing nil removes the query component of the NSURLComponents.

         - note: If a NSURLQueryItem name-value pair is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a NSURLQueryItem with a zero-length name and a nil value. If a NSURLQueryItem name-value pair has nothing before the equals sign, you get a zero-length name. If a NSURLQueryItem name-value pair has nothing after the equals sign, you get a zero-length value. If a NSURLQueryItem name-value pair has no equals sign, the NSURLQueryItem name-value pair string is the name and you get a nil value.
        */
        #[method(setQueryItems:)]
        pub unsafe fn setQueryItems(&self, query_items: Option<&NSArray<NSURLQueryItem>>);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
          The percentEncodedQueryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is retained.

         The percentEncodedQueryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. This property assumes the NSURLQueryItem names and values are already correctly percent-encoded, and that the NSURLQueryItem names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded NSURLQueryItem or a NSURLQueryItem name with the query item delimiter characters '&' and '=' will cause an exception.
        */
        #[method_id(@__retain_semantics Other percentEncodedQueryItems)]
        pub unsafe fn percentEncodedQueryItems(&self) -> Option<Id<NSArray<NSURLQueryItem>>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSURLQueryItem"))]
        /**
          The percentEncodedQueryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is retained.

         The percentEncodedQueryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. This property assumes the NSURLQueryItem names and values are already correctly percent-encoded, and that the NSURLQueryItem names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded NSURLQueryItem or a NSURLQueryItem name with the query item delimiter characters '&' and '=' will cause an exception.
        */
        #[method(setPercentEncodedQueryItems:)]
        pub unsafe fn setPercentEncodedQueryItems(
            &self,
            percent_encoded_query_items: Option<&NSArray<NSURLQueryItem>>,
        );
    }
);

extern_methods!(
    /// NSURLUtilities
    #[cfg(feature = "Foundation_NSCharacterSet")]
    unsafe impl NSCharacterSet {
        /**
          Returns a character set containing the characters allowed in a URL's user subcomponent.
        */
        #[method_id(@__retain_semantics Other URLUserAllowedCharacterSet)]
        pub unsafe fn URLUserAllowedCharacterSet() -> Id<NSCharacterSet>;

        /**
          Returns a character set containing the characters allowed in a URL's password subcomponent.
        */
        #[method_id(@__retain_semantics Other URLPasswordAllowedCharacterSet)]
        pub unsafe fn URLPasswordAllowedCharacterSet() -> Id<NSCharacterSet>;

        /**
          Returns a character set containing the characters allowed in a URL's host subcomponent.
        */
        #[method_id(@__retain_semantics Other URLHostAllowedCharacterSet)]
        pub unsafe fn URLHostAllowedCharacterSet() -> Id<NSCharacterSet>;

        /**
          Returns a character set containing the characters allowed in a URL's path component. ';' is a legal path character, but it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
        */
        #[method_id(@__retain_semantics Other URLPathAllowedCharacterSet)]
        pub unsafe fn URLPathAllowedCharacterSet() -> Id<NSCharacterSet>;

        /**
          Returns a character set containing the characters allowed in a URL's query component.
        */
        #[method_id(@__retain_semantics Other URLQueryAllowedCharacterSet)]
        pub unsafe fn URLQueryAllowedCharacterSet() -> Id<NSCharacterSet>;

        /**
          Returns a character set containing the characters allowed in a URL's fragment component.
        */
        #[method_id(@__retain_semantics Other URLFragmentAllowedCharacterSet)]
        pub unsafe fn URLFragmentAllowedCharacterSet() -> Id<NSCharacterSet>;
    }
);

extern_methods!(
    /// NSURLUtilities
    #[cfg(feature = "Foundation_NSString")]
    unsafe impl NSString {
        #[cfg(feature = "Foundation_NSCharacterSet")]
        #[method_id(@__retain_semantics Other stringByAddingPercentEncodingWithAllowedCharacters:)]
        pub unsafe fn stringByAddingPercentEncodingWithAllowedCharacters(
            &self,
            allowed_characters: &NSCharacterSet,
        ) -> Option<Id<NSString>>;

        /**
          Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.
        */
        #[method_id(@__retain_semantics Other stringByRemovingPercentEncoding)]
        pub unsafe fn stringByRemovingPercentEncoding(&self) -> Option<Id<NSString>>;

        #[deprecated = "Use -stringByAddingPercentEncodingWithAllowedCharacters: instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid."]
        #[method_id(@__retain_semantics Other stringByAddingPercentEscapesUsingEncoding:)]
        pub unsafe fn stringByAddingPercentEscapesUsingEncoding(
            &self,
            enc: NSStringEncoding,
        ) -> Option<Id<NSString>>;

        #[deprecated = "Use -stringByRemovingPercentEncoding instead, which always uses the recommended UTF-8 encoding."]
        #[method_id(@__retain_semantics Other stringByReplacingPercentEscapesUsingEncoding:)]
        pub unsafe fn stringByReplacingPercentEscapesUsingEncoding(
            &self,
            enc: NSStringEncoding,
        ) -> Option<Id<NSString>>;
    }
);

extern_methods!(
    /// NSURLPathUtilities
    #[cfg(feature = "Foundation_NSURL")]
    unsafe impl NSURL {
        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other fileURLWithPathComponents:)]
        pub unsafe fn fileURLWithPathComponents(
            components: &NSArray<NSString>,
        ) -> Option<Id<NSURL>>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other pathComponents)]
        pub unsafe fn pathComponents(&self) -> Option<Id<NSArray<NSString>>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other lastPathComponent)]
        pub unsafe fn lastPathComponent(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other pathExtension)]
        pub unsafe fn pathExtension(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other URLByAppendingPathComponent:)]
        pub unsafe fn URLByAppendingPathComponent(
            &self,
            path_component: &NSString,
        ) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other URLByAppendingPathComponent:isDirectory:)]
        pub unsafe fn URLByAppendingPathComponent_isDirectory(
            &self,
            path_component: &NSString,
            is_directory: bool,
        ) -> Option<Id<NSURL>>;

        #[method_id(@__retain_semantics Other URLByDeletingLastPathComponent)]
        pub unsafe fn URLByDeletingLastPathComponent(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other URLByAppendingPathExtension:)]
        pub unsafe fn URLByAppendingPathExtension(
            &self,
            path_extension: &NSString,
        ) -> Option<Id<NSURL>>;

        #[method_id(@__retain_semantics Other URLByDeletingPathExtension)]
        pub unsafe fn URLByDeletingPathExtension(&self) -> Option<Id<NSURL>>;

        /**
          The following methods work only on `file:` scheme URLs; for non-`file:` scheme URLs, these methods return the URL unchanged.
        */
        #[method_id(@__retain_semantics Other URLByStandardizingPath)]
        pub unsafe fn URLByStandardizingPath(&self) -> Option<Id<NSURL>>;

        #[method_id(@__retain_semantics Other URLByResolvingSymlinksInPath)]
        pub unsafe fn URLByResolvingSymlinksInPath(&self) -> Option<Id<NSURL>>;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSFileSecurity")]
    /**
      NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
    */
    pub struct NSFileSecurity;

    #[cfg(feature = "Foundation_NSFileSecurity")]
    unsafe impl ClassType for NSFileSecurity {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSFileSecurity")]
/**
  NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
*/
unsafe impl NSCoding for NSFileSecurity {}

#[cfg(feature = "Foundation_NSFileSecurity")]
/**
  NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
*/
unsafe impl NSObjectProtocol for NSFileSecurity {}

#[cfg(feature = "Foundation_NSFileSecurity")]
/**
  NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
*/
unsafe impl NSSecureCoding for NSFileSecurity {}

extern_methods!(
    /**
      NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
    */
    #[cfg(feature = "Foundation_NSFileSecurity")]
    unsafe impl NSFileSecurity {
        #[cfg(feature = "Foundation_NSCoder")]
        #[method_id(@__retain_semantics Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Option<Allocated<Self>>,
            coder: &NSCoder,
        ) -> Option<Id<Self>>;
    }
);

extern_methods!(
    /// NSURLLoading
    #[cfg(feature = "Foundation_NSURL")]
    unsafe impl NSURL {
        #[cfg(feature = "Foundation_NSData")]
        #[deprecated = "Use NSURLConnection instead"]
        #[method_id(@__retain_semantics Other resourceDataUsingCache:)]
        pub unsafe fn resourceDataUsingCache(&self, should_use_cache: bool) -> Option<Id<NSData>>;

        #[deprecated = "Use NSURLConnection instead"]
        #[method(loadResourceDataNotifyingClient:usingCache:)]
        pub unsafe fn loadResourceDataNotifyingClient_usingCache(
            &self,
            client: &Object,
            should_use_cache: bool,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use NSURLConnection instead"]
        #[method_id(@__retain_semantics Other propertyForKey:)]
        pub unsafe fn propertyForKey(&self, property_key: &NSString) -> Option<Id<Object>>;

        #[cfg(feature = "Foundation_NSData")]
        #[deprecated = "Use NSURLConnection instead"]
        #[method(setResourceData:)]
        pub unsafe fn setResourceData(&self, data: &NSData) -> bool;

        #[cfg(feature = "Foundation_NSString")]
        #[deprecated = "Use NSURLConnection instead"]
        #[method(setProperty:forKey:)]
        pub unsafe fn setProperty_forKey(&self, property: &Object, property_key: &NSString)
            -> bool;

        #[cfg(feature = "Foundation_NSURLHandle")]
        #[deprecated = "Use NSURLConnection instead"]
        #[method_id(@__retain_semantics Other URLHandleUsingCache:)]
        pub unsafe fn URLHandleUsingCache(&self, should_use_cache: bool)
            -> Option<Id<NSURLHandle>>;
    }
);
