//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSURLDownload")]
    /**
     @class NSURLDownload
    @discussion A NSURLDownload loads a request and saves the downloaded data to a file. The progress of the download
    is reported via the NSURLDownloadDelegate protocol. Note: The word "download" is used to refer to the process
    of loading data off a network, decoding the data if necessary and saving the data to a file.
    */
    pub struct NSURLDownload;

    #[cfg(feature = "Foundation_NSURLDownload")]
    unsafe impl ClassType for NSURLDownload {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSURLDownload")]
/**
 @class NSURLDownload
@discussion A NSURLDownload loads a request and saves the downloaded data to a file. The progress of the download
is reported via the NSURLDownloadDelegate protocol. Note: The word "download" is used to refer to the process
of loading data off a network, decoding the data if necessary and saving the data to a file.
*/
unsafe impl NSObjectProtocol for NSURLDownload {}

extern_methods!(
    /**
     @class NSURLDownload
    @discussion A NSURLDownload loads a request and saves the downloaded data to a file. The progress of the download
    is reported via the NSURLDownloadDelegate protocol. Note: The word "download" is used to refer to the process
    of loading data off a network, decoding the data if necessary and saving the data to a file.
    */
    #[cfg(feature = "Foundation_NSURLDownload")]
    unsafe impl NSURLDownload {
        #[cfg(feature = "Foundation_NSString")]
        #[method(canResumeDownloadDecodedWithEncodingMIMEType:)]
        pub unsafe fn canResumeDownloadDecodedWithEncodingMIMEType(mime_type: &NSString) -> bool;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[deprecated = "Use NSURLSession downloadTask (see NSURLSession.h)"]
        #[method_id(@__retain_semantics Init initWithRequest:delegate:)]
        pub unsafe fn initWithRequest_delegate(
            this: Option<Allocated<Self>>,
            request: &NSURLRequest,
            delegate: Option<&ProtocolObject<dyn NSURLDownloadDelegate>>,
        ) -> Id<Self>;

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSString"))]
        #[deprecated = "Use NSURLSession downloadTask (see NSURLSession.h)"]
        #[method_id(@__retain_semantics Init initWithResumeData:delegate:path:)]
        pub unsafe fn initWithResumeData_delegate_path(
            this: Option<Allocated<Self>>,
            resume_data: &NSData,
            delegate: Option<&ProtocolObject<dyn NSURLDownloadDelegate>>,
            path: &NSString,
        ) -> Id<Self>;

        #[method(cancel)]
        pub unsafe fn cancel(&self);

        #[cfg(feature = "Foundation_NSString")]
        #[method(setDestination:allowOverwrite:)]
        pub unsafe fn setDestination_allowOverwrite(&self, path: &NSString, allow_overwrite: bool);

        #[cfg(feature = "Foundation_NSURLRequest")]
        /**
         @abstract Returns the request of the download.
        @result The request of the download.
        */
        #[method_id(@__retain_semantics Other request)]
        pub unsafe fn request(&self) -> Id<NSURLRequest>;

        #[cfg(feature = "Foundation_NSData")]
        /**
         @abstract Returns the resume data of a download that is incomplete.
        @result The resume data.
        @description resumeData returns the resume data of a download that is incomplete. This data represents the necessary
        state information that NSURLDownload needs to resume a download. The resume data can later be used when initializing
        a download with initWithResumeData:delegate:path:. Non-nil is returned if resuming the download seems possible.
        Non-nil is returned if the download was cancelled or ended in error after some but not all data has been received.
        The protocol of the download as well as the server must support resuming for non-nil to be returned.
        In order to later resume a download, be sure to call setDeletesFileUponFailure: with NO.
        */
        #[method_id(@__retain_semantics Other resumeData)]
        pub unsafe fn resumeData(&self) -> Option<Id<NSData>>;

        /**
         @abstract Sets whether or not the downloaded file should be deleted upon failure.
        1    @description To allow the download to be resumed in case the download ends prematurely,
        deletesFileUponFailure must be set to NO as soon as possible to prevent the downloaded file
        from being deleted. deletesFileUponFailure is YES by default.
        */
        #[method(deletesFileUponFailure)]
        pub unsafe fn deletesFileUponFailure(&self) -> bool;

        /**
         @abstract Sets whether or not the downloaded file should be deleted upon failure.
        1    @description To allow the download to be resumed in case the download ends prematurely,
        deletesFileUponFailure must be set to NO as soon as possible to prevent the downloaded file
        from being deleted. deletesFileUponFailure is YES by default.
        */
        #[method(setDeletesFileUponFailure:)]
        pub unsafe fn setDeletesFileUponFailure(&self, deletes_file_upon_failure: bool);
    }
);

extern_protocol!(
    /**
     @protocol NSURLDownloadDelegate
    @discussion The NSURLDownloadDelegate delegate is used to report the progress of the download.
    */
    pub unsafe trait NSURLDownloadDelegate: NSObjectProtocol {
        #[cfg(feature = "Foundation_NSURLDownload")]
        #[optional]
        #[method(downloadDidBegin:)]
        unsafe fn downloadDidBegin(&self, download: &NSURLDownload);

        #[cfg(all(
            feature = "Foundation_NSURLDownload",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other download:willSendRequest:redirectResponse:)]
        unsafe fn download_willSendRequest_redirectResponse(
            &self,
            download: &NSURLDownload,
            request: &NSURLRequest,
            redirect_response: Option<&NSURLResponse>,
        ) -> Option<Id<NSURLRequest>>;

        #[cfg(all(
            feature = "Foundation_NSURLDownload",
            feature = "Foundation_NSURLProtectionSpace"
        ))]
        #[optional]
        #[method(download:canAuthenticateAgainstProtectionSpace:)]
        unsafe fn download_canAuthenticateAgainstProtectionSpace(
            &self,
            connection: &NSURLDownload,
            protection_space: &NSURLProtectionSpace,
        ) -> bool;

        #[cfg(all(
            feature = "Foundation_NSURLAuthenticationChallenge",
            feature = "Foundation_NSURLDownload"
        ))]
        #[optional]
        #[method(download:didReceiveAuthenticationChallenge:)]
        unsafe fn download_didReceiveAuthenticationChallenge(
            &self,
            download: &NSURLDownload,
            challenge: &NSURLAuthenticationChallenge,
        );

        #[cfg(all(
            feature = "Foundation_NSURLAuthenticationChallenge",
            feature = "Foundation_NSURLDownload"
        ))]
        #[optional]
        #[method(download:didCancelAuthenticationChallenge:)]
        unsafe fn download_didCancelAuthenticationChallenge(
            &self,
            download: &NSURLDownload,
            challenge: &NSURLAuthenticationChallenge,
        );

        #[cfg(feature = "Foundation_NSURLDownload")]
        #[optional]
        #[method(downloadShouldUseCredentialStorage:)]
        unsafe fn downloadShouldUseCredentialStorage(&self, download: &NSURLDownload) -> bool;

        #[cfg(all(
            feature = "Foundation_NSURLDownload",
            feature = "Foundation_NSURLResponse"
        ))]
        #[optional]
        #[method(download:didReceiveResponse:)]
        unsafe fn download_didReceiveResponse(
            &self,
            download: &NSURLDownload,
            response: &NSURLResponse,
        );

        #[cfg(all(
            feature = "Foundation_NSURLDownload",
            feature = "Foundation_NSURLResponse"
        ))]
        #[optional]
        #[method(download:willResumeWithResponse:fromByte:)]
        unsafe fn download_willResumeWithResponse_fromByte(
            &self,
            download: &NSURLDownload,
            response: &NSURLResponse,
            starting_byte: c_longlong,
        );

        #[cfg(feature = "Foundation_NSURLDownload")]
        #[optional]
        #[method(download:didReceiveDataOfLength:)]
        unsafe fn download_didReceiveDataOfLength(
            &self,
            download: &NSURLDownload,
            length: NSUInteger,
        );

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURLDownload"))]
        #[optional]
        #[method(download:shouldDecodeSourceDataOfMIMEType:)]
        unsafe fn download_shouldDecodeSourceDataOfMIMEType(
            &self,
            download: &NSURLDownload,
            encoding_type: &NSString,
        ) -> bool;

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURLDownload"))]
        #[optional]
        #[method(download:decideDestinationWithSuggestedFilename:)]
        unsafe fn download_decideDestinationWithSuggestedFilename(
            &self,
            download: &NSURLDownload,
            filename: &NSString,
        );

        #[cfg(all(feature = "Foundation_NSString", feature = "Foundation_NSURLDownload"))]
        #[optional]
        #[method(download:didCreateDestination:)]
        unsafe fn download_didCreateDestination(&self, download: &NSURLDownload, path: &NSString);

        #[cfg(feature = "Foundation_NSURLDownload")]
        #[optional]
        #[method(downloadDidFinish:)]
        unsafe fn downloadDidFinish(&self, download: &NSURLDownload);

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURLDownload"))]
        #[optional]
        #[method(download:didFailWithError:)]
        unsafe fn download_didFailWithError(&self, download: &NSURLDownload, error: &NSError);
    }

    unsafe impl ProtocolType for dyn NSURLDownloadDelegate {}
);
