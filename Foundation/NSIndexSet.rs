//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSIndexSet")]
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    pub struct NSIndexSet;

    #[cfg(feature = "Foundation_NSIndexSet")]
    unsafe impl ClassType for NSIndexSet {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSIndexSet")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSCoding for NSIndexSet {}

#[cfg(feature = "Foundation_NSIndexSet")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSObjectProtocol for NSIndexSet {}

#[cfg(feature = "Foundation_NSIndexSet")]
/**
  An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

----| contains        -------> [CUSTOM TEXT FIELD]
Name-------------|   | starts with     |
Kind                 | ends with-------|
Creation date        | is
Modification date

Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

@"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
@"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
@"displayValues" -> ordered to-many relation containing the display values for the row
@"criteria" -> ordered to-many relation containing the criteria for the row

These key paths can be set using the set*KeyPath: methods below
*/
unsafe impl NSSecureCoding for NSIndexSet {}

extern_methods!(
    /**
      An NSRuleEditor is a class that allows the user to create and configure a list of options.  The view has a delegate which offers a tree of choices to the view.  The choices are presented by the view to the user as a row of popup buttons, static text fields, and custom views.  Each row in the list represents a particular path down the tree of choices.  An example of part of a tree of choices and a path through it:

    ----| contains        -------> [CUSTOM TEXT FIELD]
    Name-------------|   | starts with     |
    Kind                 | ends with-------|
    Creation date        | is
    Modification date

    Each node in the tree is represented by a "criterion," which can be any object.  As the user chooses from the popup menus, the rule editor view will query its delegate for the child criteria of the chosen criterion.  The only restriction on the criteria is that two criterions should be considered equal by isEqual: if they represent the same node, and must not be equal if they represent different nodes.  The path through the tree for a given row is represented by the array of criteria for the row.  For example, the criteria for the above selection would represent "Name", "ends with", and the custom text field; the manner in which the criteria represent those values is up to the developer.

    There are two types of rows - standard rows and header rows (NSRuleEditorRowTypeSimple and NSRuleEditorRowTypeCompound).  A header row can contain other rows, but a standard row cannot.  Header rows and standard rows can have different trees of criteria.  The amount and style of row nesting is configurable.

    Every time a row is created or modified, the rule editor view will query its delegate view for a "display value" for each new criteriion in the row.  The display value is what is presented to the user, and must be a NSString, NSView, or NSMenuItem.  When a criterion is selected in the row, the rule editor will query the criterion for its child criteria and then each of the children for their display value.  If there are multiple children, a popup button is formed from the string values and menu items.  If there is only one child, its display value is displayed as a static text field (if it is a string) or as a view (if the value is a view).

    NSRuleEditor has some optional support for predicates.  For each row, it will ask its delegate for various parts of a predicate, which are returned in a dictionary.  Assuming the delegate returns enough parts for each row, the parts are then combined to form a predicate for the entire view.  This is expressed in the  "predicate" property for the view.  Subclassers can modify the predicate for each row as it is constructed.  Setting a predicate back on the view is not supported.

    NSRuleEditor exposes one binding, "rows."  The "rows" binding may be bound to an ordered to-many relation (e.g. NSMutableArray).  Each object in the relation should have the following properties:

    @"rowType" -> integer representing the type of the row (NSRuleEditorRowType)
    @"subrows" -> ordered to-many relation (e.g. NSMutableArray) containing the directly nested subrows for the given row
    @"displayValues" -> ordered to-many relation containing the display values for the row
    @"criteria" -> ordered to-many relation containing the criteria for the row

    These key paths can be set using the set*KeyPath: methods below
    */
    #[cfg(feature = "Foundation_NSIndexSet")]
    unsafe impl NSIndexSet {
        #[method_id(@__retain_semantics Other indexSet)]
        pub unsafe fn indexSet() -> Id<Self>;

        #[method_id(@__retain_semantics Other indexSetWithIndex:)]
        pub unsafe fn indexSetWithIndex(value: NSUInteger) -> Id<Self>;

        #[method_id(@__retain_semantics Other indexSetWithIndexesInRange:)]
        pub unsafe fn indexSetWithIndexesInRange(range: NSRange) -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithIndexesInRange:)]
        pub unsafe fn initWithIndexesInRange(
            this: Option<Allocated<Self>>,
            range: NSRange,
        ) -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithIndexSet:)]
        pub unsafe fn initWithIndexSet(
            this: Option<Allocated<Self>>,
            index_set: &NSIndexSet,
        ) -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithIndex:)]
        pub unsafe fn initWithIndex(this: Option<Allocated<Self>>, value: NSUInteger) -> Id<Self>;

        #[method(isEqualToIndexSet:)]
        pub unsafe fn isEqualToIndexSet(&self, index_set: &NSIndexSet) -> bool;

        #[method(count)]
        pub unsafe fn count(&self) -> NSUInteger;

        /**
          The following six methods will return NSNotFound if there is no index in the set satisfying the query.
        */
        #[method(firstIndex)]
        pub unsafe fn firstIndex(&self) -> NSUInteger;

        #[method(lastIndex)]
        pub unsafe fn lastIndex(&self) -> NSUInteger;

        #[method(indexGreaterThanIndex:)]
        pub unsafe fn indexGreaterThanIndex(&self, value: NSUInteger) -> NSUInteger;

        #[method(indexLessThanIndex:)]
        pub unsafe fn indexLessThanIndex(&self, value: NSUInteger) -> NSUInteger;

        #[method(indexGreaterThanOrEqualToIndex:)]
        pub unsafe fn indexGreaterThanOrEqualToIndex(&self, value: NSUInteger) -> NSUInteger;

        #[method(indexLessThanOrEqualToIndex:)]
        pub unsafe fn indexLessThanOrEqualToIndex(&self, value: NSUInteger) -> NSUInteger;

        #[method(getIndexes:maxCount:inIndexRange:)]
        pub unsafe fn getIndexes_maxCount_inIndexRange(
            &self,
            index_buffer: NonNull<NSUInteger>,
            buffer_size: NSUInteger,
            range: NSRangePointer,
        ) -> NSUInteger;

        #[method(countOfIndexesInRange:)]
        pub unsafe fn countOfIndexesInRange(&self, range: NSRange) -> NSUInteger;

        #[method(containsIndex:)]
        pub unsafe fn containsIndex(&self, value: NSUInteger) -> bool;

        #[method(containsIndexesInRange:)]
        pub unsafe fn containsIndexesInRange(&self, range: NSRange) -> bool;

        #[method(containsIndexes:)]
        pub unsafe fn containsIndexes(&self, index_set: &NSIndexSet) -> bool;

        #[method(intersectsIndexesInRange:)]
        pub unsafe fn intersectsIndexesInRange(&self, range: NSRange) -> bool;

        #[method(enumerateIndexesUsingBlock:)]
        pub unsafe fn enumerateIndexesUsingBlock(
            &self,
            block: &Block<(NSUInteger, NonNull<Bool>), ()>,
        );

        #[method(enumerateIndexesWithOptions:usingBlock:)]
        pub unsafe fn enumerateIndexesWithOptions_usingBlock(
            &self,
            opts: NSEnumerationOptions,
            block: &Block<(NSUInteger, NonNull<Bool>), ()>,
        );

        #[method(enumerateIndexesInRange:options:usingBlock:)]
        pub unsafe fn enumerateIndexesInRange_options_usingBlock(
            &self,
            range: NSRange,
            opts: NSEnumerationOptions,
            block: &Block<(NSUInteger, NonNull<Bool>), ()>,
        );

        #[method(indexPassingTest:)]
        pub unsafe fn indexPassingTest(
            &self,
            predicate: &Block<(NSUInteger, NonNull<Bool>), Bool>,
        ) -> NSUInteger;

        #[method(indexWithOptions:passingTest:)]
        pub unsafe fn indexWithOptions_passingTest(
            &self,
            opts: NSEnumerationOptions,
            predicate: &Block<(NSUInteger, NonNull<Bool>), Bool>,
        ) -> NSUInteger;

        #[method(indexInRange:options:passingTest:)]
        pub unsafe fn indexInRange_options_passingTest(
            &self,
            range: NSRange,
            opts: NSEnumerationOptions,
            predicate: &Block<(NSUInteger, NonNull<Bool>), Bool>,
        ) -> NSUInteger;

        #[method_id(@__retain_semantics Other indexesPassingTest:)]
        pub unsafe fn indexesPassingTest(
            &self,
            predicate: &Block<(NSUInteger, NonNull<Bool>), Bool>,
        ) -> Id<NSIndexSet>;

        #[method_id(@__retain_semantics Other indexesWithOptions:passingTest:)]
        pub unsafe fn indexesWithOptions_passingTest(
            &self,
            opts: NSEnumerationOptions,
            predicate: &Block<(NSUInteger, NonNull<Bool>), Bool>,
        ) -> Id<NSIndexSet>;

        #[method_id(@__retain_semantics Other indexesInRange:options:passingTest:)]
        pub unsafe fn indexesInRange_options_passingTest(
            &self,
            range: NSRange,
            opts: NSEnumerationOptions,
            predicate: &Block<(NSUInteger, NonNull<Bool>), Bool>,
        ) -> Id<NSIndexSet>;

        #[method(enumerateRangesUsingBlock:)]
        pub unsafe fn enumerateRangesUsingBlock(&self, block: &Block<(NSRange, NonNull<Bool>), ()>);

        #[method(enumerateRangesWithOptions:usingBlock:)]
        pub unsafe fn enumerateRangesWithOptions_usingBlock(
            &self,
            opts: NSEnumerationOptions,
            block: &Block<(NSRange, NonNull<Bool>), ()>,
        );

        #[method(enumerateRangesInRange:options:usingBlock:)]
        pub unsafe fn enumerateRangesInRange_options_usingBlock(
            &self,
            range: NSRange,
            opts: NSEnumerationOptions,
            block: &Block<(NSRange, NonNull<Bool>), ()>,
        );
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSMutableIndexSet")]
    pub struct NSMutableIndexSet;

    #[cfg(feature = "Foundation_NSMutableIndexSet")]
    unsafe impl ClassType for NSMutableIndexSet {
        #[inherits(NSObject)]
        type Super = NSIndexSet;
    }
);

#[cfg(feature = "Foundation_NSMutableIndexSet")]
unsafe impl NSCoding for NSMutableIndexSet {}

#[cfg(feature = "Foundation_NSMutableIndexSet")]
unsafe impl NSObjectProtocol for NSMutableIndexSet {}

#[cfg(feature = "Foundation_NSMutableIndexSet")]
unsafe impl NSSecureCoding for NSMutableIndexSet {}

extern_methods!(
    #[cfg(feature = "Foundation_NSMutableIndexSet")]
    unsafe impl NSMutableIndexSet {
        #[method(addIndexes:)]
        pub unsafe fn addIndexes(&self, index_set: &NSIndexSet);

        #[method(removeIndexes:)]
        pub unsafe fn removeIndexes(&self, index_set: &NSIndexSet);

        #[method(removeAllIndexes)]
        pub unsafe fn removeAllIndexes(&self);

        #[method(addIndex:)]
        pub unsafe fn addIndex(&self, value: NSUInteger);

        #[method(removeIndex:)]
        pub unsafe fn removeIndex(&self, value: NSUInteger);

        #[method(addIndexesInRange:)]
        pub unsafe fn addIndexesInRange(&self, range: NSRange);

        #[method(removeIndexesInRange:)]
        pub unsafe fn removeIndexesInRange(&self, range: NSRange);

        #[method(shiftIndexesStartingAtIndex:by:)]
        pub unsafe fn shiftIndexesStartingAtIndex_by(&self, index: NSUInteger, delta: NSInteger);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSIndexSet`
    #[cfg(feature = "Foundation_NSMutableIndexSet")]
    unsafe impl NSMutableIndexSet {
        #[method_id(@__retain_semantics Other indexSet)]
        pub unsafe fn indexSet() -> Id<Self, Owned>;

        #[method_id(@__retain_semantics Other indexSetWithIndex:)]
        pub unsafe fn indexSetWithIndex(value: NSUInteger) -> Id<Self, Owned>;

        #[method_id(@__retain_semantics Other indexSetWithIndexesInRange:)]
        pub unsafe fn indexSetWithIndexesInRange(range: NSRange) -> Id<Self, Owned>;

        #[method_id(@__retain_semantics Init initWithIndexesInRange:)]
        pub unsafe fn initWithIndexesInRange(
            this: Option<Allocated<Self>>,
            range: NSRange,
        ) -> Id<Self, Owned>;

        #[method_id(@__retain_semantics Init initWithIndexSet:)]
        pub unsafe fn initWithIndexSet(
            this: Option<Allocated<Self>>,
            index_set: &NSIndexSet,
        ) -> Id<Self, Owned>;

        #[method_id(@__retain_semantics Init initWithIndex:)]
        pub unsafe fn initWithIndex(
            this: Option<Allocated<Self>>,
            value: NSUInteger,
        ) -> Id<Self, Owned>;
    }
);
