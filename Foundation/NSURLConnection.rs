//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "Foundation_NSURLConnection")]
    /**
     @class NSURLConnection

    @abstract An NSURLConnection object provides support to perform
    asynchronous loads of a URL request, providing data to a
    client supplied delegate.

    @discussion The interface for NSURLConnection is very sparse, providing
    only the controls to start and cancel asynchronous loads of a
    URL request.<p>

    An NSURLConnection may be used for loading of resource data
    directly to memory, in which case an
    NSURLConnectionDataDelegate should be supplied, or for
    downloading of resource data directly to a file, in which case
    an NSURLConnectionDownloadDelegate is used.  The delegate is
    retained by the NSURLConnection until a terminal condition is
    encountered.  These two delegates are logically subclasses of
    the base protocol, NSURLConnectionDelegate.<p>

    A terminal condition produced by the loader will result in a
    connection:didFailWithError: in the case of an error, or
    connectionDidFinishLoading: or connectionDidFinishDownloading:
    delegate message.<p>

    The -cancel message hints to the loader that a resource load
    should be abandoned but does not guarantee that more delegate
    messages will not be delivered.  If -cancel does cause the
    load to be abandoned, the delegate will be released without
    further messages.  In general, a caller should be prepared for
    -cancel to have no effect, and internally ignore any delegate
    callbacks until the delegate is released.

    Scheduling of an NSURLConnection specifies the context in
    which delegate callbacks will be made, but the actual IO may
    occur on a separate thread and should be considered an
    implementation detail.<p>

    When created, an NSURLConnection performs a deep-copy of the
    NSURLRequest.  This copy is available through the
    -originalRequest method.  As the connection performs the load,
    this request may change as a result of protocol
    canonicalization or due to following redirects.
    -currentRequest can be used to retrieve this value.<p>

    An NSURLConnections created with the
    +connectionWithRequest:delegate: or -initWithRequest:delegate:
    methods are scheduled on the current runloop immediately, and
    it is not necessary to send the -start message to begin the
    resource load.<p>

    NSURLConnections created with
    -initWithRequest:delegate:startImmediately: are not
    automatically scheduled.  Use -scheduleWithRunLoop:forMode: or
    -setDelegateQueue: to specify the context for delegate
    callbacks, and -start to begin the load.  If you do not
    explicitly schedule the connection before -start, it will be
    scheduled on the current runloop and mode automatically.<p>

    The NSURLConnectionSynchronousLoading category adds
    +sendSynchronousRequest:returningResponse:error, which blocks
    the current thread until the resource data is available or an
    error occurs.  It should be noted that using this method on an
    applications main run loop may result in an unacceptably long
    delay in a user interface and its use is strongly
    discourage.<p>

    The NSURLConnectionQueuedLoading category implements
    +sendAsynchronousRequest:queue:completionHandler, providing
    similar simplicity but provides a mechanism where the current
    runloop is not blocked.<p>

    Both of the immediate loading categories do not provide for
    customization of resource load, and do not allow the caller to
    respond to, e.g., authentication challenges.<p>
    */
    pub struct NSURLConnection;

    #[cfg(feature = "Foundation_NSURLConnection")]
    unsafe impl ClassType for NSURLConnection {
        type Super = NSObject;
    }
);

#[cfg(feature = "Foundation_NSURLConnection")]
/**
 @class NSURLConnection

@abstract An NSURLConnection object provides support to perform
asynchronous loads of a URL request, providing data to a
client supplied delegate.

@discussion The interface for NSURLConnection is very sparse, providing
only the controls to start and cancel asynchronous loads of a
URL request.<p>

An NSURLConnection may be used for loading of resource data
directly to memory, in which case an
NSURLConnectionDataDelegate should be supplied, or for
downloading of resource data directly to a file, in which case
an NSURLConnectionDownloadDelegate is used.  The delegate is
retained by the NSURLConnection until a terminal condition is
encountered.  These two delegates are logically subclasses of
the base protocol, NSURLConnectionDelegate.<p>

A terminal condition produced by the loader will result in a
connection:didFailWithError: in the case of an error, or
connectionDidFinishLoading: or connectionDidFinishDownloading:
delegate message.<p>

The -cancel message hints to the loader that a resource load
should be abandoned but does not guarantee that more delegate
messages will not be delivered.  If -cancel does cause the
load to be abandoned, the delegate will be released without
further messages.  In general, a caller should be prepared for
-cancel to have no effect, and internally ignore any delegate
callbacks until the delegate is released.

Scheduling of an NSURLConnection specifies the context in
which delegate callbacks will be made, but the actual IO may
occur on a separate thread and should be considered an
implementation detail.<p>

When created, an NSURLConnection performs a deep-copy of the
NSURLRequest.  This copy is available through the
-originalRequest method.  As the connection performs the load,
this request may change as a result of protocol
canonicalization or due to following redirects.
-currentRequest can be used to retrieve this value.<p>

An NSURLConnections created with the
+connectionWithRequest:delegate: or -initWithRequest:delegate:
methods are scheduled on the current runloop immediately, and
it is not necessary to send the -start message to begin the
resource load.<p>

NSURLConnections created with
-initWithRequest:delegate:startImmediately: are not
automatically scheduled.  Use -scheduleWithRunLoop:forMode: or
-setDelegateQueue: to specify the context for delegate
callbacks, and -start to begin the load.  If you do not
explicitly schedule the connection before -start, it will be
scheduled on the current runloop and mode automatically.<p>

The NSURLConnectionSynchronousLoading category adds
+sendSynchronousRequest:returningResponse:error, which blocks
the current thread until the resource data is available or an
error occurs.  It should be noted that using this method on an
applications main run loop may result in an unacceptably long
delay in a user interface and its use is strongly
discourage.<p>

The NSURLConnectionQueuedLoading category implements
+sendAsynchronousRequest:queue:completionHandler, providing
similar simplicity but provides a mechanism where the current
runloop is not blocked.<p>

Both of the immediate loading categories do not provide for
customization of resource load, and do not allow the caller to
respond to, e.g., authentication challenges.<p>
*/
unsafe impl NSObjectProtocol for NSURLConnection {}

extern_methods!(
    /**
     @class NSURLConnection

    @abstract An NSURLConnection object provides support to perform
    asynchronous loads of a URL request, providing data to a
    client supplied delegate.

    @discussion The interface for NSURLConnection is very sparse, providing
    only the controls to start and cancel asynchronous loads of a
    URL request.<p>

    An NSURLConnection may be used for loading of resource data
    directly to memory, in which case an
    NSURLConnectionDataDelegate should be supplied, or for
    downloading of resource data directly to a file, in which case
    an NSURLConnectionDownloadDelegate is used.  The delegate is
    retained by the NSURLConnection until a terminal condition is
    encountered.  These two delegates are logically subclasses of
    the base protocol, NSURLConnectionDelegate.<p>

    A terminal condition produced by the loader will result in a
    connection:didFailWithError: in the case of an error, or
    connectionDidFinishLoading: or connectionDidFinishDownloading:
    delegate message.<p>

    The -cancel message hints to the loader that a resource load
    should be abandoned but does not guarantee that more delegate
    messages will not be delivered.  If -cancel does cause the
    load to be abandoned, the delegate will be released without
    further messages.  In general, a caller should be prepared for
    -cancel to have no effect, and internally ignore any delegate
    callbacks until the delegate is released.

    Scheduling of an NSURLConnection specifies the context in
    which delegate callbacks will be made, but the actual IO may
    occur on a separate thread and should be considered an
    implementation detail.<p>

    When created, an NSURLConnection performs a deep-copy of the
    NSURLRequest.  This copy is available through the
    -originalRequest method.  As the connection performs the load,
    this request may change as a result of protocol
    canonicalization or due to following redirects.
    -currentRequest can be used to retrieve this value.<p>

    An NSURLConnections created with the
    +connectionWithRequest:delegate: or -initWithRequest:delegate:
    methods are scheduled on the current runloop immediately, and
    it is not necessary to send the -start message to begin the
    resource load.<p>

    NSURLConnections created with
    -initWithRequest:delegate:startImmediately: are not
    automatically scheduled.  Use -scheduleWithRunLoop:forMode: or
    -setDelegateQueue: to specify the context for delegate
    callbacks, and -start to begin the load.  If you do not
    explicitly schedule the connection before -start, it will be
    scheduled on the current runloop and mode automatically.<p>

    The NSURLConnectionSynchronousLoading category adds
    +sendSynchronousRequest:returningResponse:error, which blocks
    the current thread until the resource data is available or an
    error occurs.  It should be noted that using this method on an
    applications main run loop may result in an unacceptably long
    delay in a user interface and its use is strongly
    discourage.<p>

    The NSURLConnectionQueuedLoading category implements
    +sendAsynchronousRequest:queue:completionHandler, providing
    similar simplicity but provides a mechanism where the current
    runloop is not blocked.<p>

    Both of the immediate loading categories do not provide for
    customization of resource load, and do not allow the caller to
    respond to, e.g., authentication challenges.<p>
    */
    #[cfg(feature = "Foundation_NSURLConnection")]
    unsafe impl NSURLConnection {
        #[cfg(feature = "Foundation_NSURLRequest")]
        #[deprecated = "Use NSURLSession (see NSURLSession.h)"]
        #[method_id(@__retain_semantics Init initWithRequest:delegate:startImmediately:)]
        pub unsafe fn initWithRequest_delegate_startImmediately(
            this: Option<Allocated<Self>>,
            request: &NSURLRequest,
            delegate: Option<&Object>,
            start_immediately: bool,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[deprecated = "Use NSURLSession (see NSURLSession.h)"]
        #[method_id(@__retain_semantics Init initWithRequest:delegate:)]
        pub unsafe fn initWithRequest_delegate(
            this: Option<Allocated<Self>>,
            request: &NSURLRequest,
            delegate: Option<&Object>,
        ) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[deprecated = "Use NSURLSession (see NSURLSession.h)"]
        #[method_id(@__retain_semantics Other connectionWithRequest:delegate:)]
        pub unsafe fn connectionWithRequest_delegate(
            request: &NSURLRequest,
            delegate: Option<&Object>,
        ) -> Option<Id<NSURLConnection>>;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[method_id(@__retain_semantics Other originalRequest)]
        pub unsafe fn originalRequest(&self) -> Id<NSURLRequest>;

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[method_id(@__retain_semantics Other currentRequest)]
        pub unsafe fn currentRequest(&self) -> Id<NSURLRequest>;

        #[method(start)]
        pub unsafe fn start(&self);

        #[method(cancel)]
        pub unsafe fn cancel(&self);

        #[cfg(feature = "Foundation_NSRunLoop")]
        #[method(scheduleInRunLoop:forMode:)]
        pub unsafe fn scheduleInRunLoop_forMode(
            &self,
            a_run_loop: &NSRunLoop,
            mode: &NSRunLoopMode,
        );

        #[cfg(feature = "Foundation_NSRunLoop")]
        #[method(unscheduleFromRunLoop:forMode:)]
        pub unsafe fn unscheduleFromRunLoop_forMode(
            &self,
            a_run_loop: &NSRunLoop,
            mode: &NSRunLoopMode,
        );

        #[cfg(feature = "Foundation_NSOperationQueue")]
        #[method(setDelegateQueue:)]
        pub unsafe fn setDelegateQueue(&self, queue: Option<&NSOperationQueue>);

        #[cfg(feature = "Foundation_NSURLRequest")]
        #[method(canHandleRequest:)]
        pub unsafe fn canHandleRequest(request: &NSURLRequest) -> bool;
    }
);

extern_protocol!(
    /**
     @protocol       NSURLConnectionDelegate

    @abstract
    Delegate methods that are common to all forms of
    NSURLConnection.  These are all optional.  This
    protocol should be considered a base class for the
    NSURLConnectionDataDelegate and
    NSURLConnectionDownloadDelegate protocols.

    @discussion
    connection:didFailWithError: will be called at
    most once, if an error occurs during a resource
    load.  No other callbacks will be made after.<p>

    connectionShouldUseCredentialStorage: will be
    called at most once, before a resource load begins
    (which means it may be called during construction
    of the connection.)  The delegate should return
    TRUE if the connection should consult the shared
    NSURLCredentialStorage in response to
    authentication challenges.  Regardless of the
    result, the authentication challenge methods may
    still be called.

    connection:willSendRequestForAuthenticationChallenge:
    is the preferred (Mac OS X 10.7 and iOS 5.0 or
    later) mechanism for responding to authentication
    challenges.  See
    <Foundation/NSURLAuthenticationChallenge.h> for
    more information on dealing with the various types
    of authentication challenges.

    connection:canAuthenticateAgainstProtectionSpace:
    connection:didReceiveAuthenticationChallenge:
    connection:didCancelAuthenticationChallenge: are
    deprecated and new code should adopt
    connection:willSendRequestForAuthenticationChallenge.
    The older delegates will still be called for
    compatibility, but incur more latency in dealing
    with the authentication challenge.
    */
    pub unsafe trait NSURLConnectionDelegate: NSObjectProtocol {
        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURLConnection"))]
        #[optional]
        #[method(connection:didFailWithError:)]
        unsafe fn connection_didFailWithError(&self, connection: &NSURLConnection, error: &NSError);

        #[cfg(feature = "Foundation_NSURLConnection")]
        #[optional]
        #[method(connectionShouldUseCredentialStorage:)]
        unsafe fn connectionShouldUseCredentialStorage(&self, connection: &NSURLConnection)
            -> bool;

        #[cfg(all(
            feature = "Foundation_NSURLAuthenticationChallenge",
            feature = "Foundation_NSURLConnection"
        ))]
        #[optional]
        #[method(connection:willSendRequestForAuthenticationChallenge:)]
        unsafe fn connection_willSendRequestForAuthenticationChallenge(
            &self,
            connection: &NSURLConnection,
            challenge: &NSURLAuthenticationChallenge,
        );

        #[cfg(all(
            feature = "Foundation_NSURLConnection",
            feature = "Foundation_NSURLProtectionSpace"
        ))]
        #[deprecated = "Use -connection:willSendRequestForAuthenticationChallenge: instead."]
        #[optional]
        #[method(connection:canAuthenticateAgainstProtectionSpace:)]
        unsafe fn connection_canAuthenticateAgainstProtectionSpace(
            &self,
            connection: &NSURLConnection,
            protection_space: &NSURLProtectionSpace,
        ) -> bool;

        #[cfg(all(
            feature = "Foundation_NSURLAuthenticationChallenge",
            feature = "Foundation_NSURLConnection"
        ))]
        #[deprecated = "Use -connection:willSendRequestForAuthenticationChallenge: instead."]
        #[optional]
        #[method(connection:didReceiveAuthenticationChallenge:)]
        unsafe fn connection_didReceiveAuthenticationChallenge(
            &self,
            connection: &NSURLConnection,
            challenge: &NSURLAuthenticationChallenge,
        );

        #[cfg(all(
            feature = "Foundation_NSURLAuthenticationChallenge",
            feature = "Foundation_NSURLConnection"
        ))]
        #[deprecated = "Use -connection:willSendRequestForAuthenticationChallenge: instead."]
        #[optional]
        #[method(connection:didCancelAuthenticationChallenge:)]
        unsafe fn connection_didCancelAuthenticationChallenge(
            &self,
            connection: &NSURLConnection,
            challenge: &NSURLAuthenticationChallenge,
        );
    }

    unsafe impl ProtocolType for dyn NSURLConnectionDelegate {}
);

extern_protocol!(
    /**
     @protocol       NSURLConnectionDataDelegate

    @abstract
    Delegate methods used for loading data to memory.
    These delegate methods are all optional.

    @discussion
    connection:willSendRequest:redirectResponse: is
    called whenever an connection determines that it
    must change URLs in order to continue loading a
    request.  This gives the delegate an opportunity
    inspect and if necessary modify a request.  A
    delegate can cause the request to abort by either
    calling the connections -cancel method, or by
    returning nil from this callback.<p>

    There is one subtle difference which results from
    this choice. If -cancel is called in the delegate
    method, all processing for the connection stops,
    and no further delegate callbacks will be sent. If
    the delegate returns nil, the connection will
    continue to process, and this has special
    relevance in the case where the redirectResponse
    argument is non-nil. In this case, any data that
    is loaded for the connection will be sent to the
    delegate, and the delegate will receive a finished
    or failure delegate callback as appropriate.<p>

    connection:didReceiveResponse: is called when
    enough data has been read to construct an
    NSURLResponse object. In the event of a protocol
    which may return multiple responses (such as HTTP
    multipart/x-mixed-replace) the delegate should be
    prepared to inspect the new response and make
    itself ready for data callbacks as appropriate.<p>

    connection:didReceiveData: is called with a single
    immutable NSData object to the delegate,
    representing the next portion of the data loaded
    from the connection.  This is the only guaranteed
    for the delegate to receive the data from the
    resource load.<p>

    connection:needNewBodyStream: is called when the
    loader must retransmit a requests payload, due to
    connection errors or authentication challenges.
    Delegates should construct a new unopened and
    autoreleased NSInputStream.  If not implemented,
    the loader will be required to spool the bytes to
    be uploaded to disk, a potentially expensive
    operation.  Returning nil will cancel the
    connection.

    connection:didSendBodyData:totalBytesWritten:totalBytesExpectedToWrite:
    is called during an upload operation to provide
    progress feedback.  Note that the values may
    change in unexpected ways if the request needs to
    be retransmitted.<p>

    connection:willCacheResponse: gives the delegate
    an opportunity to inspect and modify the
    NSCachedURLResponse which will be cached by the
    loader if caching is enabled for the original
    NSURLRequest.  Returning nil from this delegate
    will prevent the resource from being cached.  Note
    that the -data method of the cached response may
    return an autoreleased in-memory copy of the true
    data, and should not be used as an alternative to
    receiving and accumulating the data through
    connection:didReceiveData:<p>

    connectionDidFinishLoading: is called when all
    connection processing has completed successfully,
    before the delegate is released by the
    connection.<p>
    */
    pub unsafe trait NSURLConnectionDataDelegate: NSURLConnectionDelegate {
        #[cfg(all(
            feature = "Foundation_NSURLConnection",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other connection:willSendRequest:redirectResponse:)]
        unsafe fn connection_willSendRequest_redirectResponse(
            &self,
            connection: &NSURLConnection,
            request: &NSURLRequest,
            response: Option<&NSURLResponse>,
        ) -> Option<Id<NSURLRequest>>;

        #[cfg(all(
            feature = "Foundation_NSURLConnection",
            feature = "Foundation_NSURLResponse"
        ))]
        #[optional]
        #[method(connection:didReceiveResponse:)]
        unsafe fn connection_didReceiveResponse(
            &self,
            connection: &NSURLConnection,
            response: &NSURLResponse,
        );

        #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSURLConnection"))]
        #[optional]
        #[method(connection:didReceiveData:)]
        unsafe fn connection_didReceiveData(&self, connection: &NSURLConnection, data: &NSData);

        #[cfg(all(
            feature = "Foundation_NSInputStream",
            feature = "Foundation_NSURLConnection",
            feature = "Foundation_NSURLRequest"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other connection:needNewBodyStream:)]
        unsafe fn connection_needNewBodyStream(
            &self,
            connection: &NSURLConnection,
            request: &NSURLRequest,
        ) -> Option<Id<NSInputStream>>;

        #[cfg(feature = "Foundation_NSURLConnection")]
        #[optional]
        #[method(connection:didSendBodyData:totalBytesWritten:totalBytesExpectedToWrite:)]
        unsafe fn connection_didSendBodyData_totalBytesWritten_totalBytesExpectedToWrite(
            &self,
            connection: &NSURLConnection,
            bytes_written: NSInteger,
            total_bytes_written: NSInteger,
            total_bytes_expected_to_write: NSInteger,
        );

        #[cfg(all(
            feature = "Foundation_NSCachedURLResponse",
            feature = "Foundation_NSURLConnection"
        ))]
        #[optional]
        #[method_id(@__retain_semantics Other connection:willCacheResponse:)]
        unsafe fn connection_willCacheResponse(
            &self,
            connection: &NSURLConnection,
            cached_response: &NSCachedURLResponse,
        ) -> Option<Id<NSCachedURLResponse>>;

        #[cfg(feature = "Foundation_NSURLConnection")]
        #[optional]
        #[method(connectionDidFinishLoading:)]
        unsafe fn connectionDidFinishLoading(&self, connection: &NSURLConnection);
    }

    unsafe impl ProtocolType for dyn NSURLConnectionDataDelegate {}
);

extern_protocol!(
    /**
     @protocol       NSURLConnectionDownloadDelegate

    @abstract
    Delegate methods used to perform resource
    downloads directly to a disk file.  All the
    methods are optional with the exception of
    connectionDidFinishDownloading:destinationURL:
    which must be implemented in order to inform the
    delegate of the location of the finished download.
    This delegate and download implementation is
    currently only available on iOS 5.0 or later.

    @discussion
    connection:didWriteData:totalBytesWritten:expectedTotalBytes:
    provides progress information about the state of
    the download, the number of bytes written since
    the last delegate callback, the total number of
    bytes written to disk and the total number of
    bytes that are expected (or 0 if this is unknown.)

    connectionDidResumeDownloading:totalBytesWritten:expectedTotalBytes:
    is called when the connection is able to resume an
    in progress download.  This may happen due to a
    connection or network failure.

    connectionDidFinishDownloading:destinationURL: is
    a terminal event which indicates the completion of
    a download and provides the location of the file.
    The file will be located in the applications cache
    directory and is guaranteed to exist for the
    duration of the delegate callback.  The
    implication is that the delegate should copy or
    move the download to a more persistent location if
    desired.
    */
    pub unsafe trait NSURLConnectionDownloadDelegate: NSURLConnectionDelegate {
        #[cfg(feature = "Foundation_NSURLConnection")]
        #[optional]
        #[method(connection:didWriteData:totalBytesWritten:expectedTotalBytes:)]
        unsafe fn connection_didWriteData_totalBytesWritten_expectedTotalBytes(
            &self,
            connection: &NSURLConnection,
            bytes_written: c_longlong,
            total_bytes_written: c_longlong,
            expected_total_bytes: c_longlong,
        );

        #[cfg(feature = "Foundation_NSURLConnection")]
        #[optional]
        #[method(connectionDidResumeDownloading:totalBytesWritten:expectedTotalBytes:)]
        unsafe fn connectionDidResumeDownloading_totalBytesWritten_expectedTotalBytes(
            &self,
            connection: &NSURLConnection,
            total_bytes_written: c_longlong,
            expected_total_bytes: c_longlong,
        );

        #[cfg(all(feature = "Foundation_NSURL", feature = "Foundation_NSURLConnection"))]
        #[method(connectionDidFinishDownloading:destinationURL:)]
        unsafe fn connectionDidFinishDownloading_destinationURL(
            &self,
            connection: &NSURLConnection,
            destination_url: &NSURL,
        );
    }

    unsafe impl ProtocolType for dyn NSURLConnectionDownloadDelegate {}
);

extern_methods!(
    /**
     @category    NSURLConnection(NSURLConnectionSynchronousLoading)

    @abstract
    The NSURLConnectionSynchronousLoading category on
    NSURLConnection provides the interface to perform
    synchronous loading of URL requests.
    */
    /// NSURLConnectionSynchronousLoading
    #[cfg(feature = "Foundation_NSURLConnection")]
    unsafe impl NSURLConnection {
        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse"
        ))]
        #[deprecated = "Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h"]
        #[method_id(@__retain_semantics Other sendSynchronousRequest:returningResponse:error:_)]
        pub unsafe fn sendSynchronousRequest_returningResponse_error(
            request: &NSURLRequest,
            response: Option<&mut Option<Id<NSURLResponse>>>,
        ) -> Result<Id<NSData>, Id<NSError>>;
    }
);

extern_methods!(
    /**
     @category NSURLConnection(NSURLConnectionQueuedLoading)

    The NSURLConnectionQueuedLoading category on NSURLConnection
    provides the interface to perform asynchronous loading of URL
    requests where the results of the request are delivered to a
    block via an NSOperationQueue.

    Note that there is no guarantee of load ordering implied by this
    method.
    */
    /// NSURLConnectionQueuedLoading
    #[cfg(feature = "Foundation_NSURLConnection")]
    unsafe impl NSURLConnection {
        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSOperationQueue",
            feature = "Foundation_NSURLRequest",
            feature = "Foundation_NSURLResponse"
        ))]
        #[deprecated = "Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h"]
        #[method(sendAsynchronousRequest:queue:completionHandler:)]
        pub unsafe fn sendAsynchronousRequest_queue_completionHandler(
            request: &NSURLRequest,
            queue: &NSOperationQueue,
            handler: &Block<(*mut NSURLResponse, *mut NSData, *mut NSError), ()>,
        );
    }
);
