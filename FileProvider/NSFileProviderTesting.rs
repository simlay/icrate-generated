//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::FileProvider::*;
use crate::Foundation::*;
use crate::UniformTypeIdentifiers::*;

ns_enum!(
    #[underlying(NSInteger)]
    /**
      Type of the operation
    */
    pub enum NSFileProviderTestingOperationType {
        NSFileProviderTestingOperationTypeIngestion = 0,
        NSFileProviderTestingOperationTypeLookup = 1,
        NSFileProviderTestingOperationTypeCreation = 2,
        NSFileProviderTestingOperationTypeModification = 3,
        NSFileProviderTestingOperationTypeDeletion = 4,
        NSFileProviderTestingOperationTypeContentFetch = 5,
        NSFileProviderTestingOperationTypeChildrenEnumeration = 6,
        NSFileProviderTestingOperationTypeCollisionResolution = 7,
    }
);

extern_protocol!(
    /**
      An operation that can scheduled.
    */
    pub unsafe trait NSFileProviderTestingOperation: NSObjectProtocol {
        /**
          The operation type
        */
        #[method(type)]
        unsafe fn r#type(&self) -> NSFileProviderTestingOperationType;

        #[method_id(@__retain_semantics Other asIngestion)]
        unsafe fn asIngestion(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingIngestion>>>;

        #[method_id(@__retain_semantics Other asLookup)]
        unsafe fn asLookup(&self) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingLookup>>>;

        #[method_id(@__retain_semantics Other asCreation)]
        unsafe fn asCreation(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingCreation>>>;

        #[method_id(@__retain_semantics Other asModification)]
        unsafe fn asModification(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingModification>>>;

        #[method_id(@__retain_semantics Other asDeletion)]
        unsafe fn asDeletion(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingDeletion>>>;

        #[method_id(@__retain_semantics Other asContentFetch)]
        unsafe fn asContentFetch(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingContentFetch>>>;

        #[method_id(@__retain_semantics Other asChildrenEnumeration)]
        unsafe fn asChildrenEnumeration(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingChildrenEnumeration>>>;

        #[method_id(@__retain_semantics Other asCollisionResolution)]
        unsafe fn asCollisionResolution(
            &self,
        ) -> Option<Id<ProtocolObject<dyn NSFileProviderTestingCollisionResolution>>>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingOperation {}
);

extern_methods!(
    /**
      Control the scheduling of operation.

    These methods are available on domain with the NSFileProviderDomainTestingModeInteractive
    enabled.

    In order to manually schedule the operation, the testing harness will first call
    -listAvailableTestingOperationWithError and get a list of operations that can be scheduled.
    It can pick one or more operations from that list and call -runTestingOperations:error: to
    schedule those operations.

    From that point, it should get the new list of available operations and iterate between listing,
    picking operation, running those operation and so on.

    A process must have the com.apple.developer.fileprovider.testing-mode entitlement in order to
    call the methods from this category.
    */
    /// TestingModeInteractive
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSError"))]
        #[method_id(@__retain_semantics Other listAvailableTestingOperationsWithError:_)]
        pub unsafe fn listAvailableTestingOperationsWithError(
            &self,
        ) -> Result<Id<NSArray<ProtocolObject<dyn NSFileProviderTestingOperation>>>, Id<NSError>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other runTestingOperations:error:_)]
        pub unsafe fn runTestingOperations_error(
            &self,
            operations: &NSArray<ProtocolObject<dyn NSFileProviderTestingOperation>>,
        ) -> Result<
            Id<NSDictionary<ProtocolObject<dyn NSFileProviderTestingOperation>, NSError>>,
            Id<NSError>,
        >;
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    /**
      Side affected by the operation.
    */
    pub enum NSFileProviderTestingOperationSide {
        NSFileProviderTestingOperationSideDisk = 0,
        NSFileProviderTestingOperationSideFileProvider = 1,
    }
);

extern_protocol!(
    /**
      This operation causes the system to ingest a change.

    When running this operation, the system will discover a change from the disk or the provider.
    */
    pub unsafe trait NSFileProviderTestingIngestion: NSFileProviderTestingOperation {
        /**
          Side of the event.
        */
        #[method(side)]
        unsafe fn side(&self) -> NSFileProviderTestingOperationSide;

        /**
          Identifier of the affected item.
        */
        #[method_id(@__retain_semantics Other itemIdentifier)]
        unsafe fn itemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;

        /**
          The metadata of the item.

        This will be nil if the item is being deleted.
        */
        #[method_id(@__retain_semantics Other item)]
        unsafe fn item(&self) -> Option<Id<NSFileProviderItem>>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingIngestion {}
);

extern_protocol!(
    /**
      This operation causes the system to lookup an item.
    */
    pub unsafe trait NSFileProviderTestingLookup: NSFileProviderTestingOperation {
        /**
          Side of the event.
        */
        #[method(side)]
        unsafe fn side(&self) -> NSFileProviderTestingOperationSide;

        /**
          Identifier of the affected item.
        */
        #[method_id(@__retain_semantics Other itemIdentifier)]
        unsafe fn itemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingLookup {}
);

extern_protocol!(
    /**
      This operation causes the system to propagate a creation of an item from a source side to a target side.
    */
    pub unsafe trait NSFileProviderTestingCreation: NSFileProviderTestingOperation {
        /**
          The target side of the operation.
        */
        #[method(targetSide)]
        unsafe fn targetSide(&self) -> NSFileProviderTestingOperationSide;

        /**
          The description of the item.
        */
        #[method_id(@__retain_semantics Other sourceItem)]
        unsafe fn sourceItem(&self) -> Id<NSFileProviderItem>;

        #[cfg(feature = "FileProvider_NSFileProviderDomainVersion")]
        /**
          The domain version at the time the creation was discovered on the source side.
        */
        #[method_id(@__retain_semantics Other domainVersion)]
        unsafe fn domainVersion(&self) -> Option<Id<NSFileProviderDomainVersion>>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingCreation {}
);

extern_protocol!(
    /**
      This operation causes the system to propagate a modification of an existing item from a source side to a target side.

    The modification happens if a change is identified on an item that is already known by both sides.
    */
    pub unsafe trait NSFileProviderTestingModification:
        NSFileProviderTestingOperation
    {
        /**
          The target side of the operation.
        */
        #[method(targetSide)]
        unsafe fn targetSide(&self) -> NSFileProviderTestingOperationSide;

        /**
          The description of the item.
        */
        #[method_id(@__retain_semantics Other sourceItem)]
        unsafe fn sourceItem(&self) -> Id<NSFileProviderItem>;

        /**
          The identifier of the target item.
        */
        #[method_id(@__retain_semantics Other targetItemIdentifier)]
        unsafe fn targetItemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;

        #[cfg(feature = "FileProvider_NSFileProviderItemVersion")]
        /**
          The version of the target item on top of which the modification is applied
        */
        #[method_id(@__retain_semantics Other targetItemBaseVersion)]
        unsafe fn targetItemBaseVersion(&self) -> Id<NSFileProviderItemVersion>;

        /**
          The list of updated fields.
        */
        #[method(changedFields)]
        unsafe fn changedFields(&self) -> NSFileProviderItemFields;

        #[cfg(feature = "FileProvider_NSFileProviderDomainVersion")]
        /**
          The domain version at the time the change was discovered on the source side.
        */
        #[method_id(@__retain_semantics Other domainVersion)]
        unsafe fn domainVersion(&self) -> Option<Id<NSFileProviderDomainVersion>>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingModification {}
);

extern_protocol!(
    /**
      This operation causes the system to propagate a deletion from a source side to a target side.

    The deletion happens if an item that is known by the target side is deleted on the source side.
    */
    pub unsafe trait NSFileProviderTestingDeletion: NSFileProviderTestingOperation {
        /**
          The target side of the operation.
        */
        #[method(targetSide)]
        unsafe fn targetSide(&self) -> NSFileProviderTestingOperationSide;

        /**
          The identifier of the source item.
        */
        #[method_id(@__retain_semantics Other sourceItemIdentifier)]
        unsafe fn sourceItemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;

        /**
          The identifier of the target item.
        */
        #[method_id(@__retain_semantics Other targetItemIdentifier)]
        unsafe fn targetItemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;

        #[cfg(feature = "FileProvider_NSFileProviderItemVersion")]
        /**
          The version of the target item on top of which the deletion is applied
        */
        #[method_id(@__retain_semantics Other targetItemBaseVersion)]
        unsafe fn targetItemBaseVersion(&self) -> Id<NSFileProviderItemVersion>;

        #[cfg(feature = "FileProvider_NSFileProviderDomainVersion")]
        /**
          The domain version at the time the change was discovered on the source side.
        */
        #[method_id(@__retain_semantics Other domainVersion)]
        unsafe fn domainVersion(&self) -> Option<Id<NSFileProviderDomainVersion>>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingDeletion {}
);

extern_protocol!(
    /**
      This operation causes the system to fetch the content of an item.
    */
    pub unsafe trait NSFileProviderTestingContentFetch:
        NSFileProviderTestingOperation
    {
        /**
          The side of the operation.
        */
        #[method(side)]
        unsafe fn side(&self) -> NSFileProviderTestingOperationSide;

        /**
          The identifier of the item.
        */
        #[method_id(@__retain_semantics Other itemIdentifier)]
        unsafe fn itemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingContentFetch {}
);

extern_protocol!(
    /**
      This operation causes the system to list the children of an item
    */
    pub unsafe trait NSFileProviderTestingChildrenEnumeration:
        NSFileProviderTestingOperation
    {
        /**
          The side of the operation.
        */
        #[method(side)]
        unsafe fn side(&self) -> NSFileProviderTestingOperationSide;

        /**
          The identifier of the item.
        */
        #[method_id(@__retain_semantics Other itemIdentifier)]
        unsafe fn itemIdentifier(&self) -> Id<NSFileProviderItemIdentifier>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingChildrenEnumeration {}
);

extern_protocol!(
    /**
      This operation causes the system to resolve a collision by rename a colliding item.

    In case two items claim the same disk location because the have the same parent and filename,
    the system will choose to rename one of those items away from that location. The renamed item will
    have the same parent, but a slightly modified name (for instance "a.txt" will be renamed to "a 2.txt").

    This can for instance happen if the case sensitivity of the local filesystem and of the provider differs.
    */
    pub unsafe trait NSFileProviderTestingCollisionResolution:
        NSFileProviderTestingOperation
    {
        /**
          The side of the operation.
        */
        #[method(side)]
        unsafe fn side(&self) -> NSFileProviderTestingOperationSide;

        /**
          The state of the item.
        */
        #[method_id(@__retain_semantics Other renamedItem)]
        unsafe fn renamedItem(&self) -> Id<NSFileProviderItem>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderTestingCollisionResolution {}
);
