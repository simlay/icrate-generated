//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::FileProvider::*;
use crate::Foundation::*;
use crate::UniformTypeIdentifiers::*;

ns_enum!(
    #[underlying(NSInteger)]
    pub enum NSFileProviderDomainRemovalMode {
        NSFileProviderDomainRemovalModeRemoveAll = 0,
        NSFileProviderDomainRemovalModePreserveDirtyUserData = 1,
        NSFileProviderDomainRemovalModePreserveDownloadedUserData = 2,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    /**
     The file provider manager allows you to communicate with the file provider
    framework from both the extension and related processes.

    NSFileProviderManager can be used from the following processes:
    - the extension
    - the main app containing the extension
    - sibling extensions to the extension
    - executables contained in the main app bundle (on macOS only)

    Executables contained in the main app bundle need to have a bundle identifier that is
    prefixed by the bundle identifier of the main app (note that this is generally required
    for extensions). They must also have access to the document group defined for the provider
    (via its `NSExtensionFileProviderDocumentGroup` key).

    The file provider framework will invoke your file provider extension in response
    to those calls if appropriate.

    The class also provides methods to manage provider domains. Each domain has a
    corresponding manager.
    */
    pub struct NSFileProviderManager;

    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl ClassType for NSFileProviderManager {
        type Super = NSObject;
    }
);

#[cfg(feature = "FileProvider_NSFileProviderManager")]
/**
 The file provider manager allows you to communicate with the file provider
framework from both the extension and related processes.

NSFileProviderManager can be used from the following processes:
- the extension
- the main app containing the extension
- sibling extensions to the extension
- executables contained in the main app bundle (on macOS only)

Executables contained in the main app bundle need to have a bundle identifier that is
prefixed by the bundle identifier of the main app (note that this is generally required
for extensions). They must also have access to the document group defined for the provider
(via its `NSExtensionFileProviderDocumentGroup` key).

The file provider framework will invoke your file provider extension in response
to those calls if appropriate.

The class also provides methods to manage provider domains. Each domain has a
corresponding manager.
*/
unsafe impl NSObjectProtocol for NSFileProviderManager {}

extern_methods!(
    /**
     The file provider manager allows you to communicate with the file provider
    framework from both the extension and related processes.

    NSFileProviderManager can be used from the following processes:
    - the extension
    - the main app containing the extension
    - sibling extensions to the extension
    - executables contained in the main app bundle (on macOS only)

    Executables contained in the main app bundle need to have a bundle identifier that is
    prefixed by the bundle identifier of the main app (note that this is generally required
    for extensions). They must also have access to the document group defined for the provider
    (via its `NSExtensionFileProviderDocumentGroup` key).

    The file provider framework will invoke your file provider extension in response
    to those calls if appropriate.

    The class also provides methods to manage provider domains. Each domain has a
    corresponding manager.
    */
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        /**
         Return the manager responsible for the default domain.
        */
        #[method_id(@__retain_semantics Other defaultManager)]
        pub unsafe fn defaultManager() -> Id<NSFileProviderManager>;

        #[cfg(feature = "FileProvider_NSFileProviderDomain")]
        #[method_id(@__retain_semantics Other managerForDomain:)]
        pub unsafe fn managerForDomain(domain: &NSFileProviderDomain) -> Option<Id<Self>>;

        #[cfg(feature = "Foundation_NSError")]
        #[method(signalEnumeratorForContainerItemIdentifier:completionHandler:)]
        pub unsafe fn signalEnumeratorForContainerItemIdentifier_completionHandler(
            &self,
            container_item_identifier: &NSFileProviderItemIdentifier,
            completion: &Block<(*mut NSError,), ()>,
        );

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(getUserVisibleURLForItemIdentifier:completionHandler:)]
        pub unsafe fn getUserVisibleURLForItemIdentifier_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            completion_handler: &Block<(*mut NSURL, *mut NSError), ()>,
        );

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(getIdentifierForUserVisibleFileAtURL:completionHandler:)]
        pub unsafe fn getIdentifierForUserVisibleFileAtURL_completionHandler(
            url: &NSURL,
            completion_handler: &Block<
                (
                    *mut NSFileProviderItemIdentifier,
                    *mut NSFileProviderDomainIdentifier,
                    *mut NSError,
                ),
                (),
            >,
        );

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "Foundation_NSURLSessionTask"
        ))]
        #[method(registerURLSessionTask:forItemWithIdentifier:completionHandler:)]
        pub unsafe fn registerURLSessionTask_forItemWithIdentifier_completionHandler(
            &self,
            task: &NSURLSessionTask,
            identifier: &NSFileProviderItemIdentifier,
            completion: &Block<(*mut NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
         The purpose identifier of your file provider extension. A coordination using a
        file coordinator with this purpose identifier set will not trigger your file
        provider extension. You can use this to e.g. perform speculative work on behalf
        of the file provider from the main app.
        */
        #[method_id(@__retain_semantics Other providerIdentifier)]
        pub unsafe fn providerIdentifier(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSURL")]
        /**
         The root URL for provided documents. This URL is derived by consulting the
        NSExtensionFileProviderDocumentGroup property on your extension. The document
        storage URL is the folder "File Provider Storage" in the corresponding
        container.

        If the NSExtensionFileProviderDocumentGroup property is not set, calling this
        method will result in an error.
        */
        #[method_id(@__retain_semantics Other documentStorageURL)]
        pub unsafe fn documentStorageURL(&self) -> Id<NSURL>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method_id(@__retain_semantics Other temporaryDirectoryURLWithError:_)]
        pub unsafe fn temporaryDirectoryURLWithError(&self) -> Result<Id<NSURL>, Id<NSError>>;

        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSURL"))]
        #[method(writePlaceholderAtURL:withMetadata:error:_)]
        pub unsafe fn writePlaceholderAtURL_withMetadata_error(
            placeholder_url: &NSURL,
            metadata: &NSFileProviderItem,
        ) -> Result<(), Id<NSError>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other placeholderURLForURL:)]
        pub unsafe fn placeholderURLForURL(url: &NSURL) -> Id<NSURL>;

        #[cfg(all(
            feature = "FileProvider_NSFileProviderDomain",
            feature = "Foundation_NSError"
        ))]
        #[method(addDomain:completionHandler:)]
        pub unsafe fn addDomain_completionHandler(
            domain: &NSFileProviderDomain,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(all(
            feature = "FileProvider_NSFileProviderDomain",
            feature = "Foundation_NSError"
        ))]
        #[method(removeDomain:completionHandler:)]
        pub unsafe fn removeDomain_completionHandler(
            domain: &NSFileProviderDomain,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(all(
            feature = "FileProvider_NSFileProviderDomain",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(removeDomain:mode:completionHandler:)]
        pub unsafe fn removeDomain_mode_completionHandler(
            domain: &NSFileProviderDomain,
            mode: NSFileProviderDomainRemovalMode,
            completion_handler: &Block<(*mut NSURL, *mut NSError), ()>,
        );

        #[cfg(all(
            feature = "FileProvider_NSFileProviderDomain",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError"
        ))]
        #[method(getDomainsWithCompletionHandler:)]
        pub unsafe fn getDomainsWithCompletionHandler(
            completion_handler: &Block<(NonNull<NSArray<NSFileProviderDomain>>, *mut NSError), ()>,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method(removeAllDomainsWithCompletionHandler:)]
        pub unsafe fn removeAllDomainsWithCompletionHandler(
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method(signalErrorResolved:completionHandler:)]
        pub unsafe fn signalErrorResolved_completionHandler(
            &self,
            error: &NSError,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSProgress")]
        #[method_id(@__retain_semantics Other globalProgressForKind:)]
        pub unsafe fn globalProgressForKind(
            &self,
            kind: &NSProgressFileOperationKind,
        ) -> Id<NSProgress>;
    }
);

extern_static!(NSFileProviderMaterializedSetDidChange: &'static NSNotificationName);

extern_methods!(
    /// MaterializedSet
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[method_id(@__retain_semantics Other enumeratorForMaterializedItems)]
        pub unsafe fn enumeratorForMaterializedItems(
            &self,
        ) -> Id<ProtocolObject<dyn NSFileProviderEnumerator>>;
    }
);

extern_static!(NSFileProviderPendingSetDidChange: &'static NSNotificationName);

extern_protocol!(
    pub unsafe trait NSFileProviderPendingSetEnumerator: NSFileProviderEnumerator {
        #[cfg(feature = "FileProvider_NSFileProviderDomainVersion")]
        /**
         The version of the domain when the pending set was last refreshed by the system.

        This property is updated when the enumeration methods are called on the pending set enumerator. The value
        is initially nil.
        */
        #[method_id(@__retain_semantics Other domainVersion)]
        unsafe fn domainVersion(&self) -> Option<Id<NSFileProviderDomainVersion>>;

        /**
         The amount of time in seconds at which the pending set is refreshed on modifications.
        */
        #[method(refreshInterval)]
        unsafe fn refreshInterval(&self) -> NSTimeInterval;

        /**
         This property is set to YES when the enumeration of the pending set was capped at or below its maximum size.
        Under normal conditions, the count of items pending sync will get lower as sync progresses, and this variable
        will eventually be set to NO when the pending set again includes all items pending sync.
        */
        #[method(isMaximumSizeReached)]
        unsafe fn isMaximumSizeReached(&self) -> bool;
    }

    unsafe impl ProtocolType for dyn NSFileProviderPendingSetEnumerator {}
);

extern_methods!(
    /// PendingSet
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[method_id(@__retain_semantics Other enumeratorForPendingItems)]
        pub unsafe fn enumeratorForPendingItems(
            &self,
        ) -> Id<ProtocolObject<dyn NSFileProviderPendingSetEnumerator>>;
    }
);

extern_methods!(
    /// Import
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(all(
            feature = "FileProvider_NSFileProviderDomain",
            feature = "Foundation_NSError",
            feature = "Foundation_NSURL"
        ))]
        #[method(importDomain:fromDirectoryAtURL:completionHandler:)]
        pub unsafe fn importDomain_fromDirectoryAtURL_completionHandler(
            domain: &NSFileProviderDomain,
            url: &NSURL,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method(reimportItemsBelowItemWithIdentifier:completionHandler:)]
        pub unsafe fn reimportItemsBelowItemWithIdentifier_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method(requestModificationOfFields:forItemWithIdentifier:options:completionHandler:)]
        pub unsafe fn requestModificationOfFields_forItemWithIdentifier_options_completionHandler(
            &self,
            fields: NSFileProviderItemFields,
            item_identifier: &NSFileProviderItemIdentifier,
            options: NSFileProviderModifyItemOptions,
            completion_handler: &Block<(*mut NSError,), ()>,
        );
    }
);

extern_methods!(
    /// Eviction
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(feature = "Foundation_NSError")]
        #[method(evictItemWithIdentifier:completionHandler:)]
        pub unsafe fn evictItemWithIdentifier_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            completion_handler: &Block<(*mut NSError,), ()>,
        );
    }
);

extern_methods!(
    /// Barrier
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(feature = "Foundation_NSError")]
        #[method(waitForChangesOnItemsBelowItemWithIdentifier:completionHandler:)]
        pub unsafe fn waitForChangesOnItemsBelowItemWithIdentifier_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            completion_handler: &Block<(*mut NSError,), ()>,
        );
    }
);

extern_methods!(
    /// Stabilization
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(feature = "Foundation_NSError")]
        #[method(waitForStabilizationWithCompletionHandler:)]
        pub unsafe fn waitForStabilizationWithCompletionHandler(
            &self,
            completion_handler: &Block<(*mut NSError,), ()>,
        );
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    pub enum NSFileProviderManagerDisconnectionOptions {
        NSFileProviderManagerDisconnectionOptionsTemporary = 1 << 0,
    }
);

extern_methods!(
    /// Disconnection
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(all(feature = "Foundation_NSError", feature = "Foundation_NSString"))]
        #[method(disconnectWithReason:options:completionHandler:)]
        pub unsafe fn disconnectWithReason_options_completionHandler(
            &self,
            localized_reason: &NSString,
            options: NSFileProviderManagerDisconnectionOptions,
            completion_handler: &Block<(*mut NSError,), ()>,
        );

        #[cfg(feature = "Foundation_NSError")]
        #[method(reconnectWithCompletionHandler:)]
        pub unsafe fn reconnectWithCompletionHandler(
            &self,
            completion_handler: &Block<(*mut NSError,), ()>,
        );
    }
);

extern_methods!(
    /// Materialize
    #[cfg(feature = "FileProvider_NSFileProviderManager")]
    unsafe impl NSFileProviderManager {
        #[cfg(feature = "Foundation_NSError")]
        #[method(requestDownloadForItemWithIdentifier:requestedRange:completionHandler:)]
        pub unsafe fn requestDownloadForItemWithIdentifier_requestedRange_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            range_to_materialize: NSRange,
            completion_handler: &Block<(*mut NSError,), ()>,
        );
    }
);
