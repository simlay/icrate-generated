//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::FileProvider::*;
use crate::Foundation::*;
use crate::UniformTypeIdentifiers::*;

ns_options!(
    #[underlying(NSUInteger)]
    /**
     Options passed on item creation.
    */
    pub enum NSFileProviderCreateItemOptions {
        NSFileProviderCreateItemMayAlreadyExist = 1 << 0,
        NSFileProviderCreateItemDeletionConflicted = 1 << 1,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
     Options passed on item deletion.
    */
    pub enum NSFileProviderDeleteItemOptions {
        NSFileProviderDeleteItemRecursive = 1 << 0,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
     NSFileProviderMaterializationFlags are used to inform the system about specific conditions
    that apply to the content retrieved by the provider in fetchPartialContentsForItemWithIdentifier.

    */
    pub enum NSFileProviderMaterializationFlags {
        NSFileProviderMaterializationFlagsKnownSparseRanges = 1 << 0,
    }
);

ns_options!(
    #[underlying(NSUInteger)]
    /**
     Used by the system to express options and constraints to the provider in fetchPartialContentsForItemWithIdentifier.
    */
    pub enum NSFileProviderFetchContentsOptions {
        NSFileProviderFetchContentsOptionsStrictVersioning = 1 << 0,
    }
);

extern_protocol!(
    pub unsafe trait NSFileProviderEnumerating: NSObjectProtocol {
        #[cfg(all(
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other enumeratorForContainerItemIdentifier:request:error:_)]
        unsafe fn enumeratorForContainerItemIdentifier_request_error(
            &self,
            container_item_identifier: &NSFileProviderItemIdentifier,
            request: &NSFileProviderRequest,
        ) -> Result<Id<ProtocolObject<dyn NSFileProviderEnumerator>>, Id<NSError>>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderEnumerating {}
);

extern_protocol!(
    /**
     FileProvider extension for which the system replicates the content on disk.

    The extension exposes a hierarchy of NSFileProviderItem instances that the system
    will replicate on disk as a file hierarchy. The file hierarchy reflects the filename,
    parent, content, and metadata described by the NSFileProviderItem. In case two items
    are at the same disk location (same parent and filename), the system may choose to
    "bounce" an item.

    The system lazily replicates the item hierarchy: items are created "dataless" on disk
    and the content (for files) or list of children (for folders) is fetched on first
    access by calling fetchContentsForItemWithIdentifier, or enumeratorForContainerItemIdentifier.

    The provider can notify the system of changes on the items by publishing those on the
    enumerator for the working set. The system notifies the extension of changes made by the
    user on disk by calling createItemBasedOnTemplate, modifyItem, or deleteItemWithIdentifier.

    Concurrency:
    ------------
    A replicated extension class must be prepared to handle multiple concurrent calls since the
    system may perform several concurrent operations (for instance, modifying an item, while enumerating
    the working set, creating another item, and fetching the contents of yet another item).

    The system has limits to the number of concurrent operations.When the number of concurrent
    operations is reached, the system will not schedule additional operations falling in that category
    until at least one of the running operation has completed by calling its completion handler.

    The system currently separates the operations into the following categories:
    - enumeration of the working set. At most 1 enumeration of the working set can happen at a given time
    - downloads. The system has a per-domain limit on the number of concurrent calls to fetchContents and similar calls.
    That limit is configurable by setting the NSExtensionFileProviderDownloadPipelineDepth key to an integer
    value (between 1 and 128) in the Info.plist of the extension.
    - uploads. The system has a per-domain limit on the number of concurrent calls to createItemBasedOnTemplate and
    modifyItem when the call includes new content to be uploaded. That limit is configurable by setting the
    NSExtensionFileProviderUploadPipelineDepth key to an integer value (between 1 and 128) in the Info.plist
    of the extension.
    */
    pub unsafe trait NSFileProviderReplicatedExtension:
        NSFileProviderEnumerating + NSObjectProtocol
    {
        #[cfg(feature = "FileProvider_NSFileProviderDomain")]
        #[method_id(@__retain_semantics Init initWithDomain:)]
        unsafe fn initWithDomain(
            this: Option<Allocated<Self>>,
            domain: &NSFileProviderDomain,
        ) -> Id<Self>;

        #[method(invalidate)]
        unsafe fn invalidate(&self);

        #[cfg(all(
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress"
        ))]
        #[method_id(@__retain_semantics Other itemForIdentifier:request:completionHandler:)]
        unsafe fn itemForIdentifier_request_completionHandler(
            &self,
            identifier: &NSFileProviderItemIdentifier,
            request: &NSFileProviderRequest,
            completion_handler: &Block<(*mut NSFileProviderItem, *mut NSError), ()>,
        ) -> Id<NSProgress>;

        #[cfg(all(
            feature = "FileProvider_NSFileProviderItemVersion",
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other fetchContentsForItemWithIdentifier:version:request:completionHandler:)]
        unsafe fn fetchContentsForItemWithIdentifier_version_request_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            requested_version: Option<&NSFileProviderItemVersion>,
            request: &NSFileProviderRequest,
            completion_handler: &Block<(*mut NSURL, *mut NSFileProviderItem, *mut NSError), ()>,
        ) -> Id<NSProgress>;

        #[cfg(all(
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other createItemBasedOnTemplate:fields:contents:options:request:completionHandler:)]
        unsafe fn createItemBasedOnTemplate_fields_contents_options_request_completionHandler(
            &self,
            item_template: &NSFileProviderItem,
            fields: NSFileProviderItemFields,
            url: Option<&NSURL>,
            options: NSFileProviderCreateItemOptions,
            request: &NSFileProviderRequest,
            completion_handler: &Block<
                (
                    *mut NSFileProviderItem,
                    NSFileProviderItemFields,
                    Bool,
                    *mut NSError,
                ),
                (),
            >,
        ) -> Id<NSProgress>;

        #[cfg(all(
            feature = "FileProvider_NSFileProviderItemVersion",
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other modifyItem:baseVersion:changedFields:contents:options:request:completionHandler:)]
        unsafe fn modifyItem_baseVersion_changedFields_contents_options_request_completionHandler(
            &self,
            item: &NSFileProviderItem,
            version: &NSFileProviderItemVersion,
            changed_fields: NSFileProviderItemFields,
            new_contents: Option<&NSURL>,
            options: NSFileProviderModifyItemOptions,
            request: &NSFileProviderRequest,
            completion_handler: &Block<
                (
                    *mut NSFileProviderItem,
                    NSFileProviderItemFields,
                    Bool,
                    *mut NSError,
                ),
                (),
            >,
        ) -> Id<NSProgress>;

        #[cfg(all(
            feature = "FileProvider_NSFileProviderItemVersion",
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress"
        ))]
        #[method_id(@__retain_semantics Other deleteItemWithIdentifier:baseVersion:options:request:completionHandler:)]
        unsafe fn deleteItemWithIdentifier_baseVersion_options_request_completionHandler(
            &self,
            identifier: &NSFileProviderItemIdentifier,
            version: &NSFileProviderItemVersion,
            options: NSFileProviderDeleteItemOptions,
            request: &NSFileProviderRequest,
            completion_handler: &Block<(*mut NSError,), ()>,
        ) -> Id<NSProgress>;

        #[optional]
        #[method(importDidFinishWithCompletionHandler:)]
        unsafe fn importDidFinishWithCompletionHandler(&self, completion_handler: &Block<(), ()>);

        #[optional]
        #[method(materializedItemsDidChangeWithCompletionHandler:)]
        unsafe fn materializedItemsDidChangeWithCompletionHandler(
            &self,
            completion_handler: &Block<(), ()>,
        );

        #[optional]
        #[method(pendingItemsDidChangeWithCompletionHandler:)]
        unsafe fn pendingItemsDidChangeWithCompletionHandler(
            &self,
            completion_handler: &Block<(), ()>,
        );
    }

    unsafe impl ProtocolType for dyn NSFileProviderReplicatedExtension {}
);

extern_protocol!(
    /**
     Protocol to implement if the provider instance supports fetching incremental content changes.
    */
    pub unsafe trait NSFileProviderIncrementalContentFetching: NSObjectProtocol {
        #[cfg(all(
            feature = "FileProvider_NSFileProviderItemVersion",
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other fetchContentsForItemWithIdentifier:version:usingExistingContentsAtURL:existingVersion:request:completionHandler:)]
        unsafe fn fetchContentsForItemWithIdentifier_version_usingExistingContentsAtURL_existingVersion_request_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            requested_version: Option<&NSFileProviderItemVersion>,
            existing_contents: &NSURL,
            existing_version: &NSFileProviderItemVersion,
            request: &NSFileProviderRequest,
            completion_handler: &Block<(*mut NSURL, *mut NSFileProviderItem, *mut NSError), ()>,
        ) -> Id<NSProgress>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderIncrementalContentFetching {}
);

extern_protocol!(
    pub unsafe trait NSFileProviderServicing: NSObjectProtocol {
        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress"
        ))]
        #[method_id(@__retain_semantics Other supportedServiceSourcesForItemIdentifier:completionHandler:)]
        unsafe fn supportedServiceSourcesForItemIdentifier_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            completion_handler: &Block<
                (
                    *mut NSArray<ProtocolObject<dyn NSFileProviderServiceSource>>,
                    *mut NSError,
                ),
                (),
            >,
        ) -> Id<NSProgress>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderServicing {}
);

extern_protocol!(
    /**
     Protocol to implement if the provider supports fetching thumbnails for its items.
    */
    pub unsafe trait NSFileProviderThumbnailing: NSObjectProtocol {
        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSData",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress"
        ))]
        #[method_id(@__retain_semantics Other fetchThumbnailsForItemIdentifiers:requestedSize:perThumbnailCompletionHandler:completionHandler:)]
        unsafe fn fetchThumbnailsForItemIdentifiers_requestedSize_perThumbnailCompletionHandler_completionHandler(
            &self,
            item_identifiers: &NSArray<NSFileProviderItemIdentifier>,
            size: CGSize,
            per_thumbnail_completion_handler: &Block<
                (
                    NonNull<NSFileProviderItemIdentifier>,
                    *mut NSData,
                    *mut NSError,
                ),
                (),
            >,
            completion_handler: &Block<(*mut NSError,), ()>,
        ) -> Id<NSProgress>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderThumbnailing {}
);

extern_protocol!(
    pub unsafe trait NSFileProviderCustomAction: NSObjectProtocol {
        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress"
        ))]
        #[method_id(@__retain_semantics Other performActionWithIdentifier:onItemsWithIdentifiers:completionHandler:)]
        unsafe fn performActionWithIdentifier_onItemsWithIdentifiers_completionHandler(
            &self,
            action_identifier: &NSFileProviderExtensionActionIdentifier,
            item_identifiers: &NSArray<NSFileProviderItemIdentifier>,
            completion_handler: &Block<(*mut NSError,), ()>,
        ) -> Id<NSProgress>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderCustomAction {}
);

extern_protocol!(
    /**
     Protocol to implement for managing UserInteraction alerts.
    */
    pub unsafe trait NSFileProviderUserInteractionSuppressing: NSObjectProtocol {
        #[cfg(feature = "Foundation_NSString")]
        #[method(setInteractionSuppressed:forIdentifier:)]
        unsafe fn setInteractionSuppressed_forIdentifier(
            &self,
            suppression: bool,
            suppression_identifier: &NSString,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method(isInteractionSuppressedForIdentifier:)]
        unsafe fn isInteractionSuppressedForIdentifier(
            &self,
            suppression_identifier: &NSString,
        ) -> bool;
    }

    unsafe impl ProtocolType for dyn NSFileProviderUserInteractionSuppressing {}
);

extern_protocol!(
    pub unsafe trait NSFileProviderDomainState: NSObjectProtocol {
        #[cfg(feature = "FileProvider_NSFileProviderDomainVersion")]
        /**
         Version of the domain.

        The domain version is an opaque value assigned by the provider. It is read by the system in the
        completion handler for createItemBasedOnTemplate, modifyItem, deleteItem and itemForIdentifier, as
        well as in the finish calls when enumerating the working set. The read is guaranteed to happen
        on the same dispatch queue the completion handler was called on.

        When the system discovers a change on disk, it associates that change to the currently known
        domain version. When that change get communicated to the extension, that version is included in
        the NSFileProviderRequest object passed by the system to the extension. As a consequence, the
        provider can use the domain version to identify the state of the system when a change was made on disk.

        The provider is responsible for defining when the domain version changes. When that value is
        updated, the provider must notify the system by signaling the working set.

        The system ignore any domain version that is smaller than the previously known version.
        */
        #[method_id(@__retain_semantics Other domainVersion)]
        unsafe fn domainVersion(&self) -> Id<NSFileProviderDomainVersion>;

        #[cfg(feature = "Foundation_NSDictionary")]
        /**
         Global state of the domain.

        Use this dictionary to add state information to the domain. It is accessible to predicates for
        User Interactions, FileProvider Actions, and FileProviderUI Actions, via the top-level `domainUserInfo` context
        key.

        This dictionary must only contain key and value classes in the following list:
        NSString, NSNumber, NSDate, and NSPersonNameComponents.

        The system expects the domainVersion to be updated when the value of the userInfo property
        changes.
        */
        #[method_id(@__retain_semantics Other userInfo)]
        unsafe fn userInfo(&self) -> Id<NSDictionary>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderDomainState {}
);

extern_protocol!(
    pub unsafe trait NSFileProviderPartialContentFetching: NSObjectProtocol {
        #[cfg(all(
            feature = "FileProvider_NSFileProviderItemVersion",
            feature = "FileProvider_NSFileProviderRequest",
            feature = "Foundation_NSError",
            feature = "Foundation_NSProgress",
            feature = "Foundation_NSURL"
        ))]
        #[method_id(@__retain_semantics Other fetchPartialContentsForItemWithIdentifier:version:request:minimalRange:aligningTo:options:completionHandler:)]
        unsafe fn fetchPartialContentsForItemWithIdentifier_version_request_minimalRange_aligningTo_options_completionHandler(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
            requested_version: &NSFileProviderItemVersion,
            request: &NSFileProviderRequest,
            requested_range: NSRange,
            alignment: NSUInteger,
            options: NSFileProviderFetchContentsOptions,
            completion_handler: &Block<
                (
                    *mut NSURL,
                    *mut NSFileProviderItem,
                    NSRange,
                    NSFileProviderMaterializationFlags,
                    *mut NSError,
                ),
                (),
            >,
        ) -> Id<NSProgress>;
    }

    unsafe impl ProtocolType for dyn NSFileProviderPartialContentFetching {}
);
