//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::Foundation::*;
use crate::GameController::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "GameController_GCEventViewController")]
    pub struct GCEventViewController;

    #[cfg(feature = "GameController_GCEventViewController")]
    unsafe impl ClassType for GCEventViewController {
        #[inherits(NSResponder, NSObject)]
        type Super = NSViewController;
    }
);

#[cfg(feature = "GameController_GCEventViewController")]
unsafe impl NSCoding for GCEventViewController {}

#[cfg(feature = "GameController_GCEventViewController")]
unsafe impl NSEditor for GCEventViewController {}

#[cfg(feature = "GameController_GCEventViewController")]
unsafe impl NSObjectProtocol for GCEventViewController {}

#[cfg(feature = "GameController_GCEventViewController")]
unsafe impl NSSeguePerforming for GCEventViewController {}

#[cfg(feature = "GameController_GCEventViewController")]
unsafe impl NSUserInterfaceItemIdentification for GCEventViewController {}

extern_methods!(
    #[cfg(feature = "GameController_GCEventViewController")]
    unsafe impl GCEventViewController {
        /**
         Controllers can be used to control the general UIKit user interface and for many views that is
        the default behavior. By using a controller event view controller you get fine grained control
        over whether the controller events go trough the UIEvent & UIResponder chain, or if they are
        decoupled from the UI and all incoming data is served via GCController.

        Defaults to NO - suppressing UIEvents from game controllers and presenting them via the GCController
        API whilst this controller's view or any of it's subviews are the first responders. If you are not
        using any UIView components or UIEvents in your application you should leave this as NO and process
        your game controller events via the normal GCController API.

        If set to YES the controller input will start flowing through UIEvent and the UIResponder
        chain will be used. This gives you fine grained control over the event handling of the
        controlled view and its subviews. You should stop using GCController instances and the corresponding
        profiles if you no longer need to read input from them.

        Note that unlike UIView.userInteractionEnabled this only controls the flow of game controller events.

        @see GCController
        @see UIView.userInteractionEnabled
        */
        #[method(controllerUserInteractionEnabled)]
        pub unsafe fn controllerUserInteractionEnabled(&self) -> bool;

        /**
         Controllers can be used to control the general UIKit user interface and for many views that is
        the default behavior. By using a controller event view controller you get fine grained control
        over whether the controller events go trough the UIEvent & UIResponder chain, or if they are
        decoupled from the UI and all incoming data is served via GCController.

        Defaults to NO - suppressing UIEvents from game controllers and presenting them via the GCController
        API whilst this controller's view or any of it's subviews are the first responders. If you are not
        using any UIView components or UIEvents in your application you should leave this as NO and process
        your game controller events via the normal GCController API.

        If set to YES the controller input will start flowing through UIEvent and the UIResponder
        chain will be used. This gives you fine grained control over the event handling of the
        controlled view and its subviews. You should stop using GCController instances and the corresponding
        profiles if you no longer need to read input from them.

        Note that unlike UIView.userInteractionEnabled this only controls the flow of game controller events.

        @see GCController
        @see UIView.userInteractionEnabled
        */
        #[method(setControllerUserInteractionEnabled:)]
        pub unsafe fn setControllerUserInteractionEnabled(
            &self,
            controller_user_interaction_enabled: bool,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `NSViewController`
    #[cfg(feature = "GameController_GCEventViewController")]
    unsafe impl GCEventViewController {
        #[cfg(feature = "Foundation_NSBundle")]
        #[method_id(@__retain_semantics Init initWithNibName:bundle:)]
        pub unsafe fn initWithNibName_bundle(
            this: Option<Allocated<Self>>,
            nib_name_or_nil: Option<&NSNibName>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Id<Self>;
    }
);
