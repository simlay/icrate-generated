//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::Foundation::*;
use crate::GameController::*;

extern_static!(GCInputMicroGamepadDpad: &'static NSString);

extern_static!(GCInputMicroGamepadButtonA: &'static NSString);

extern_static!(GCInputMicroGamepadButtonX: &'static NSString);

extern_static!(GCInputMicroGamepadButtonMenu: &'static NSString);

pub type GCMicroGamepadValueChangedHandler =
    *mut Block<(NonNull<GCMicroGamepad>, NonNull<GCControllerElement>), ()>;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "GameController_GCMicroGamepad")]
    pub struct GCMicroGamepad;

    #[cfg(feature = "GameController_GCMicroGamepad")]
    unsafe impl ClassType for GCMicroGamepad {
        #[inherits(NSObject)]
        type Super = GCPhysicalInputProfile;
    }
);

#[cfg(feature = "GameController_GCMicroGamepad")]
unsafe impl NSObjectProtocol for GCMicroGamepad {}

extern_methods!(
    #[cfg(feature = "GameController_GCMicroGamepad")]
    unsafe impl GCMicroGamepad {
        #[cfg(feature = "GameController_GCController")]
        #[method_id(@__retain_semantics Other controller)]
        pub unsafe fn controller(&self) -> Option<Id<GCController>>;

        #[method(valueChangedHandler)]
        pub unsafe fn valueChangedHandler(&self) -> GCMicroGamepadValueChangedHandler;

        #[method(setValueChangedHandler:)]
        pub unsafe fn setValueChangedHandler(
            &self,
            value_changed_handler: GCMicroGamepadValueChangedHandler,
        );

        #[cfg(feature = "GameController_GCMicroGamepadSnapshot")]
        #[deprecated = "GCMicroGamepadSnapshot has been deprecated, use [GCController capture] instead"]
        #[method_id(@__retain_semantics Other saveSnapshot)]
        pub unsafe fn saveSnapshot(&self) -> Id<GCMicroGamepadSnapshot>;

        #[cfg(feature = "GameController_GCControllerDirectionPad")]
        /**
         Optionally analog in the Micro profile. All the elements of this directional input are either analog or digital.
        */
        #[method_id(@__retain_semantics Other dpad)]
        pub unsafe fn dpad(&self) -> Id<GCControllerDirectionPad>;

        #[cfg(feature = "GameController_GCControllerButtonInput")]
        /**
         The Micro profile has two buttons that are optionally analog in the Micro profile.
        Button A is the primary action button, it indicates affirmative action and should be used to advance in menus
        or perform the primary action in gameplay.
        */
        #[method_id(@__retain_semantics Other buttonA)]
        pub unsafe fn buttonA(&self) -> Id<GCControllerButtonInput>;

        #[cfg(feature = "GameController_GCControllerButtonInput")]
        /**
         Button X is the secondary action button, it indicates an alternate affirmative action and should be used to perform
        a secondary action. If there is no secondary action it should be used as equivalent to buttonA.

        Unlike on other profiles there is no negative button on this profile. Instead the menu button should be
        used to present menu content or to retreat in a menu flow.
        @see buttonA
        */
        #[method_id(@__retain_semantics Other buttonX)]
        pub unsafe fn buttonX(&self) -> Id<GCControllerButtonInput>;

        #[cfg(feature = "GameController_GCControllerButtonInput")]
        /**
         Button menu is the primary menu button, and should be used to enter the main menu and pause the game.
        */
        #[method_id(@__retain_semantics Other buttonMenu)]
        pub unsafe fn buttonMenu(&self) -> Id<GCControllerButtonInput>;

        /**
         The Micro profile can use the raw position values of the touchpad on the remote as D-pad values, or it can create a virtual dpad centered around the first contact point with the surface.

        If NO; a smaller sliding window is created around the initial touch point and subsequent movement is relative to that center. Movement outside the window will slide the window with it to re-center it. This is great for surfaces where there is no clear sense of a middle and drift over time is an issue.

        If YES; the absolute values are used and any drift will have to managed manually either through user traning or by a developer using the dpad.

        The default value for this property is NO, meaning a sliding window is used for the dpad.
        */
        #[method(reportsAbsoluteDpadValues)]
        pub unsafe fn reportsAbsoluteDpadValues(&self) -> bool;

        /**
         The Micro profile can use the raw position values of the touchpad on the remote as D-pad values, or it can create a virtual dpad centered around the first contact point with the surface.

        If NO; a smaller sliding window is created around the initial touch point and subsequent movement is relative to that center. Movement outside the window will slide the window with it to re-center it. This is great for surfaces where there is no clear sense of a middle and drift over time is an issue.

        If YES; the absolute values are used and any drift will have to managed manually either through user traning or by a developer using the dpad.

        The default value for this property is NO, meaning a sliding window is used for the dpad.
        */
        #[method(setReportsAbsoluteDpadValues:)]
        pub unsafe fn setReportsAbsoluteDpadValues(&self, reports_absolute_dpad_values: bool);

        /**
         Allows the Micro profile to monitor the orientation of the controller, if the controller is positioned in landscape orientation, D-pad input values will be transposed 90 degrees to match the new orientation.

        The default value for this property is NO.
        */
        #[method(allowsRotation)]
        pub unsafe fn allowsRotation(&self) -> bool;

        /**
         Allows the Micro profile to monitor the orientation of the controller, if the controller is positioned in landscape orientation, D-pad input values will be transposed 90 degrees to match the new orientation.

        The default value for this property is NO.
        */
        #[method(setAllowsRotation:)]
        pub unsafe fn setAllowsRotation(&self, allows_rotation: bool);

        #[method(setStateFromMicroGamepad:)]
        pub unsafe fn setStateFromMicroGamepad(&self, micro_gamepad: &GCMicroGamepad);
    }
);
