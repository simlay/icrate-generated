//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::Foundation::*;
use crate::GameController::*;

extern_protocol!(
    /**
     An object conforming to \c GCLinearInput represents an input that produces
    normalized values in the unit interval - between [0, 1].
    */
    pub unsafe trait GCLinearInput: NSObjectProtocol {
        /**
         Set this block to be notified when the value of the input changes.

        @param element the element that has been modified.
        @param input the input that has been modified.
        @param value the value the axis was set to at the time the valueDidChangeHandler fired.
        */
        #[method(valueDidChangeHandler)]
        unsafe fn valueDidChangeHandler(
            &self,
        ) -> *mut Block<
            (
                NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                NonNull<ProtocolObject<dyn GCLinearInput>>,
                c_float,
            ),
            (),
        >;

        /**
         Set this block to be notified when the value of the input changes.

        @param element the element that has been modified.
        @param input the input that has been modified.
        @param value the value the axis was set to at the time the valueDidChangeHandler fired.
        */
        #[method(setValueDidChangeHandler:)]
        unsafe fn setValueDidChangeHandler(
            &self,
            value_did_change_handler: Option<
                &Block<
                    (
                        NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                        NonNull<ProtocolObject<dyn GCLinearInput>>,
                        c_float,
                    ),
                    (),
                >,
            >,
        );

        /**
         A normalized value for the axis input, between 0 and 1 (inclusive). The values
        are deadzoned and saturated before they are returned so there is no value
        outside the range.  Deadzoning does not remove values from the range, the full
        0 to 1 magnitude of values are possible from the input.

        You can rely on a value of 0 meaning the value is inside the deadzone.  Any
        value greater than zero is not in the deadzone.
        */
        #[method(value)]
        unsafe fn value(&self) -> c_float;

        /**
         Check if the input can support more than just digital values.

        If \c YES, the input can produce any value between [0, 1].  Otherwise, the
        input only produces the values 0 or 1.
        */
        #[method(isAnalog)]
        unsafe fn isAnalog(&self) -> bool;

        /**
         Check if the input value "rolls over" when reaching either the extreme high
        or low value.  For example, some dials can be rotated past the position that
        represents their maximum value, causing the next reported value to roll over.

        Defaults to NO for most inputs.
        */
        #[method(canWrap)]
        unsafe fn canWrap(&self) -> bool;

        /**
         The timestamp of the last value.

        This time interval is not relative to any specific point in time.  You can
        subtract a previous timestamp from the current timestamp to determine the time
        (in seconds) between changes to the value.
        */
        #[method(lastValueTimestamp)]
        unsafe fn lastValueTimestamp(&self) -> NSTimeInterval;

        /**
         The interval (in seconds) between the timestamp of the last event and the
        current time.

        This should be treated as a lower bound of the event latency.  It may not
        include (wired or wireless) transmission latency, or latency accrued on
        the device before the event was transmitted to the host.
        */
        #[method(lastValueLatency)]
        unsafe fn lastValueLatency(&self) -> NSTimeInterval;
    }

    unsafe impl ProtocolType for dyn GCLinearInput {}
);
