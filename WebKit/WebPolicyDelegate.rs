//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::Foundation::*;
use crate::WebKit::*;

ns_enum!(
    #[underlying(NSInteger)]
    /**
     @enum WebNavigationType
    @abstract The type of action that triggered a possible navigation.
    @constant WebNavigationTypeLinkClicked A link with an href was clicked.
    @constant WebNavigationTypeFormSubmitted A form was submitted.
    @constant WebNavigationTypeBackForward The user chose back or forward.
    @constant WebNavigationTypeReload The User hit the reload button.
    @constant WebNavigationTypeFormResubmitted A form was resubmitted (by virtue of doing back, forward or reload).
    @constant WebNavigationTypeOther Navigation is taking place for some other reason.
    */
    #[deprecated]
    pub enum WebNavigationType {
        #[deprecated]
        WebNavigationTypeLinkClicked = 0,
        #[deprecated]
        WebNavigationTypeFormSubmitted = 1,
        #[deprecated]
        WebNavigationTypeBackForward = 2,
        #[deprecated]
        WebNavigationTypeReload = 3,
        #[deprecated]
        WebNavigationTypeFormResubmitted = 4,
        #[deprecated]
        WebNavigationTypeOther = 5,
    }
);

extern_static!(WebActionNavigationTypeKey: Option<&'static NSString>);

extern_static!(WebActionElementKey: Option<&'static NSString>);

extern_static!(WebActionButtonKey: Option<&'static NSString>);

extern_static!(WebActionModifierFlagsKey: Option<&'static NSString>);

extern_static!(WebActionOriginalURLKey: Option<&'static NSString>);

extern_protocol!(
    #[deprecated]
    /**
     @protocol WebPolicyDecisionListener
    @discussion This protocol is used to call back with the results of a
    policy decision. This provides the ability to make these decisions
    asyncrhonously, which means the decision can be made by prompting
    with a sheet, for example.
    */
    pub unsafe trait WebPolicyDecisionListener: NSObjectProtocol {
        #[method(use)]
        unsafe fn r#use(&self);

        #[method(download)]
        unsafe fn download(&self);

        #[method(ignore)]
        unsafe fn ignore(&self);
    }

    unsafe impl ProtocolType for dyn WebPolicyDecisionListener {}
);

extern_protocol!(
    #[deprecated]
    /**
     @category WebPolicyDelegate
    @discussion While loading a URL, WebKit asks the WebPolicyDelegate for
    policies that determine the action of what to do with the URL or the data that
    the URL represents. Typically, the policy handler methods are called in this order:

    decidePolicyForNewWindowAction:request:newFrameName:decisionListener: (at most once)<BR>
    decidePolicyForNavigationAction:request:frame:decisionListener: (zero or more times)<BR>
    decidePolicyForMIMEType:request:frame: (zero or more times)<BR>

    New window policy is always checked. Navigation policy is checked
    for the initial load and every redirect unless blocked by an
    earlier policy. Content policy is checked once the content type is
    known, unless an earlier policy prevented it.

    In rare cases, content policy might be checked more than
    once. This occurs when loading a "multipart/x-mixed-replace"
    document, also known as "server push". In this case, multiple
    documents come in one navigation, with each replacing the last. In
    this case, conent policy will be checked for each one.
    */
    pub unsafe trait WebPolicyDelegate: NSObjectProtocol {
        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSURLRequest",
            feature = "WebKit_WebFrame",
            feature = "WebKit_WebView"
        ))]
        #[optional]
        #[method(webView:decidePolicyForNavigationAction:request:frame:decisionListener:)]
        unsafe fn webView_decidePolicyForNavigationAction_request_frame_decisionListener(
            &self,
            web_view: Option<&WebView>,
            action_information: Option<&NSDictionary>,
            request: Option<&NSURLRequest>,
            frame: Option<&WebFrame>,
            listener: Option<&ProtocolObject<dyn WebPolicyDecisionListener>>,
        );

        #[cfg(all(
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString",
            feature = "Foundation_NSURLRequest",
            feature = "WebKit_WebView"
        ))]
        #[optional]
        #[method(webView:decidePolicyForNewWindowAction:request:newFrameName:decisionListener:)]
        unsafe fn webView_decidePolicyForNewWindowAction_request_newFrameName_decisionListener(
            &self,
            web_view: Option<&WebView>,
            action_information: Option<&NSDictionary>,
            request: Option<&NSURLRequest>,
            frame_name: Option<&NSString>,
            listener: Option<&ProtocolObject<dyn WebPolicyDecisionListener>>,
        );

        #[cfg(all(
            feature = "Foundation_NSString",
            feature = "Foundation_NSURLRequest",
            feature = "WebKit_WebFrame",
            feature = "WebKit_WebView"
        ))]
        #[optional]
        #[method(webView:decidePolicyForMIMEType:request:frame:decisionListener:)]
        unsafe fn webView_decidePolicyForMIMEType_request_frame_decisionListener(
            &self,
            web_view: Option<&WebView>,
            r#type: Option<&NSString>,
            request: Option<&NSURLRequest>,
            frame: Option<&WebFrame>,
            listener: Option<&ProtocolObject<dyn WebPolicyDecisionListener>>,
        );

        #[cfg(all(
            feature = "Foundation_NSError",
            feature = "WebKit_WebFrame",
            feature = "WebKit_WebView"
        ))]
        #[optional]
        #[method(webView:unableToImplementPolicyWithError:frame:)]
        unsafe fn webView_unableToImplementPolicyWithError_frame(
            &self,
            web_view: Option<&WebView>,
            error: Option<&NSError>,
            frame: Option<&WebFrame>,
        );
    }

    unsafe impl ProtocolType for dyn WebPolicyDelegate {}
);
