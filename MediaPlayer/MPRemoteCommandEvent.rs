//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::Foundation::*;
use crate::MediaPlayer::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPRemoteCommandEvent")]
    pub struct MPRemoteCommandEvent;

    #[cfg(feature = "MediaPlayer_MPRemoteCommandEvent")]
    unsafe impl ClassType for MPRemoteCommandEvent {
        type Super = NSObject;
    }
);

#[cfg(feature = "MediaPlayer_MPRemoteCommandEvent")]
unsafe impl NSObjectProtocol for MPRemoteCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPRemoteCommandEvent")]
    unsafe impl MPRemoteCommandEvent {
        #[cfg(feature = "MediaPlayer_MPRemoteCommand")]
        /**
          The command that sent the event.
        */
        #[method_id(@__retain_semantics Other command)]
        pub unsafe fn command(&self) -> Id<MPRemoteCommand>;

        /**
          The time when the event occurred.
        */
        #[method(timestamp)]
        pub unsafe fn timestamp(&self) -> NSTimeInterval;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPSkipIntervalCommandEvent")]
    pub struct MPSkipIntervalCommandEvent;

    #[cfg(feature = "MediaPlayer_MPSkipIntervalCommandEvent")]
    unsafe impl ClassType for MPSkipIntervalCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPSkipIntervalCommandEvent")]
unsafe impl NSObjectProtocol for MPSkipIntervalCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPSkipIntervalCommandEvent")]
    unsafe impl MPSkipIntervalCommandEvent {
        /**
          The chosen interval for this skip command event.
        */
        #[method(interval)]
        pub unsafe fn interval(&self) -> NSTimeInterval;
    }
);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum MPSeekCommandEventType {
        MPSeekCommandEventTypeBeginSeeking = 0,
        MPSeekCommandEventTypeEndSeeking = 1,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPSeekCommandEvent")]
    pub struct MPSeekCommandEvent;

    #[cfg(feature = "MediaPlayer_MPSeekCommandEvent")]
    unsafe impl ClassType for MPSeekCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPSeekCommandEvent")]
unsafe impl NSObjectProtocol for MPSeekCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPSeekCommandEvent")]
    unsafe impl MPSeekCommandEvent {
        /**
          The type of seek command event, which specifies whether an external player
         began or ended seeking.
        */
        #[method(type)]
        pub unsafe fn r#type(&self) -> MPSeekCommandEventType;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPRatingCommandEvent")]
    pub struct MPRatingCommandEvent;

    #[cfg(feature = "MediaPlayer_MPRatingCommandEvent")]
    unsafe impl ClassType for MPRatingCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPRatingCommandEvent")]
unsafe impl NSObjectProtocol for MPRatingCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPRatingCommandEvent")]
    unsafe impl MPRatingCommandEvent {
        /**
          The chosen rating for this command event. This value will be within the
         minimumRating and maximumRating values set for the MPRatingCommand object.
        */
        #[method(rating)]
        pub unsafe fn rating(&self) -> c_float;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPChangePlaybackRateCommandEvent")]
    pub struct MPChangePlaybackRateCommandEvent;

    #[cfg(feature = "MediaPlayer_MPChangePlaybackRateCommandEvent")]
    unsafe impl ClassType for MPChangePlaybackRateCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPChangePlaybackRateCommandEvent")]
unsafe impl NSObjectProtocol for MPChangePlaybackRateCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPChangePlaybackRateCommandEvent")]
    unsafe impl MPChangePlaybackRateCommandEvent {
        /**
          The chosen playback rate for this command event. This value will be equal
         to one of the values specified in the supportedPlaybackRates array for the
         MPChangePlaybackRateCommand object.
        */
        #[method(playbackRate)]
        pub unsafe fn playbackRate(&self) -> c_float;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPFeedbackCommandEvent")]
    pub struct MPFeedbackCommandEvent;

    #[cfg(feature = "MediaPlayer_MPFeedbackCommandEvent")]
    unsafe impl ClassType for MPFeedbackCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPFeedbackCommandEvent")]
unsafe impl NSObjectProtocol for MPFeedbackCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPFeedbackCommandEvent")]
    unsafe impl MPFeedbackCommandEvent {
        /**
          Whether the command event is a negative operation. For example, the command
         might ask that the app remove a bookmark for a particular track, rather than
         add it. In this case, the handler for the bookmark command should check this
         flag and remove the bookmark if it is set to YES.

         For like/dislike, a "negative like" might be treated differently from a
         dislike command. The app might want to remove the "like" flag from the
         current track, but not treat it as a dislike command.
        */
        #[method(isNegative)]
        pub unsafe fn isNegative(&self) -> bool;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPChangeLanguageOptionCommandEvent")]
    pub struct MPChangeLanguageOptionCommandEvent;

    #[cfg(feature = "MediaPlayer_MPChangeLanguageOptionCommandEvent")]
    unsafe impl ClassType for MPChangeLanguageOptionCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPChangeLanguageOptionCommandEvent")]
unsafe impl NSObjectProtocol for MPChangeLanguageOptionCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPChangeLanguageOptionCommandEvent")]
    unsafe impl MPChangeLanguageOptionCommandEvent {
        #[cfg(feature = "MediaPlayer_MPNowPlayingInfoLanguageOption")]
        /**
          The requested language option to change.
         The supplied language option may be the Automatic Legible Language Option
         which would mean that best legible language option based on user preferences
         is being requested. See MPNowPlayingInfoLanguageOption isAutomaticLegibleLanguageOption
        */
        #[method_id(@__retain_semantics Other languageOption)]
        pub unsafe fn languageOption(&self) -> Id<MPNowPlayingInfoLanguageOption>;

        /**
          Describes the extent of the changed language option
        */
        #[method(setting)]
        pub unsafe fn setting(&self) -> MPChangeLanguageOptionSetting;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPChangePlaybackPositionCommandEvent")]
    pub struct MPChangePlaybackPositionCommandEvent;

    #[cfg(feature = "MediaPlayer_MPChangePlaybackPositionCommandEvent")]
    unsafe impl ClassType for MPChangePlaybackPositionCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPChangePlaybackPositionCommandEvent")]
unsafe impl NSObjectProtocol for MPChangePlaybackPositionCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPChangePlaybackPositionCommandEvent")]
    unsafe impl MPChangePlaybackPositionCommandEvent {
        /**
          The desired playback position to use when setting the current time of the player.
        */
        #[method(positionTime)]
        pub unsafe fn positionTime(&self) -> NSTimeInterval;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPChangeShuffleModeCommandEvent")]
    pub struct MPChangeShuffleModeCommandEvent;

    #[cfg(feature = "MediaPlayer_MPChangeShuffleModeCommandEvent")]
    unsafe impl ClassType for MPChangeShuffleModeCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPChangeShuffleModeCommandEvent")]
unsafe impl NSObjectProtocol for MPChangeShuffleModeCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPChangeShuffleModeCommandEvent")]
    unsafe impl MPChangeShuffleModeCommandEvent {
        /**
          The desired shuffle type to use when fulfilling the request.
        */
        #[method(shuffleType)]
        pub unsafe fn shuffleType(&self) -> MPShuffleType;

        /**
          Whether or not the selection should be preserved between playback sessions
        */
        #[method(preservesShuffleMode)]
        pub unsafe fn preservesShuffleMode(&self) -> bool;
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MediaPlayer_MPChangeRepeatModeCommandEvent")]
    pub struct MPChangeRepeatModeCommandEvent;

    #[cfg(feature = "MediaPlayer_MPChangeRepeatModeCommandEvent")]
    unsafe impl ClassType for MPChangeRepeatModeCommandEvent {
        #[inherits(NSObject)]
        type Super = MPRemoteCommandEvent;
    }
);

#[cfg(feature = "MediaPlayer_MPChangeRepeatModeCommandEvent")]
unsafe impl NSObjectProtocol for MPChangeRepeatModeCommandEvent {}

extern_methods!(
    #[cfg(feature = "MediaPlayer_MPChangeRepeatModeCommandEvent")]
    unsafe impl MPChangeRepeatModeCommandEvent {
        /**
          The desired repeat type to use when fulfilling the request.
        */
        #[method(repeatType)]
        pub unsafe fn repeatType(&self) -> MPRepeatType;

        /**
          Whether or not the selection should be preserved between playback sessions
        */
        #[method(preservesRepeatMode)]
        pub unsafe fn preservesRepeatMode(&self) -> bool;
    }
);
