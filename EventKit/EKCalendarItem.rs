//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::AppKit::*;
use crate::CoreLocation::*;
use crate::EventKit::*;
use crate::Foundation::*;
use crate::MapKit::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "EventKit_EKCalendarItem")]
    pub struct EKCalendarItem;

    #[cfg(feature = "EventKit_EKCalendarItem")]
    unsafe impl ClassType for EKCalendarItem {
        #[inherits(NSObject)]
        type Super = EKObject;
    }
);

#[cfg(feature = "EventKit_EKCalendarItem")]
unsafe impl NSObjectProtocol for EKCalendarItem {}

extern_methods!(
    #[cfg(feature = "EventKit_EKCalendarItem")]
    unsafe impl EKCalendarItem {
        #[cfg(feature = "Foundation_NSString")]
        /**
         @property   UUID
        @discussion This is now deprecated; use calendarItemIdentifier instead.
        */
        #[method_id(@__retain_semantics Other UUID)]
        pub unsafe fn UUID(&self) -> Id<NSString>;

        #[cfg(feature = "EventKit_EKCalendar")]
        /**
         @property calendar
        @abstract The calendar that this calendar item belongs to.
        @discussion This will be nil for new calendar items until you set it.
        */
        #[method_id(@__retain_semantics Other calendar)]
        pub unsafe fn calendar(&self) -> Option<Id<EKCalendar>>;

        #[cfg(feature = "EventKit_EKCalendar")]
        /**
         @property calendar
        @abstract The calendar that this calendar item belongs to.
        @discussion This will be nil for new calendar items until you set it.
        */
        #[method(setCalendar:)]
        pub unsafe fn setCalendar(&self, calendar: Option<&EKCalendar>);

        #[cfg(feature = "Foundation_NSString")]
        /**
         @property   calendarItemIdentifier
        @abstract   A unique identifier for a calendar item.
        @discussion Item identifiers are not sync-proof in that a full sync will lose
        this identifier, so you should always have a back up plan for dealing
        with a reminder that is no longer fetchable by this property, e.g. by title, etc.
        Use [EKEventStore calendarItemWithIdentifier:] to look up the item by this value.
        */
        #[method_id(@__retain_semantics Other calendarItemIdentifier)]
        pub unsafe fn calendarItemIdentifier(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @property   calendarItemExternalIdentifier
        @abstract   A server-provided identifier for this calendar item
        @discussion This identifier, provided by the server, allows you to reference the same event or reminder across
        multiple devices. For calendars stored locally on the device, including the birthday calendar,
        it simply passes through to calendarItemIdentifier.

        This identifier is unique as of creation for every calendar item.  However, there are some
        cases where duplicate copies of a calendar item can exist in the same database, including:
        - A calendar item was imported from an ICS file into multiple calendars
        - An event was created in a calendar shared with the user and the user was also invited to the event
        - The user is a delegate of a calendar that also has this event
        - A subscribed calendar was added to multiple accounts
        In such cases, you should choose between calendar items based on other factors, such as
        the calendar or source.

        This identifier is the same for all occurrences of a recurring event. If you wish to differentiate
        between occurrences, you may want to use the start date.

        This may be nil for new calendar items that do not yet belong to a calendar.

        In addition, there are two caveats for Exchange-based calendars:
        - This identifier will be different between EventKit on iOS versus OS X
        - This identifier will be different between devices for EKReminders
        */
        #[method_id(@__retain_semantics Other calendarItemExternalIdentifier)]
        pub unsafe fn calendarItemExternalIdentifier(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @property title
        @abstract The title of this calendar item.
        @discussion This will be an empty string for new calendar items until you set it.
        */
        #[method_id(@__retain_semantics Other title)]
        pub unsafe fn title(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        /**
         @property title
        @abstract The title of this calendar item.
        @discussion This will be an empty string for new calendar items until you set it.
        */
        #[method(setTitle:)]
        pub unsafe fn setTitle(&self, title: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other location)]
        pub unsafe fn location(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setLocation:)]
        pub unsafe fn setLocation(&self, location: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other notes)]
        pub unsafe fn notes(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setNotes:)]
        pub unsafe fn setNotes(&self, notes: Option<&NSString>);

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Other URL)]
        pub unsafe fn URL(&self) -> Option<Id<NSURL>>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method(setURL:)]
        pub unsafe fn setURL(&self, url: Option<&NSURL>);

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other lastModifiedDate)]
        pub unsafe fn lastModifiedDate(&self) -> Option<Id<NSDate>>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method_id(@__retain_semantics Other creationDate)]
        pub unsafe fn creationDate(&self) -> Option<Id<NSDate>>;

        #[cfg(feature = "Foundation_NSTimeZone")]
        #[method_id(@__retain_semantics Other timeZone)]
        pub unsafe fn timeZone(&self) -> Option<Id<NSTimeZone>>;

        #[cfg(feature = "Foundation_NSTimeZone")]
        #[method(setTimeZone:)]
        pub unsafe fn setTimeZone(&self, time_zone: Option<&NSTimeZone>);

        /**
          These exist to do simple checks for the presence of data without
         loading said data. While at present only hasRecurrenceRules has a
         fast path, it is a good idea to use these if you only need to know
         the data exists anyway since at some point they will all be a
         simple check.
        */
        #[method(hasAlarms)]
        pub unsafe fn hasAlarms(&self) -> bool;

        #[method(hasRecurrenceRules)]
        pub unsafe fn hasRecurrenceRules(&self) -> bool;

        #[method(hasAttendees)]
        pub unsafe fn hasAttendees(&self) -> bool;

        #[method(hasNotes)]
        pub unsafe fn hasNotes(&self) -> bool;

        #[cfg(all(feature = "EventKit_EKParticipant", feature = "Foundation_NSArray"))]
        /**
          An array of EKParticipant objects
        */
        #[method_id(@__retain_semantics Other attendees)]
        pub unsafe fn attendees(&self) -> Option<Id<NSArray<EKParticipant>>>;

        #[cfg(all(feature = "EventKit_EKAlarm", feature = "Foundation_NSArray"))]
        /**
          An array of EKAlarm objects
        */
        #[method_id(@__retain_semantics Other alarms)]
        pub unsafe fn alarms(&self) -> Option<Id<NSArray<EKAlarm>>>;

        #[cfg(all(feature = "EventKit_EKAlarm", feature = "Foundation_NSArray"))]
        /**
          An array of EKAlarm objects
        */
        #[method(setAlarms:)]
        pub unsafe fn setAlarms(&self, alarms: Option<&NSArray<EKAlarm>>);

        #[cfg(feature = "EventKit_EKAlarm")]
        #[method(addAlarm:)]
        pub unsafe fn addAlarm(&self, alarm: &EKAlarm);

        #[cfg(feature = "EventKit_EKAlarm")]
        #[method(removeAlarm:)]
        pub unsafe fn removeAlarm(&self, alarm: &EKAlarm);

        #[cfg(all(feature = "EventKit_EKRecurrenceRule", feature = "Foundation_NSArray"))]
        /**
         @property   recurrenceRules
        @abstract   An array of EKRecurrenceRules, or nil if none.
        */
        #[method_id(@__retain_semantics Other recurrenceRules)]
        pub unsafe fn recurrenceRules(&self) -> Option<Id<NSArray<EKRecurrenceRule>>>;

        #[cfg(all(feature = "EventKit_EKRecurrenceRule", feature = "Foundation_NSArray"))]
        /**
         @property   recurrenceRules
        @abstract   An array of EKRecurrenceRules, or nil if none.
        */
        #[method(setRecurrenceRules:)]
        pub unsafe fn setRecurrenceRules(
            &self,
            recurrence_rules: Option<&NSArray<EKRecurrenceRule>>,
        );

        #[cfg(feature = "EventKit_EKRecurrenceRule")]
        #[method(addRecurrenceRule:)]
        pub unsafe fn addRecurrenceRule(&self, rule: &EKRecurrenceRule);

        #[cfg(feature = "EventKit_EKRecurrenceRule")]
        #[method(removeRecurrenceRule:)]
        pub unsafe fn removeRecurrenceRule(&self, rule: &EKRecurrenceRule);
    }
);
