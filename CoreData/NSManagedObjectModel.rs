//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreData::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CoreData_NSManagedObjectModel")]
    /**
      Models describe object graphs to be managed. Models (and their entities/properties/fetch request templates) are editable until they are used by a persistent store coordinator, allowing developers to create/modify them dynamically. However, once a model is being used, it MUST NOT be changed. When the persistent store coordinator first fetches data using a model, it will become uneditable. Any attempt to mutate a model or any of its subobjects after that point will cause an exception to be thrown. If you need to modify a model that is in use, create a copy, modify the copy, and then discard the objects with the old model.
    */
    pub struct NSManagedObjectModel;

    #[cfg(feature = "CoreData_NSManagedObjectModel")]
    unsafe impl ClassType for NSManagedObjectModel {
        type Super = NSObject;
    }
);

#[cfg(feature = "CoreData_NSManagedObjectModel")]
/**
  Models describe object graphs to be managed. Models (and their entities/properties/fetch request templates) are editable until they are used by a persistent store coordinator, allowing developers to create/modify them dynamically. However, once a model is being used, it MUST NOT be changed. When the persistent store coordinator first fetches data using a model, it will become uneditable. Any attempt to mutate a model or any of its subobjects after that point will cause an exception to be thrown. If you need to modify a model that is in use, create a copy, modify the copy, and then discard the objects with the old model.
*/
unsafe impl NSCoding for NSManagedObjectModel {}

#[cfg(feature = "CoreData_NSManagedObjectModel")]
/**
  Models describe object graphs to be managed. Models (and their entities/properties/fetch request templates) are editable until they are used by a persistent store coordinator, allowing developers to create/modify them dynamically. However, once a model is being used, it MUST NOT be changed. When the persistent store coordinator first fetches data using a model, it will become uneditable. Any attempt to mutate a model or any of its subobjects after that point will cause an exception to be thrown. If you need to modify a model that is in use, create a copy, modify the copy, and then discard the objects with the old model.
*/
unsafe impl NSFastEnumeration for NSManagedObjectModel {}

#[cfg(feature = "CoreData_NSManagedObjectModel")]
/**
  Models describe object graphs to be managed. Models (and their entities/properties/fetch request templates) are editable until they are used by a persistent store coordinator, allowing developers to create/modify them dynamically. However, once a model is being used, it MUST NOT be changed. When the persistent store coordinator first fetches data using a model, it will become uneditable. Any attempt to mutate a model or any of its subobjects after that point will cause an exception to be thrown. If you need to modify a model that is in use, create a copy, modify the copy, and then discard the objects with the old model.
*/
unsafe impl NSObjectProtocol for NSManagedObjectModel {}

extern_methods!(
    /**
      Models describe object graphs to be managed. Models (and their entities/properties/fetch request templates) are editable until they are used by a persistent store coordinator, allowing developers to create/modify them dynamically. However, once a model is being used, it MUST NOT be changed. When the persistent store coordinator first fetches data using a model, it will become uneditable. Any attempt to mutate a model or any of its subobjects after that point will cause an exception to be thrown. If you need to modify a model that is in use, create a copy, modify the copy, and then discard the objects with the old model.
    */
    #[cfg(feature = "CoreData_NSManagedObjectModel")]
    unsafe impl NSManagedObjectModel {
        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSBundle"))]
        #[method_id(@__retain_semantics Other mergedModelFromBundles:)]
        pub unsafe fn mergedModelFromBundles(
            bundles: Option<&NSArray<NSBundle>>,
        ) -> Option<Id<NSManagedObjectModel>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other modelByMergingModels:)]
        pub unsafe fn modelByMergingModels(
            models: Option<&NSArray<NSManagedObjectModel>>,
        ) -> Option<Id<NSManagedObjectModel>>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[cfg(feature = "Foundation_NSURL")]
        #[method_id(@__retain_semantics Init initWithContentsOfURL:)]
        pub unsafe fn initWithContentsOfURL(
            this: Option<Allocated<Self>>,
            url: &NSURL,
        ) -> Option<Id<Self>>;

        #[cfg(all(
            feature = "CoreData_NSEntityDescription",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other entitiesByName)]
        pub unsafe fn entitiesByName(&self) -> Id<NSDictionary<NSString, NSEntityDescription>>;

        #[cfg(all(
            feature = "CoreData_NSEntityDescription",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Other entities)]
        pub unsafe fn entities(&self) -> Id<NSArray<NSEntityDescription>>;

        #[cfg(all(
            feature = "CoreData_NSEntityDescription",
            feature = "Foundation_NSArray"
        ))]
        #[method(setEntities:)]
        pub unsafe fn setEntities(&self, entities: &NSArray<NSEntityDescription>);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        /**
          returns all available configuration names
        */
        #[method_id(@__retain_semantics Other configurations)]
        pub unsafe fn configurations(&self) -> Id<NSArray<NSString>>;

        #[cfg(all(
            feature = "CoreData_NSEntityDescription",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other entitiesForConfiguration:)]
        pub unsafe fn entitiesForConfiguration(
            &self,
            configuration: Option<&NSString>,
        ) -> Option<Id<NSArray<NSEntityDescription>>>;

        #[cfg(all(
            feature = "CoreData_NSEntityDescription",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSString"
        ))]
        #[method(setEntities:forConfiguration:)]
        pub unsafe fn setEntities_forConfiguration(
            &self,
            entities: &NSArray<NSEntityDescription>,
            configuration: &NSString,
        );

        #[cfg(all(feature = "CoreData_NSFetchRequest", feature = "Foundation_NSString"))]
        #[method(setFetchRequestTemplate:forName:)]
        pub unsafe fn setFetchRequestTemplate_forName(
            &self,
            fetch_request_template: Option<&NSFetchRequest>,
            name: &NSString,
        );

        #[cfg(all(feature = "CoreData_NSFetchRequest", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other fetchRequestTemplateForName:)]
        pub unsafe fn fetchRequestTemplateForName(
            &self,
            name: &NSString,
        ) -> Option<Id<NSFetchRequest>>;

        #[cfg(all(
            feature = "CoreData_NSFetchRequest",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other fetchRequestFromTemplateWithName:substitutionVariables:)]
        pub unsafe fn fetchRequestFromTemplateWithName_substitutionVariables(
            &self,
            name: &NSString,
            variables: &NSDictionary<NSString, Object>,
        ) -> Option<Id<NSFetchRequest>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        /**
         NSDictionary containing localized string values for entities, properties, and error strings related to this model. The key and value pattern follows:
        key = "Entity/NonLocalizedEntityName"
        value = "LocalizedEntityName"

        // for properties of the same non-localized name in differenct entities, which should have different localized names
        key = "Property/NonLocalizedPropertyName/Entity/EntityName"
        value = "LocalizedPropertyName"

        key = "Property/NonLocalizedPropertyName"
        value = "LocalizedPropertyName"

        key = "ErrorString/NonLocalizedErrorString"
        value = "LocalizedErrorString"
        */
        #[method_id(@__retain_semantics Other localizationDictionary)]
        pub unsafe fn localizationDictionary(&self)
            -> Option<Id<NSDictionary<NSString, NSString>>>;

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        /**
         NSDictionary containing localized string values for entities, properties, and error strings related to this model. The key and value pattern follows:
        key = "Entity/NonLocalizedEntityName"
        value = "LocalizedEntityName"

        // for properties of the same non-localized name in differenct entities, which should have different localized names
        key = "Property/NonLocalizedPropertyName/Entity/EntityName"
        value = "LocalizedPropertyName"

        key = "Property/NonLocalizedPropertyName"
        value = "LocalizedPropertyName"

        key = "ErrorString/NonLocalizedErrorString"
        value = "LocalizedErrorString"
        */
        #[method(setLocalizationDictionary:)]
        pub unsafe fn setLocalizationDictionary(
            &self,
            localization_dictionary: Option<&NSDictionary<NSString, NSString>>,
        );

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSBundle",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other mergedModelFromBundles:forStoreMetadata:)]
        pub unsafe fn mergedModelFromBundles_forStoreMetadata(
            bundles: Option<&NSArray<NSBundle>>,
            metadata: &NSDictionary<NSString, Object>,
        ) -> Option<Id<NSManagedObjectModel>>;

        #[cfg(all(
            feature = "Foundation_NSArray",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other modelByMergingModels:forStoreMetadata:)]
        pub unsafe fn modelByMergingModels_forStoreMetadata(
            models: &NSArray<NSManagedObjectModel>,
            metadata: &NSDictionary<NSString, Object>,
        ) -> Option<Id<NSManagedObjectModel>>;

        #[cfg(all(
            feature = "CoreData_NSFetchRequest",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        /**
          Returns the dictionary of fetch request templates, keyed by name, for the model.  If the template contains a predicate with substitution variables, you should instead use fetchRequestFromTemplateWithName:substitutionVariables: to create a new fetch request.
        */
        #[method_id(@__retain_semantics Other fetchRequestTemplatesByName)]
        pub unsafe fn fetchRequestTemplatesByName(
            &self,
        ) -> Id<NSDictionary<NSString, NSFetchRequest>>;

        #[cfg(feature = "Foundation_NSSet")]
        /**
          Returns the collection of developer-defined version identifiers for the model.  For models created in Xcode, this value is set by the developer in the model inspector. Merged models return the combined  collection of identifiers. This value is meant to be used as a debugging hint to help developers determine the models that were combined to create a merged model. The framework does not give models a default identifier, nor does it depend this value at runtime.
        */
        #[method_id(@__retain_semantics Other versionIdentifiers)]
        pub unsafe fn versionIdentifiers(&self) -> Id<NSSet>;

        #[cfg(feature = "Foundation_NSSet")]
        /**
          Returns the collection of developer-defined version identifiers for the model.  For models created in Xcode, this value is set by the developer in the model inspector. Merged models return the combined  collection of identifiers. This value is meant to be used as a debugging hint to help developers determine the models that were combined to create a merged model. The framework does not give models a default identifier, nor does it depend this value at runtime.
        */
        #[method(setVersionIdentifiers:)]
        pub unsafe fn setVersionIdentifiers(&self, version_identifiers: &NSSet);

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method(isConfiguration:compatibleWithStoreMetadata:)]
        pub unsafe fn isConfiguration_compatibleWithStoreMetadata(
            &self,
            configuration: Option<&NSString>,
            metadata: &NSDictionary<NSString, Object>,
        ) -> bool;

        #[cfg(all(
            feature = "Foundation_NSData",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        /**
          Returns a dictionary of the version hashes for the entities in the model, keyed by entity name.  (The dictionary of version hash information is used by Core Data to determine schema compatibility.)
        */
        #[method_id(@__retain_semantics Other entityVersionHashesByName)]
        pub unsafe fn entityVersionHashesByName(&self) -> Id<NSDictionary<NSString, NSData>>;
    }
);
