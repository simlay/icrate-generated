//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreData::*;
use crate::Foundation::*;

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CoreData_NSEntityDescription")]
    /**
      Entities describe the "types" of objects available.
    */
    pub struct NSEntityDescription;

    #[cfg(feature = "CoreData_NSEntityDescription")]
    unsafe impl ClassType for NSEntityDescription {
        type Super = NSObject;
    }
);

#[cfg(feature = "CoreData_NSEntityDescription")]
/**
  Entities describe the "types" of objects available.
*/
unsafe impl NSCoding for NSEntityDescription {}

#[cfg(feature = "CoreData_NSEntityDescription")]
/**
  Entities describe the "types" of objects available.
*/
unsafe impl NSFastEnumeration for NSEntityDescription {}

#[cfg(feature = "CoreData_NSEntityDescription")]
/**
  Entities describe the "types" of objects available.
*/
unsafe impl NSObjectProtocol for NSEntityDescription {}

extern_methods!(
    /**
      Entities describe the "types" of objects available.
    */
    #[cfg(feature = "CoreData_NSEntityDescription")]
    unsafe impl NSEntityDescription {
        #[cfg(all(
            feature = "CoreData_NSManagedObjectContext",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other entityForName:inManagedObjectContext:)]
        pub unsafe fn entityForName_inManagedObjectContext(
            entity_name: &NSString,
            context: &NSManagedObjectContext,
        ) -> Option<Id<NSEntityDescription>>;

        #[cfg(all(
            feature = "CoreData_NSManagedObject",
            feature = "CoreData_NSManagedObjectContext",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other insertNewObjectForEntityForName:inManagedObjectContext:)]
        pub unsafe fn insertNewObjectForEntityForName_inManagedObjectContext(
            entity_name: &NSString,
            context: &NSManagedObjectContext,
        ) -> Id<NSManagedObject>;

        #[cfg(feature = "CoreData_NSManagedObjectModel")]
        #[method_id(@__retain_semantics Other managedObjectModel)]
        pub unsafe fn managedObjectModel(&self) -> Id<NSManagedObjectModel>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other managedObjectClassName)]
        pub unsafe fn managedObjectClassName(&self) -> Id<NSString>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setManagedObjectClassName:)]
        pub unsafe fn setManagedObjectClassName(
            &self,
            managed_object_class_name: Option<&NSString>,
        );

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[method(isAbstract)]
        pub unsafe fn isAbstract(&self) -> bool;

        #[method(setAbstract:)]
        pub unsafe fn setAbstract(&self, r#abstract: bool);

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other subentitiesByName)]
        pub unsafe fn subentitiesByName(&self) -> Id<NSDictionary<NSString, NSEntityDescription>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method_id(@__retain_semantics Other subentities)]
        pub unsafe fn subentities(&self) -> Id<NSArray<NSEntityDescription>>;

        #[cfg(feature = "Foundation_NSArray")]
        #[method(setSubentities:)]
        pub unsafe fn setSubentities(&self, subentities: &NSArray<NSEntityDescription>);

        #[method_id(@__retain_semantics Other superentity)]
        pub unsafe fn superentity(&self) -> Option<Id<NSEntityDescription>>;

        #[cfg(all(
            feature = "CoreData_NSPropertyDescription",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other propertiesByName)]
        pub unsafe fn propertiesByName(&self) -> Id<NSDictionary<NSString, NSPropertyDescription>>;

        #[cfg(all(
            feature = "CoreData_NSPropertyDescription",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Other properties)]
        pub unsafe fn properties(&self) -> Id<NSArray<NSPropertyDescription>>;

        #[cfg(all(
            feature = "CoreData_NSPropertyDescription",
            feature = "Foundation_NSArray"
        ))]
        #[method(setProperties:)]
        pub unsafe fn setProperties(&self, properties: &NSArray<NSPropertyDescription>);

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method_id(@__retain_semantics Other userInfo)]
        pub unsafe fn userInfo(&self) -> Option<Id<NSDictionary>>;

        #[cfg(feature = "Foundation_NSDictionary")]
        #[method(setUserInfo:)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&NSDictionary>);

        #[cfg(all(
            feature = "CoreData_NSAttributeDescription",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        /**
          convenience methods to get the most common (and most relevant) types of properties for an entity
        */
        #[method_id(@__retain_semantics Other attributesByName)]
        pub unsafe fn attributesByName(&self)
            -> Id<NSDictionary<NSString, NSAttributeDescription>>;

        #[cfg(all(
            feature = "CoreData_NSRelationshipDescription",
            feature = "Foundation_NSDictionary",
            feature = "Foundation_NSString"
        ))]
        #[method_id(@__retain_semantics Other relationshipsByName)]
        pub unsafe fn relationshipsByName(
            &self,
        ) -> Id<NSDictionary<NSString, NSRelationshipDescription>>;

        #[cfg(all(
            feature = "CoreData_NSRelationshipDescription",
            feature = "Foundation_NSArray"
        ))]
        #[method_id(@__retain_semantics Other relationshipsWithDestinationEntity:)]
        pub unsafe fn relationshipsWithDestinationEntity(
            &self,
            entity: &NSEntityDescription,
        ) -> Id<NSArray<NSRelationshipDescription>>;

        #[method(isKindOfEntity:)]
        pub unsafe fn isKindOfEntity(&self, entity: &NSEntityDescription) -> bool;

        #[cfg(feature = "Foundation_NSData")]
        /**
          Returns the version hash for the entity.  The version hash is used to uniquely identify an entity based on the collection and configuration of properties for the entity.  The version hash uses only values which affect the persistence of data and the user-defined versionHashModifier value.  (The values which affect persistence are the name of the entity, the version hash of the superentity (if present), if the entity is abstract, and all of the version hashes for the properties.)  This value is stored as part of the version information in the metadata for stores which use this entity, as well as a definition of an entity involved in an NSEntityMapping.
        */
        #[method_id(@__retain_semantics Other versionHash)]
        pub unsafe fn versionHash(&self) -> Id<NSData>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Returns/sets the version hash modifier for the entity.  This value is included in the version hash for the entity, allowing developers to mark/denote an entity as being a different "version" than another, even if all of the values which affect persistence are equal.  (Such a difference is important in cases where the structure of an entity is unchanged, but the format or content of data has changed.)
        */
        #[method_id(@__retain_semantics Other versionHashModifier)]
        pub unsafe fn versionHashModifier(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Returns/sets the version hash modifier for the entity.  This value is included in the version hash for the entity, allowing developers to mark/denote an entity as being a different "version" than another, even if all of the values which affect persistence are equal.  (Such a difference is important in cases where the structure of an entity is unchanged, but the format or content of data has changed.)
        */
        #[method(setVersionHashModifier:)]
        pub unsafe fn setVersionHashModifier(&self, version_hash_modifier: Option<&NSString>);

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other renamingIdentifier)]
        pub unsafe fn renamingIdentifier(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setRenamingIdentifier:)]
        pub unsafe fn setRenamingIdentifier(&self, renaming_identifier: Option<&NSString>);

        #[cfg(all(
            feature = "CoreData_NSFetchIndexDescription",
            feature = "Foundation_NSArray"
        ))]
        /**
          Returns/sets the set of indexes for the entity. Returns/takes an array of NSFetchIndexDescription instances. This value does not form part of the entity's version hash, and may be ignored by stores which do not natively support indexing.
        IMPORTANT: Indexes should be the last things set in a model. Changing an entity hierarchy in any way that could affect the validity of indexes (adding or removing super/subentities, adding or removing properties anywhere in the hierarchy) will cause all exisiting indexes for entities in that hierarchy to be dropped.
        */
        #[method_id(@__retain_semantics Other indexes)]
        pub unsafe fn indexes(&self) -> Id<NSArray<NSFetchIndexDescription>>;

        #[cfg(all(
            feature = "CoreData_NSFetchIndexDescription",
            feature = "Foundation_NSArray"
        ))]
        /**
          Returns/sets the set of indexes for the entity. Returns/takes an array of NSFetchIndexDescription instances. This value does not form part of the entity's version hash, and may be ignored by stores which do not natively support indexing.
        IMPORTANT: Indexes should be the last things set in a model. Changing an entity hierarchy in any way that could affect the validity of indexes (adding or removing super/subentities, adding or removing properties anywhere in the hierarchy) will cause all exisiting indexes for entities in that hierarchy to be dropped.
        */
        #[method(setIndexes:)]
        pub unsafe fn setIndexes(&self, indexes: &NSArray<NSFetchIndexDescription>);

        #[cfg(feature = "Foundation_NSArray")]
        /**
          Returns/sets uniqueness constraints for the entity. A uniqueness constraint is a set of one or more attributes whose value must be unique over the set of instances of that entity.

        Sets an array of arrays, each of which contains one or more NSAttributeDescription or NSString instances (strings must be the names of attributes on the entity) on which the constraint is registered.
        Returns an array of arrays, each of which contains instances of NSString which identify the attributes on the entity that comprise the constraint.
        This value forms part of the entity's version hash. Stores which do not support uniqueness constraints should refuse to initialize when given a model containing such constraints.
        Discussion: uniqueness constraint violations can be computationally expensive to handle. It is highly suggested that there be only one uniqueness constraint per entity hierarchy,
        although subentites may extend a sueprentity's constraint.
        */
        #[method_id(@__retain_semantics Other uniquenessConstraints)]
        pub unsafe fn uniquenessConstraints(&self) -> Id<NSArray<NSArray<Object>>>;

        #[cfg(feature = "Foundation_NSArray")]
        /**
          Returns/sets uniqueness constraints for the entity. A uniqueness constraint is a set of one or more attributes whose value must be unique over the set of instances of that entity.

        Sets an array of arrays, each of which contains one or more NSAttributeDescription or NSString instances (strings must be the names of attributes on the entity) on which the constraint is registered.
        Returns an array of arrays, each of which contains instances of NSString which identify the attributes on the entity that comprise the constraint.
        This value forms part of the entity's version hash. Stores which do not support uniqueness constraints should refuse to initialize when given a model containing such constraints.
        Discussion: uniqueness constraint violations can be computationally expensive to handle. It is highly suggested that there be only one uniqueness constraint per entity hierarchy,
        although subentites may extend a sueprentity's constraint.
        */
        #[method(setUniquenessConstraints:)]
        pub unsafe fn setUniquenessConstraints(
            &self,
            uniqueness_constraints: &NSArray<NSArray<Object>>,
        );

        #[cfg(feature = "Foundation_NSArray")]
        /**
           Getter returns an array of arrays of NSPropertyDescription objects describing the components of the indexes.
        Setter takes an array of arrays of NSPropertyDescription objects and/or strings that are the names of properties of the entity on which the index is created. The special strings @"self" and @"entity" can be used to indicate that an index should contain a reference to the object's primary or entity key.
        This value does not form part of the entity's version hash, and may be ignored by stores which do not natively support compound indexes.
        */
        #[deprecated = "Use NSEntityDescription.indexes instead"]
        #[method_id(@__retain_semantics Other compoundIndexes)]
        pub unsafe fn compoundIndexes(&self) -> Id<NSArray<NSArray<Object>>>;

        #[cfg(feature = "Foundation_NSArray")]
        /**
           Getter returns an array of arrays of NSPropertyDescription objects describing the components of the indexes.
        Setter takes an array of arrays of NSPropertyDescription objects and/or strings that are the names of properties of the entity on which the index is created. The special strings @"self" and @"entity" can be used to indicate that an index should contain a reference to the object's primary or entity key.
        This value does not form part of the entity's version hash, and may be ignored by stores which do not natively support compound indexes.
        */
        #[deprecated = "Use NSEntityDescription.indexes instead"]
        #[method(setCompoundIndexes:)]
        pub unsafe fn setCompoundIndexes(&self, compound_indexes: &NSArray<NSArray<Object>>);

        #[cfg(feature = "Foundation_NSExpression")]
        /**
          Expression used to compute the CoreSpotlight display name for instance of this entity.
        */
        #[method_id(@__retain_semantics Other coreSpotlightDisplayNameExpression)]
        pub unsafe fn coreSpotlightDisplayNameExpression(&self) -> Id<NSExpression>;

        #[cfg(feature = "Foundation_NSExpression")]
        /**
          Expression used to compute the CoreSpotlight display name for instance of this entity.
        */
        #[method(setCoreSpotlightDisplayNameExpression:)]
        pub unsafe fn setCoreSpotlightDisplayNameExpression(
            &self,
            core_spotlight_display_name_expression: &NSExpression,
        );
    }
);
