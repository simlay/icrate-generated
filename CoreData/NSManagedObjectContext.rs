//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreData::*;
use crate::Foundation::*;

extern_static!(NSManagedObjectContextWillSaveNotification: &'static NSString);

extern_static!(NSManagedObjectContextDidSaveNotification: &'static NSString);

extern_static!(NSManagedObjectContextObjectsDidChangeNotification: &'static NSString);

extern_static!(NSManagedObjectContextDidSaveObjectIDsNotification: &'static NSString);

extern_static!(NSManagedObjectContextDidMergeChangesObjectIDsNotification: &'static NSString);

extern_static!(NSInsertedObjectsKey: &'static NSString);

extern_static!(NSUpdatedObjectsKey: &'static NSString);

extern_static!(NSDeletedObjectsKey: &'static NSString);

extern_static!(NSRefreshedObjectsKey: &'static NSString);

extern_static!(NSInvalidatedObjectsKey: &'static NSString);

extern_static!(NSManagedObjectContextQueryGenerationKey: &'static NSString);

extern_static!(NSInvalidatedAllObjectsKey: &'static NSString);

extern_static!(NSInsertedObjectIDsKey: &'static NSString);

extern_static!(NSUpdatedObjectIDsKey: &'static NSString);

extern_static!(NSDeletedObjectIDsKey: &'static NSString);

extern_static!(NSRefreshedObjectIDsKey: &'static NSString);

extern_static!(NSInvalidatedObjectIDsKey: &'static NSString);

ns_enum!(
    #[underlying(NSUInteger)]
    pub enum NSManagedObjectContextConcurrencyType {
        #[deprecated = "Use another NSManagedObjectContextConcurrencyType"]
        NSConfinementConcurrencyType = 0x00,
        NSPrivateQueueConcurrencyType = 0x01,
        NSMainQueueConcurrencyType = 0x02,
    }
);

extern_class!(
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CoreData_NSManagedObjectContext")]
    pub struct NSManagedObjectContext;

    #[cfg(feature = "CoreData_NSManagedObjectContext")]
    unsafe impl ClassType for NSManagedObjectContext {
        type Super = NSObject;
    }
);

#[cfg(feature = "CoreData_NSManagedObjectContext")]
unsafe impl NSCoding for NSManagedObjectContext {}

#[cfg(feature = "CoreData_NSManagedObjectContext")]
unsafe impl NSLocking for NSManagedObjectContext {}

#[cfg(feature = "CoreData_NSManagedObjectContext")]
unsafe impl NSObjectProtocol for NSManagedObjectContext {}

extern_methods!(
    #[cfg(feature = "CoreData_NSManagedObjectContext")]
    unsafe impl NSManagedObjectContext {
        #[deprecated = "Use -initWithConcurrencyType: instead"]
        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Id<Self>;

        #[deprecated = "Use -initWithConcurrencyType: instead"]
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

        #[method_id(@__retain_semantics Init initWithConcurrencyType:)]
        pub unsafe fn initWithConcurrencyType(
            this: Option<Allocated<Self>>,
            ct: NSManagedObjectContextConcurrencyType,
        ) -> Id<Self>;

        #[method(performBlock:)]
        pub unsafe fn performBlock(&self, block: &Block<(), ()>);

        #[method(performBlockAndWait:)]
        pub unsafe fn performBlockAndWait(&self, block: &Block<(), ()>);

        #[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
        /**
          coordinator which provides model and handles persistency (multiple contexts can share a coordinator)
        */
        #[method_id(@__retain_semantics Other persistentStoreCoordinator)]
        pub unsafe fn persistentStoreCoordinator(&self)
            -> Option<Id<NSPersistentStoreCoordinator>>;

        #[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
        /**
          coordinator which provides model and handles persistency (multiple contexts can share a coordinator)
        */
        #[method(setPersistentStoreCoordinator:)]
        pub unsafe fn setPersistentStoreCoordinator(
            &self,
            persistent_store_coordinator: Option<&NSPersistentStoreCoordinator>,
        );

        #[method_id(@__retain_semantics Other parentContext)]
        pub unsafe fn parentContext(&self) -> Option<Id<NSManagedObjectContext>>;

        #[method(setParentContext:)]
        pub unsafe fn setParentContext(&self, parent_context: Option<&NSManagedObjectContext>);

        #[cfg(feature = "Foundation_NSString")]
        /**
          custom label for a context.  NSPrivateQueueConcurrencyType contexts will set the label on their queue
        */
        #[method_id(@__retain_semantics Other name)]
        pub unsafe fn name(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          custom label for a context.  NSPrivateQueueConcurrencyType contexts will set the label on their queue
        */
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "Foundation_NSUndoManager")]
        #[method_id(@__retain_semantics Other undoManager)]
        pub unsafe fn undoManager(&self) -> Option<Id<NSUndoManager>>;

        #[cfg(feature = "Foundation_NSUndoManager")]
        #[method(setUndoManager:)]
        pub unsafe fn setUndoManager(&self, undo_manager: Option<&NSUndoManager>);

        #[method(hasChanges)]
        pub unsafe fn hasChanges(&self) -> bool;

        #[cfg(feature = "Foundation_NSMutableDictionary")]
        #[method_id(@__retain_semantics Other userInfo)]
        pub unsafe fn userInfo(&self) -> Id<NSMutableDictionary, Owned>;

        #[method(concurrencyType)]
        pub unsafe fn concurrencyType(&self) -> NSManagedObjectContextConcurrencyType;

        #[cfg(all(
            feature = "CoreData_NSManagedObject",
            feature = "CoreData_NSManagedObjectID"
        ))]
        #[method_id(@__retain_semantics Other objectRegisteredForID:)]
        pub unsafe fn objectRegisteredForID(
            &self,
            object_id: &NSManagedObjectID,
        ) -> Option<Id<NSManagedObject>>;

        #[cfg(all(
            feature = "CoreData_NSManagedObject",
            feature = "CoreData_NSManagedObjectID"
        ))]
        #[method_id(@__retain_semantics Other objectWithID:)]
        pub unsafe fn objectWithID(&self, object_id: &NSManagedObjectID) -> Id<NSManagedObject>;

        #[cfg(all(
            feature = "CoreData_NSManagedObject",
            feature = "CoreData_NSManagedObjectID",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other existingObjectWithID:error:_)]
        pub unsafe fn existingObjectWithID_error(
            &self,
            object_id: &NSManagedObjectID,
        ) -> Result<Id<NSManagedObject>, Id<NSError>>;

        #[cfg(all(
            feature = "CoreData_NSFetchRequest",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other executeFetchRequest:error:_)]
        pub unsafe fn executeFetchRequest_error(
            &self,
            request: &NSFetchRequest,
        ) -> Result<Id<NSArray>, Id<NSError>>;

        #[cfg(all(
            feature = "CoreData_NSPersistentStoreRequest",
            feature = "CoreData_NSPersistentStoreResult",
            feature = "Foundation_NSError"
        ))]
        #[method_id(@__retain_semantics Other executeRequest:error:_)]
        pub unsafe fn executeRequest_error(
            &self,
            request: &NSPersistentStoreRequest,
        ) -> Result<Id<NSPersistentStoreResult>, Id<NSError>>;

        #[cfg(feature = "CoreData_NSManagedObject")]
        #[method(insertObject:)]
        pub unsafe fn insertObject(&self, object: &NSManagedObject);

        #[cfg(feature = "CoreData_NSManagedObject")]
        #[method(deleteObject:)]
        pub unsafe fn deleteObject(&self, object: &NSManagedObject);

        #[cfg(feature = "CoreData_NSManagedObject")]
        #[method(refreshObject:mergeChanges:)]
        pub unsafe fn refreshObject_mergeChanges(&self, object: &NSManagedObject, flag: bool);

        #[cfg(feature = "CoreData_NSManagedObject")]
        #[method(detectConflictsForObject:)]
        pub unsafe fn detectConflictsForObject(&self, object: &NSManagedObject);

        #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSString"))]
        #[method(observeValueForKeyPath:ofObject:change:context:)]
        pub unsafe fn observeValueForKeyPath_ofObject_change_context(
            &self,
            key_path: Option<&NSString>,
            object: Option<&Object>,
            change: Option<&NSDictionary<NSString, Object>>,
            context: *mut c_void,
        );

        #[method(processPendingChanges)]
        pub unsafe fn processPendingChanges(&self);

        #[cfg(feature = "CoreData_NSPersistentStore")]
        #[method(assignObject:toPersistentStore:)]
        pub unsafe fn assignObject_toPersistentStore(
            &self,
            object: &Object,
            store: &NSPersistentStore,
        );

        #[cfg(all(feature = "CoreData_NSManagedObject", feature = "Foundation_NSSet"))]
        #[method_id(@__retain_semantics Other insertedObjects)]
        pub unsafe fn insertedObjects(&self) -> Id<NSSet<NSManagedObject>>;

        #[cfg(all(feature = "CoreData_NSManagedObject", feature = "Foundation_NSSet"))]
        #[method_id(@__retain_semantics Other updatedObjects)]
        pub unsafe fn updatedObjects(&self) -> Id<NSSet<NSManagedObject>>;

        #[cfg(all(feature = "CoreData_NSManagedObject", feature = "Foundation_NSSet"))]
        #[method_id(@__retain_semantics Other deletedObjects)]
        pub unsafe fn deletedObjects(&self) -> Id<NSSet<NSManagedObject>>;

        #[cfg(all(feature = "CoreData_NSManagedObject", feature = "Foundation_NSSet"))]
        #[method_id(@__retain_semantics Other registeredObjects)]
        pub unsafe fn registeredObjects(&self) -> Id<NSSet<NSManagedObject>>;

        #[method(undo)]
        pub unsafe fn undo(&self);

        #[method(redo)]
        pub unsafe fn redo(&self);

        #[method(reset)]
        pub unsafe fn reset(&self);

        #[method(rollback)]
        pub unsafe fn rollback(&self);

        #[cfg(feature = "Foundation_NSError")]
        #[method(save:_)]
        pub unsafe fn save(&self) -> Result<(), Id<NSError>>;

        #[method(refreshAllObjects)]
        pub unsafe fn refreshAllObjects(&self);

        #[deprecated = "Use a queue style context and -performBlockAndWait: instead"]
        #[method(lock)]
        pub unsafe fn lock(&self);

        #[deprecated = "Use a queue style context and -performBlockAndWait: instead"]
        #[method(unlock)]
        pub unsafe fn unlock(&self);

        #[deprecated = "Use a queue style context and -performBlock: instead"]
        #[method(tryLock)]
        pub unsafe fn tryLock(&self) -> bool;

        /**
          The default is YES.
        */
        #[method(propagatesDeletesAtEndOfEvent)]
        pub unsafe fn propagatesDeletesAtEndOfEvent(&self) -> bool;

        /**
          The default is YES.
        */
        #[method(setPropagatesDeletesAtEndOfEvent:)]
        pub unsafe fn setPropagatesDeletesAtEndOfEvent(
            &self,
            propagates_deletes_at_end_of_event: bool,
        );

        /**
          The default is NO.
        */
        #[method(retainsRegisteredObjects)]
        pub unsafe fn retainsRegisteredObjects(&self) -> bool;

        /**
          The default is NO.
        */
        #[method(setRetainsRegisteredObjects:)]
        pub unsafe fn setRetainsRegisteredObjects(&self, retains_registered_objects: bool);

        /**
           set the rule to handle inaccessible faults.  If YES, then the managed object is marked deleted and all its properties, including scalars, nonnullable, and mandatory properties, will be nil or zero’d out.  If NO, the context will throw an exception. Managed objects that are inaccessible because their context is nil due to memory management issues will throw an exception regardless.
        */
        #[method(shouldDeleteInaccessibleFaults)]
        pub unsafe fn shouldDeleteInaccessibleFaults(&self) -> bool;

        /**
           set the rule to handle inaccessible faults.  If YES, then the managed object is marked deleted and all its properties, including scalars, nonnullable, and mandatory properties, will be nil or zero’d out.  If NO, the context will throw an exception. Managed objects that are inaccessible because their context is nil due to memory management issues will throw an exception regardless.
        */
        #[method(setShouldDeleteInaccessibleFaults:)]
        pub unsafe fn setShouldDeleteInaccessibleFaults(
            &self,
            should_delete_inaccessible_faults: bool,
        );

        #[cfg(all(
            feature = "CoreData_NSManagedObject",
            feature = "CoreData_NSManagedObjectID",
            feature = "CoreData_NSPropertyDescription"
        ))]
        #[method(shouldHandleInaccessibleFault:forObjectID:triggeredByProperty:)]
        pub unsafe fn shouldHandleInaccessibleFault_forObjectID_triggeredByProperty(
            &self,
            fault: &NSManagedObject,
            oid: &NSManagedObjectID,
            property: Option<&NSPropertyDescription>,
        ) -> bool;

        /**
          a negative value is considered infinite.  The default is infinite staleness.
        */
        #[method(stalenessInterval)]
        pub unsafe fn stalenessInterval(&self) -> NSTimeInterval;

        /**
          a negative value is considered infinite.  The default is infinite staleness.
        */
        #[method(setStalenessInterval:)]
        pub unsafe fn setStalenessInterval(&self, staleness_interval: NSTimeInterval);

        /**
          default: NSErrorMergePolicy
        */
        #[method_id(@__retain_semantics Other mergePolicy)]
        pub unsafe fn mergePolicy(&self) -> Id<Object>;

        /**
          default: NSErrorMergePolicy
        */
        #[method(setMergePolicy:)]
        pub unsafe fn setMergePolicy(&self, merge_policy: &Object);

        #[cfg(all(
            feature = "CoreData_NSManagedObject",
            feature = "Foundation_NSArray",
            feature = "Foundation_NSError"
        ))]
        #[method(obtainPermanentIDsForObjects:error:_)]
        pub unsafe fn obtainPermanentIDsForObjects_error(
            &self,
            objects: &NSArray<NSManagedObject>,
        ) -> Result<(), Id<NSError>>;

        #[cfg(feature = "Foundation_NSNotification")]
        #[method(mergeChangesFromContextDidSaveNotification:)]
        pub unsafe fn mergeChangesFromContextDidSaveNotification(
            &self,
            notification: &NSNotification,
        );

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSDictionary"))]
        #[method(mergeChangesFromRemoteContextSave:intoContexts:)]
        pub unsafe fn mergeChangesFromRemoteContextSave_intoContexts(
            change_notification_data: &NSDictionary,
            contexts: &NSArray<NSManagedObjectContext>,
        );

        #[cfg(feature = "CoreData_NSQueryGenerationToken")]
        /**
          Return the query generation currently in use by this context. Will be one of the following:
         - nil, default value => this context is not using generational querying
         - an opaque token => specifies the generation of data this context is vending

         All child contexts will return nil.
        */
        #[method_id(@__retain_semantics Other queryGenerationToken)]
        pub unsafe fn queryGenerationToken(&self) -> Option<Id<NSQueryGenerationToken>>;

        #[cfg(all(
            feature = "CoreData_NSQueryGenerationToken",
            feature = "Foundation_NSError"
        ))]
        #[method(setQueryGenerationFromToken:error:_)]
        pub unsafe fn setQueryGenerationFromToken_error(
            &self,
            generation: Option<&NSQueryGenerationToken>,
        ) -> Result<(), Id<NSError>>;

        /**
          Whether the context automatically merges changes saved to its coordinator or parent context. Setting this property to YES when the context is pinned to a non-current query generation is not supported.
        */
        #[method(automaticallyMergesChangesFromParent)]
        pub unsafe fn automaticallyMergesChangesFromParent(&self) -> bool;

        /**
          Whether the context automatically merges changes saved to its coordinator or parent context. Setting this property to YES when the context is pinned to a non-current query generation is not supported.
        */
        #[method(setAutomaticallyMergesChangesFromParent:)]
        pub unsafe fn setAutomaticallyMergesChangesFromParent(
            &self,
            automatically_merges_changes_from_parent: bool,
        );

        #[cfg(feature = "Foundation_NSString")]
        /**
          Set the author for the context, this will be used as an identifier in the Persistent History Transactions (NSPersistentHistoryTransaction)
        */
        #[method_id(@__retain_semantics Other transactionAuthor)]
        pub unsafe fn transactionAuthor(&self) -> Option<Id<NSString>>;

        #[cfg(feature = "Foundation_NSString")]
        /**
          Set the author for the context, this will be used as an identifier in the Persistent History Transactions (NSPersistentHistoryTransaction)
        */
        #[method(setTransactionAuthor:)]
        pub unsafe fn setTransactionAuthor(&self, transaction_author: Option<&NSString>);
    }
);
